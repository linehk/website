<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>Nim手册</title>
<style type="text/css" >
/*
Stylesheet for use with Docutils/rst2html.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.

Modified from Chad Skeeters' rst2html-style
https://bitbucket.org/cskeeters/rst2html-style/

Modified by Boyd Greenfield and narimiran
*/

html {
  font-size: 100%;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%; }

body {
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: 1.125em;
  line-height: 1.5;
  color: #222;
  background-color: #FCFCFC; }

/* Skeleton grid */
.container {
  position: relative;
  width: 100%;
  max-width: 1050px;
  margin: 0 auto;
  padding: 0;
  box-sizing: border-box; }

.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box;
  margin-left: 1%;
}

.column:first-child,
.columns:first-child {
  margin-left: 0; }

.three.columns {
  width: 19%; }

.nine.columns {
  width: 80.0%; }

.twelve.columns {
  width: 100%;
  margin-left: 0; }

@media screen and (max-width: 860px) {
  .three.columns {
    display: none;
  }
  .nine.columns {
    width: 98.0%;
  }
  body {
    font-size: 1em;
    line-height: 1.35;
  }
}

cite {
  font-style: italic !important; }


/* Nim search input */
div#searchInputDiv {
  margin-bottom: 1em;
}
input#searchInput {
  width: 80%;
}

/*
 * Some custom formatting for input forms.
 * This also fixes input form colors on Firefox with a dark system theme on Linux.
 */
input {
  -moz-appearance: none;
  color: #333;
  background-color: #f8f8f8;
  border: 1px solid #aaa;
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-size: 0.9em;
  padding: 6px;
}
input:focus {
  border: 1px solid #1fa0eb;
  box-shadow: 0 0 2px #1fa0eb;
}

/* Docgen styles */
/* Links */
a {
  color: #07b;
  text-decoration: none;
}

a span.Identifier {
  text-decoration: underline;
  text-decoration-color: #aab;
}

a.reference-toplevel {
  font-weight: bold;
}

a.toc-backref {
  text-decoration: none;
  color: #222; }

a.link-seesrc {
  color: #607c9f;
  font-size: 0.9em;
  font-style: italic; }

a:hover,
a:focus {
  color: #607c9f;
  text-decoration: underline; }

a:hover span.Identifier {
  color: #607c9f;
}


sub,
sup {
  position: relative;
  font-size: 75%;
  line-height: 0;
  vertical-align: baseline; }

sup {
  top: -0.5em; }

sub {
  bottom: -0.25em; }

img {
  width: auto;
  height: auto;
  max-width: 100%;
  vertical-align: middle;
  border: 0;
  -ms-interpolation-mode: bicubic; }

@media print {
  * {
    color: black !important;
    text-shadow: none !important;
    background: transparent !important;
    box-shadow: none !important; }

  a,
  a:visited {
    text-decoration: underline; }

  a[href]:after {
    content: " (" attr(href) ")"; }

  abbr[title]:after {
    content: " (" attr(title) ")"; }

  .ir a:after,
  a[href^="javascript:"]:after,
  a[href^="#"]:after {
    content: ""; }

  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid; }

  thead {
    display: table-header-group; }

  tr,
  img {
    page-break-inside: avoid; }

  img {
    max-width: 100% !important; }

  @page {
    margin: 0.5cm; }

  h1 {
    page-break-before: always; }

  h1.title {
    page-break-before: avoid; }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3; }

  h2,
  h3 {
    page-break-after: avoid; }
}


p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

small {
  font-size: 85%; }

strong {
  font-weight: 600;
  font-size: 0.95em;
  color: #3c3c3c;
}

em {
  font-style: italic; }

h1 {
  font-size: 1.8em;
  font-weight: 400;
  padding-bottom: .25em;
  border-bottom: 1px solid #aaa;
  margin-top: 2.5em;
  margin-bottom: 1em;
  line-height: 1.2em; }

h1.title {
  padding-bottom: 1em;
  border-bottom: 0px;
  font-size: 2.5em;
  text-align: center;
  font-weight: 900;
  margin-top: 0.75em;
  margin-bottom: 0em;
}

h2 {
  font-size: 1.3em;
  margin-top: 2em; }

h2.subtitle {
  text-align: center; }

h3 {
  font-size: 1.125em;
  font-style: italic;
  margin-top: 1.5em; }

h4 {
  font-size: 1.125em;
  margin-top: 1em; }

h5 {
  font-size: 1.125em;
  margin-top: 0.75em; }

h6 {
  font-size: 1.1em; }


ul,
ol {
  padding: 0;
  margin-top: 0.5em;
  margin-left: 0.75em; }

ul ul,
ul ol,
ol ol,
ol ul {
  margin-bottom: 0;
  margin-left: 1.25em; }

li {
    list-style-type: circle;
}

ul.simple-boot li {
    list-style-type: none;
    margin-left: 0em;
    margin-bottom: 0.5em;
}

ol.simple > li, ul.simple > li {
  margin-bottom: 0.25em;
  margin-left: 0.4em }

ul.simple.simple-toc > li {
    margin-top: 1em;
}

ul.simple-toc {
  list-style: none;
  font-size: 0.9em;
  margin-left: -0.3em;
  margin-top: 1em; }

ul.simple-toc > li {
    list-style-type: none;
}

ul.simple-toc-section {
  list-style-type: circle;
  margin-left: 1em;
  color: #6c9aae; }


ol.arabic {
  list-style: decimal; }

ol.loweralpha {
  list-style: lower-alpha; }

ol.upperalpha {
  list-style: upper-alpha; }

ol.lowerroman {
  list-style: lower-roman; }

ol.upperroman {
  list-style: upper-roman; }

ul.auto-toc {
  list-style-type: none; }


dl {
  margin-bottom: 1.5em; }

dt {
  margin-bottom: -0.5em;
  margin-left: 0.0em; }

dd {
  margin-left: 2.0em;
  margin-bottom: 3.0em;
  margin-top: 0.5em; }


hr {
  margin: 2em 0;
  border: 0;
  border-top: 1px solid #aaa; }

blockquote {
  font-size: 0.9em;
  font-style: italic;
  padding-left: 0.5em;
  margin-left: 0;
  border-left: 5px solid #bbc;
}

.pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  font-weight: 500;
  font-size: 0.85em;
  background-color: #f0f3ff;
  padding-left: 3px;
  padding-right: 3px;
  border-radius: 4px;
}

pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  color: #222;
  font-weight: 500;
  display: inline-block;
  box-sizing: border-box;
  min-width: 100%;
  padding: 0.5em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  font-size: 0.85em;
  white-space: pre !important;
  overflow-y: hidden;
  overflow-x: visible;
  background-color: ghostwhite;
  border: 1px solid #dde;
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll; }


/* Nim line-numbered tables */
.line-nums-table {
  width: 100%;
  table-layout: fixed; }

table.line-nums-table {
  border-radius: 4px;
  border: 1px solid #cccccc;
  background-color: ghostwhite;
  border-collapse: separate;
  margin-top: 15px;
  margin-bottom: 25px; }

.line-nums-table tbody {
  border: none; }

.line-nums-table td pre {
  border: none;
  background-color: transparent; }

.line-nums-table td.blob-line-nums {
  width: 28px; }

.line-nums-table td.blob-line-nums pre {
  color: #b0b0b0;
  -webkit-filter: opacity(75%);
  text-align: right;
  border-color: transparent;
  background-color: transparent;
  padding-left: 0px;
  margin-left: 0px;
  padding-right: 0px;
  margin-right: 0px; }


table {
  max-width: 100%;
  background-color: transparent;
  margin-top: 0.5em;
  margin-bottom: 1.5em;
  border-collapse: collapse;
  border-color: #ccc;
  border-spacing: 0;
  font-size: 0.9em;
}

table th, table td {
  padding: 0px 0.5em 0px;
}

table th {
  background-color: #e8e8e8;
  font-weight: bold; }

table th.docinfo-name {
    background-color: transparent;
}

table tr:hover {
  background-color: ghostwhite; }


/* rst2html default used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0; }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 !important; }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 !important; }

.last, .with-subtitle {
  margin-bottom: 0 !important; }

.hidden {
  display: none; }

blockquote.epigraph {
  margin: 2em 5em; }

dl.docutils dd {
  margin-bottom: 0.5em; }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden; }


div.figure {
  margin-left: 2em;
  margin-right: 2em; }

div.footer, div.header {
  clear: both;
  text-align: center;
  color: #666;
  font-size: smaller; }

div.footer {
    padding-top: 5em;
}

div.line-block {
  display: block;
  margin-top: 1em;
  margin-bottom: 1em; }

div.line-block div.line-block {
  margin-top: 0;
  margin-bottom: 0;
  margin-left: 1.5em; }

div.topic {
  margin: 2em; }

div.search_results {
  background-color: antiquewhite;
  margin: 3em;
  padding: 1em;
  border: 1px solid #4d4d4d;
}

div#global-links ul {
  margin-left: 0;
  list-style-type: none;
}

div#global-links > simple-boot {
    margin-left: 3em;
}

hr.docutils {
  width: 75%; }

img.align-left, .figure.align-left, object.align-left {
  clear: left;
  float: left;
  margin-right: 1em; }

img.align-right, .figure.align-right, object.align-right {
  clear: right;
  float: right;
  margin-left: 1em; }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto; }

.align-left {
  text-align: left; }

.align-center {
  clear: both;
  text-align: center; }

.align-right {
  text-align: right; }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit; }

p.attribution {
  text-align: right;
  margin-left: 50%; }

p.caption {
  font-style: italic; }

p.credits {
  font-style: italic;
  font-size: smaller; }

p.label {
  white-space: nowrap; }

p.rubric {
  font-weight: bold;
  font-size: larger;
  color: maroon;
  text-align: center; }

p.topic-title {
  font-weight: bold; }

pre.address {
  margin-bottom: 0;
  margin-top: 0;
  font: inherit; }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em;
  margin-right: 2em; }

pre.code .ln {
  color: grey; }

/* line numbers */
pre.code, code {
  background-color: #eeeeee; }

pre.code .comment, code .comment {
  color: #5c6576; }

pre.code .keyword, code .keyword {
  color: #3B0D06;
  font-weight: bold; }

pre.code .literal.string, code .literal.string {
  color: #0c5404; }

pre.code .name.builtin, code .name.builtin {
  color: #352b84; }

pre.code .deleted, code .deleted {
  background-color: #DEB0A1; }

pre.code .inserted, code .inserted {
  background-color: #A3D289; }

span.classifier {
  font-style: oblique; }

span.classifier-delimiter {
  font-weight: bold; }

span.option {
  white-space: nowrap; }

span.problematic {
  color: #b30000; }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80%; }

span.DecNumber {
  color: #252dbe; }

span.BinNumber {
  color: #252dbe; }

span.HexNumber {
  color: #252dbe; }

span.OctNumber {
  color: #252dbe; }

span.FloatNumber {
  color: #252dbe; }

span.Identifier {
  color: #222; }

span.Keyword {
  font-weight: 600;
  color: #5e8f60; }

span.StringLit {
  color: #a4255b; }

span.LongStringLit {
  color: #a4255b; }

span.CharLit {
  color: #a4255b; }

span.EscapeSequence {
  color: black; }

span.Operator {
  color: black; }

span.Punctuation {
  color: black; }

span.Comment, span.LongComment {
  font-style: italic;
  font-weight: 400;
  color: #484a86; }

span.RegularExpression {
  color: darkviolet; }

span.TagStart {
  color: darkviolet; }

span.TagEnd {
  color: darkviolet; }

span.Key {
  color: #252dbe; }

span.Value {
  color: #252dbe; }

span.RawData {
  color: #a4255b; }

span.Assembler {
  color: #252dbe; }

span.Preprocessor {
  color: #252dbe; }

span.Directive {
  color: #252dbe; }

span.Command, span.Rule, span.Hyperlink, span.Label, span.Reference,
span.Other {
  color: black; }

/* Pop type, const, proc, and iterator defs in nim def blocks */
dt pre > span.Identifier, dt pre > span.Operator {
  color: #155da4;
  font-weight: 700; }

dt pre > span.Keyword ~ span.Identifier, dt pre > span.Identifier ~ span.Identifier,
dt pre > span.Operator ~ span.Identifier, dt pre > span.Other ~ span.Identifier {
  color: inherit;
  font-weight: inherit; }

/* Nim sprite for the footer (taken from main page favicon) */
.nim-sprite {
  display: inline-block;
  height: 16px;
  width: 16px;
  background-position: 0 0;
  background-size: 16px 16px;
  -webkit-filter: opacity(50%);
  background-repeat: no-repeat;
  background-image: url("data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA==");
  margin-bottom: -5px; }

span.pragmadots {
  /* Position: relative frees us up to make the dots
  look really nice without fucking up the layout and
  causing bulging in the parent container */
  position: relative;
  /* 1px down looks slightly nicer */
  top: 1px;
  padding: 2px;
  background-color: #e8e8e8;
  border-radius: 4px;
  margin: 0 2px;
  cursor: pointer;
  font-size: 0.8em;
}

span.pragmadots:hover {
  background-color: #DBDBDB;
}
span.pragmawrap {
  display: none;
}

span.attachedType {
  display: none;
  visibility: hidden;
}
</style>

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }
}
</script>

</head>
<body onload="main()">
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Nim手册</h1>
    <div class="row">
  <div class="three columns">
  <div id="global-links">
    <ul class="simple-boot">
      <li>
        <a href="manual.html">Manual</a>
      </li>
      <li>
        <a href="lib.html">Standard library</a>
      </li>
      <li>
        <a href="theindex.html">Index</a>
      </li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="关于本文_toc" href="#关于本文">关于本文</a></li>
<li><a class="reference" id="定义_toc" href="#定义">定义</a></li>
<li><a class="reference" id="词汇分析_toc" href="#词汇分析">词汇分析</a></li>
<ul class="simple"><li><a class="reference" id="词汇分析-编码_toc" href="#词汇分析-编码">编码</a></li>
<li><a class="reference" id="词汇分析-缩进_toc" href="#词汇分析-缩进">缩进</a></li>
<li><a class="reference" id="词汇分析-注释_toc" href="#词汇分析-注释">注释</a></li>
<li><a class="reference" id="词汇分析-多行注释_toc" href="#词汇分析-多行注释">多行注释</a></li>
<li><a class="reference" id="词汇分析-标识符-amp-关键字_toc" href="#词汇分析-标识符-amp-关键字">标识符 &amp; 关键字</a></li>
<li><a class="reference" id="词汇分析-标识符相等性_toc" href="#词汇分析-标识符相等性">标识符相等性</a></li>
<li><a class="reference" id="词汇分析-字符串字面值_toc" href="#词汇分析-字符串字面值">字符串字面值</a></li>
<li><a class="reference" id="词汇分析-三引用字符串字面值_toc" href="#词汇分析-三引用字符串字面值">三引用字符串字面值</a></li>
<li><a class="reference" id="词汇分析-原始字符串字面值_toc" href="#词汇分析-原始字符串字面值">原始字符串字面值</a></li>
<li><a class="reference" id="词汇分析-广义原始字符串字面值_toc" href="#词汇分析-广义原始字符串字面值">广义原始字符串字面值</a></li>
<li><a class="reference" id="词汇分析-字符字面值_toc" href="#词汇分析-字符字面值">字符字面值</a></li>
<li><a class="reference" id="词汇分析-数值常量_toc" href="#词汇分析-数值常量">数值常量</a></li>
<li><a class="reference" id="词汇分析-操作符_toc" href="#词汇分析-操作符">操作符</a></li>
<li><a class="reference" id="词汇分析-其它标记_toc" href="#词汇分析-其它标记">其它标记</a></li>
</ul><li><a class="reference" id="句法_toc" href="#句法">句法</a></li>
<ul class="simple"><li><a class="reference" id="句法-结合律_toc" href="#句法-结合律">结合律</a></li>
<li><a class="reference" id="句法-语法_toc" href="#句法-语法">语法</a></li>
</ul><li><a class="reference" id="求值顺序_toc" href="#求值顺序">求值顺序</a></li>
<li><a class="reference" id="常量和常量表达式_toc" href="#常量和常量表达式">常量和常量表达式</a></li>
<li><a class="reference" id="编译期执行限制_toc" href="#编译期执行限制">编译期执行限制</a></li>
<li><a class="reference" id="类型_toc" href="#类型">类型</a></li>
<ul class="simple"><li><a class="reference" id="类型-序数类型_toc" href="#类型-序数类型">序数类型</a></li>
<li><a class="reference" id="类型-预定义整数类型_toc" href="#类型-预定义整数类型">预定义整数类型</a></li>
<li><a class="reference" id="类型-子范围类型_toc" href="#类型-子范围类型">子范围类型</a></li>
<li><a class="reference" id="类型-预定义浮点类型_toc" href="#类型-预定义浮点类型">预定义浮点类型</a></li>
<li><a class="reference" id="类型-布尔类型_toc" href="#类型-布尔类型">布尔类型</a></li>
<li><a class="reference" id="类型-字符类型_toc" href="#类型-字符类型">字符类型</a></li>
<li><a class="reference" id="类型-枚举类型_toc" href="#类型-枚举类型">枚举类型</a></li>
<li><a class="reference" id="类型-字符串类型_toc" href="#类型-字符串类型">字符串类型</a></li>
<li><a class="reference" id="类型-cstring类型_toc" href="#类型-cstring类型">cstring类型</a></li>
<li><a class="reference" id="类型-结构化类型_toc" href="#类型-结构化类型">结构化类型</a></li>
<li><a class="reference" id="类型-数组和序列类型_toc" href="#类型-数组和序列类型">数组和序列类型</a></li>
<li><a class="reference" id="类型-开放数组（openarray）_toc" href="#类型-开放数组（openarray）">开放数组（openarray）</a></li>
<li><a class="reference" id="类型-可变参数_toc" href="#类型-可变参数">可变参数</a></li>
<li><a class="reference" id="类型-未检查数组_toc" href="#类型-未检查数组">未检查数组</a></li>
<li><a class="reference" id="类型-元组和对象类型_toc" href="#类型-元组和对象类型">元组和对象类型</a></li>
<li><a class="reference" id="类型-对象构造_toc" href="#类型-对象构造">对象构造</a></li>
<li><a class="reference" id="类型-对象变体_toc" href="#类型-对象变体">对象变体</a></li>
<li><a class="reference" id="类型-集合类型_toc" href="#类型-集合类型">集合类型</a></li>
<ul class="simple"><li><a class="reference" id="集合类型-bit-fields_toc" href="#集合类型-bit-fields">Bit fields</a></li>
</ul><li><a class="reference" id="类型-引用和指针类型_toc" href="#类型-引用和指针类型">引用和指针类型</a></li>
<li><a class="reference" id="类型-将gc内存和-ptr-混用_toc" href="#类型-将gc内存和-ptr-混用">将GC内存和 <tt class="docutils literal"><span class="pre">ptr</span></tt> 混用</a></li>
<li><a class="reference" id="类型-not-nil注解_toc" href="#类型-not-nil注解">Not nil注解</a></li>
<li><a class="reference" id="类型-过程类型_toc" href="#类型-过程类型">过程类型</a></li>
<li><a class="reference" id="类型-distinct类型_toc" href="#类型-distinct类型">Distinct类型</a></li>
<ul class="simple"><li><a class="reference" id="distinct类型-模拟货币_toc" href="#distinct类型-模拟货币">模拟货币</a></li>
<li><a class="reference" id="distinct类型-避免sql注入攻击_toc" href="#distinct类型-避免sql注入攻击">避免SQL注入攻击</a></li>
</ul><li><a class="reference" id="类型-自动类型_toc" href="#类型-自动类型">自动类型</a></li>
</ul><li><a class="reference" id="类型关系_toc" href="#类型关系">类型关系</a></li>
<ul class="simple"><li><a class="reference" id="类型关系-类型相等性_toc" href="#类型关系-类型相等性">类型相等性</a></li>
<li><a class="reference" id="类型关系-类型相等与类型区分_toc" href="#类型关系-类型相等与类型区分">类型相等与类型区分</a></li>
<li><a class="reference" id="类型关系-子类型关系_toc" href="#类型关系-子类型关系">子类型关系</a></li>
<li><a class="reference" id="类型关系-可转换关系_toc" href="#类型关系-可转换关系">可转换关系</a></li>
<li><a class="reference" id="类型关系-赋值兼容性_toc" href="#类型关系-赋值兼容性">赋值兼容性</a></li>
</ul><li><a class="reference" id="重载解析_toc" href="#重载解析">重载解析</a></li>
<ul class="simple"><li><a class="reference" id="重载解析-基于-var-t-的重载_toc" href="#重载解析-基于-var-t-的重载">基于 'var T' 的重载</a></li>
<li><a class="reference" id="重载解析-无类型的延迟类型解析_toc" href="#重载解析-无类型的延迟类型解析">无类型的延迟类型解析</a></li>
<li><a class="reference" id="重载解析-可变参数匹配_toc" href="#重载解析-可变参数匹配">可变参数匹配</a></li>
</ul><li><a class="reference" id="语句和表达式_toc" href="#语句和表达式">语句和表达式</a></li>
<ul class="simple"><li><a class="reference" id="语句和表达式-语句列表表达式_toc" href="#语句和表达式-语句列表表达式">语句列表表达式</a></li>
<li><a class="reference" id="语句和表达式-discard表达式_toc" href="#语句和表达式-discard表达式">Discard表达式</a></li>
<li><a class="reference" id="语句和表达式-void上下文_toc" href="#语句和表达式-void上下文">Void上下文</a></li>
<li><a class="reference" id="语句和表达式-var语句_toc" href="#语句和表达式-var语句">Var语句</a></li>
<li><a class="reference" id="语句和表达式-let语句_toc" href="#语句和表达式-let语句">Let语句</a></li>
<li><a class="reference" id="语句和表达式-元组解包_toc" href="#语句和表达式-元组解包">元组解包</a></li>
<li><a class="reference" id="语句和表达式-常量段_toc" href="#语句和表达式-常量段">常量段</a></li>
<li><a class="reference" id="语句和表达式-静态语句和表达式_toc" href="#语句和表达式-静态语句和表达式">静态语句和表达式</a></li>
<li><a class="reference" id="语句和表达式-if语句_toc" href="#语句和表达式-if语句">If语句</a></li>
<li><a class="reference" id="语句和表达式-case语句_toc" href="#语句和表达式-case语句">Case语句</a></li>
<li><a class="reference" id="语句和表达式-when语句_toc" href="#语句和表达式-when语句">When语句</a></li>
<li><a class="reference" id="语句和表达式-when-nimvm语句_toc" href="#语句和表达式-when-nimvm语句">When nimvm语句</a></li>
<li><a class="reference" id="语句和表达式-return语句_toc" href="#语句和表达式-return语句">Return语句</a></li>
<li><a class="reference" id="语句和表达式-yield语句_toc" href="#语句和表达式-yield语句">Yield语句</a></li>
<li><a class="reference" id="语句和表达式-block语句_toc" href="#语句和表达式-block语句">Block语句</a></li>
<li><a class="reference" id="语句和表达式-break语句_toc" href="#语句和表达式-break语句">Break语句</a></li>
<li><a class="reference" id="语句和表达式-while语句_toc" href="#语句和表达式-while语句">While语句</a></li>
<li><a class="reference" id="语句和表达式-continue语句_toc" href="#语句和表达式-continue语句">Continue语句</a></li>
<li><a class="reference" id="语句和表达式-汇编语句_toc" href="#语句和表达式-汇编语句">汇编语句</a></li>
<li><a class="reference" id="语句和表达式-using语句_toc" href="#语句和表达式-using语句">Using语句</a></li>
<li><a class="reference" id="语句和表达式-if表达式_toc" href="#语句和表达式-if表达式">If表达式</a></li>
<li><a class="reference" id="语句和表达式-when表达式_toc" href="#语句和表达式-when表达式">When表达式</a></li>
<li><a class="reference" id="语句和表达式-case表达式_toc" href="#语句和表达式-case表达式">Case表达式</a></li>
<li><a class="reference" id="语句和表达式-block表达式_toc" href="#语句和表达式-block表达式">Block表达式</a></li>
<li><a class="reference" id="语句和表达式-table构造函数_toc" href="#语句和表达式-table构造函数">Table构造函数</a></li>
<li><a class="reference" id="语句和表达式-类型转换_toc" href="#语句和表达式-类型转换">类型转换</a></li>
<li><a class="reference" id="语句和表达式-类型强转_toc" href="#语句和表达式-类型强转">类型强转</a></li>
<li><a class="reference" id="语句和表达式-addr操作符_toc" href="#语句和表达式-addr操作符">addr操作符</a></li>
<li><a class="reference" id="语句和表达式-unsafeaddr操作符_toc" href="#语句和表达式-unsafeaddr操作符">unsafeAddr操作符</a></li>
</ul><li><a class="reference" id="过程_toc" href="#过程">过程</a></li>
<ul class="simple"><li><a class="reference" id="过程-导出标记_toc" href="#过程-导出标记">导出标记</a></li>
<li><a class="reference" id="过程-方法调用语法_toc" href="#过程-方法调用语法">方法调用语法</a></li>
<li><a class="reference" id="过程-属性_toc" href="#过程-属性">属性</a></li>
<li><a class="reference" id="过程-命令调用语法_toc" href="#过程-命令调用语法">命令调用语法</a></li>
<li><a class="reference" id="过程-闭包_toc" href="#过程-闭包">闭包</a></li>
<ul class="simple"><li><a class="reference" id="闭包-在循环中创建闭包_toc" href="#闭包-在循环中创建闭包">在循环中创建闭包</a></li>
</ul><li><a class="reference" id="过程-anonymous-procs_toc" href="#过程-anonymous-procs">Anonymous Procs</a></li>
<li><a class="reference" id="过程-函数_toc" href="#过程-函数">函数</a></li>
<li><a class="reference" id="过程-不可重载的内置_toc" href="#过程-不可重载的内置">不可重载的内置</a></li>
<li><a class="reference" id="过程-var形参_toc" href="#过程-var形参">Var形参</a></li>
<li><a class="reference" id="过程-var返回类型_toc" href="#过程-var返回类型">Var返回类型</a></li>
<ul class="simple"><li><a class="reference" id="var返回类型-未来的方向_toc" href="#var返回类型-未来的方向">未来的方向</a></li>
</ul><li><a class="reference" id="过程-下标操作符重载_toc" href="#过程-下标操作符重载">下标操作符重载</a></li>
</ul><li><a class="reference" id="多方法_toc" href="#多方法">多方法</a></li>
<ul class="simple"><li><a class="reference" id="多方法-通过proccall禁止动态方法解析_toc" href="#多方法-通过proccall禁止动态方法解析">通过procCall禁止动态方法解析</a></li>
</ul><li><a class="reference" id="迭代器和for语句_toc" href="#迭代器和for语句">迭代器和for语句</a></li>
<ul class="simple"><li><a class="reference" id="迭代器和for语句-隐式items和pairs调用_toc" href="#迭代器和for语句-隐式items和pairs调用">隐式items和pairs调用</a></li>
<li><a class="reference" id="迭代器和for语句-第一类迭代器_toc" href="#迭代器和for语句-第一类迭代器">第一类迭代器</a></li>
</ul><li><a class="reference" id="转换器_toc" href="#转换器">转换器</a></li>
<li><a class="reference" id="type段_toc" href="#type段">Type段</a></li>
<li><a class="reference" id="异常处理_toc" href="#异常处理">异常处理</a></li>
<ul class="simple"><li><a class="reference" id="异常处理-try语句_toc" href="#异常处理-try语句">Try语句</a></li>
<li><a class="reference" id="异常处理-try表达式_toc" href="#异常处理-try表达式">Try表达式</a></li>
<li><a class="reference" id="异常处理-排除从句_toc" href="#异常处理-排除从句">排除从句</a></li>
<li><a class="reference" id="异常处理-defer语句_toc" href="#异常处理-defer语句">Defer语句</a></li>
<li><a class="reference" id="异常处理-raise语句_toc" href="#异常处理-raise语句">Raise语句</a></li>
<li><a class="reference" id="异常处理-异常层级_toc" href="#异常处理-异常层级">异常层级</a></li>
<li><a class="reference" id="异常处理-导入的异常_toc" href="#异常处理-导入的异常">导入的异常</a></li>
</ul><li><a class="reference" id="效应系统_toc" href="#效应系统">效应系统</a></li>
<ul class="simple"><li><a class="reference" id="效应系统-异常跟踪_toc" href="#效应系统-异常跟踪">异常跟踪</a></li>
<li><a class="reference" id="效应系统-tag跟踪_toc" href="#效应系统-tag跟踪">Tag跟踪</a></li>
<li><a class="reference" id="效应系统-effects编译指示_toc" href="#效应系统-effects编译指示">Effects编译指示</a></li>
</ul><li><a class="reference" id="泛型_toc" href="#泛型">泛型</a></li>
<ul class="simple"><li><a class="reference" id="泛型-is操作符_toc" href="#泛型-is操作符">Is操作符</a></li>
<li><a class="reference" id="泛型-类型类别_toc" href="#泛型-类型类别">类型类别</a></li>
<li><a class="reference" id="泛型-泛型推导限制_toc" href="#泛型-泛型推导限制">泛型推导限制</a></li>
<li><a class="reference" id="泛型-泛型符号查找_toc" href="#泛型-泛型符号查找">泛型符号查找</a></li>
<ul class="simple"><li><a class="reference" id="泛型符号查找-开放和关闭的符号_toc" href="#泛型符号查找-开放和关闭的符号">开放和关闭的符号</a></li>
</ul><li><a class="reference" id="泛型-mixin语句_toc" href="#泛型-mixin语句">Mixin语句</a></li>
<li><a class="reference" id="泛型-bind语句_toc" href="#泛型-bind语句">Bind语句</a></li>
</ul><li><a class="reference" id="模板_toc" href="#模板">模板</a></li>
<ul class="simple"><li><a class="reference" id="模板-类型化和无类型形参_toc" href="#模板-类型化和无类型形参">类型化和无类型形参</a></li>
<li><a class="reference" id="模板-向模板传代码块_toc" href="#模板-向模板传代码块">向模板传代码块</a></li>
<li><a class="reference" id="模板-无类型可变参数_toc" href="#模板-无类型可变参数">无类型可变参数</a></li>
<li><a class="reference" id="模板-模板符号绑定_toc" href="#模板-模板符号绑定">模板符号绑定</a></li>
<li><a class="reference" id="模板-标识符构造_toc" href="#模板-标识符构造">标识符构造</a></li>
<li><a class="reference" id="模板-模板形参查询规则_toc" href="#模板-模板形参查询规则">模板形参查询规则</a></li>
<li><a class="reference" id="模板-模板卫生_toc" href="#模板-模板卫生">模板卫生</a></li>
<li><a class="reference" id="模板-方法调用语法限制_toc" href="#模板-方法调用语法限制">方法调用语法限制</a></li>
</ul><li><a class="reference" id="宏_toc" href="#宏">宏</a></li>
<ul class="simple"><li><a class="reference" id="宏-debug示例_toc" href="#宏-debug示例">Debug示例</a></li>
<li><a class="reference" id="宏-bindsym_toc" href="#宏-bindsym">BindSym</a></li>
<li><a class="reference" id="宏-caseminusof宏_toc" href="#宏-caseminusof宏">Case-Of宏</a></li>
<li><a class="reference" id="宏-macros用作编译指示_toc" href="#宏-macros用作编译指示">Macros用作编译指示</a></li>
<li><a class="reference" id="宏-for循环宏_toc" href="#宏-for循环宏">For循环宏</a></li>
</ul><li><a class="reference" id="特殊类型_toc" href="#特殊类型">特殊类型</a></li>
<ul class="simple"><li><a class="reference" id="特殊类型-static-t_toc" href="#特殊类型-static-t">static[T]</a></li>
<li><a class="reference" id="特殊类型-typedesc-t_toc" href="#特殊类型-typedesc-t">typedesc[T]</a></li>
<li><a class="reference" id="特殊类型-typeof操作符_toc" href="#特殊类型-typeof操作符">typeof操作符</a></li>
</ul><li><a class="reference" id="模块_toc" href="#模块">模块</a></li>
<ul class="simple"><li><a class="reference" id="模块-import语句_toc" href="#模块-import语句">Import语句</a></li>
<li><a class="reference" id="模块-include语句_toc" href="#模块-include语句">Include语句</a></li>
<li><a class="reference" id="模块-导入的模块名_toc" href="#模块-导入的模块名">导入的模块名</a></li>
<li><a class="reference" id="模块-从目录中集体导入_toc" href="#模块-从目录中集体导入">从目录中集体导入</a></li>
<li><a class="reference" id="模块-pseudo-importslashinclude-paths_toc" href="#模块-pseudo-importslashinclude-paths">Pseudo import/include paths</a></li>
<li><a class="reference" id="模块-from-import语句_toc" href="#模块-from-import语句">From import语句</a></li>
<li><a class="reference" id="模块-export语句_toc" href="#模块-export语句">Export语句</a></li>
</ul><ul class="simple"><li><a class="reference" id="模块-作用域规则_toc" href="#模块-作用域规则">作用域规则</a></li>
<ul class="simple"><li><a class="reference" id="作用域规则-块作用域_toc" href="#作用域规则-块作用域">块作用域</a></li>
<li><a class="reference" id="作用域规则-元组或对象作用域_toc" href="#作用域规则-元组或对象作用域">元组或对象作用域</a></li>
<li><a class="reference" id="作用域规则-模块作用域_toc" href="#作用域规则-模块作用域">模块作用域</a></li>
<li><a class="reference" id="作用域规则-代码重排_toc" href="#作用域规则-代码重排">代码重排</a></li>
</ul></ul><li><a class="reference" id="编译器消息_toc" href="#编译器消息">编译器消息</a></li>
<li><a class="reference" id="编译指示_toc" href="#编译指示">编译指示</a></li>
<ul class="simple"><li><a class="reference" id="编译指示-deprecated-编译指示_toc" href="#编译指示-deprecated-编译指示">deprecated 编译指示</a></li>
<li><a class="reference" id="编译指示-nosideeffect-编译指示_toc" href="#编译指示-nosideeffect-编译指示">noSideEffect 编译指示</a></li>
<li><a class="reference" id="编译指示-compiletime-编译指示_toc" href="#编译指示-compiletime-编译指示">compileTime 编译指示</a></li>
<li><a class="reference" id="编译指示-noreturn-编译指示_toc" href="#编译指示-noreturn-编译指示">noReturn 编译指示</a></li>
<li><a class="reference" id="编译指示-acyclic-编译指示_toc" href="#编译指示-acyclic-编译指示">acyclic 编译指示</a></li>
<li><a class="reference" id="编译指示-final-编译指示_toc" href="#编译指示-final-编译指示">final 编译指示</a></li>
<li><a class="reference" id="编译指示-shallow-编译指示_toc" href="#编译指示-shallow-编译指示">shallow 编译指示</a></li>
<li><a class="reference" id="编译指示-pure-编译指示_toc" href="#编译指示-pure-编译指示">pure 编译指示</a></li>
<li><a class="reference" id="编译指示-asmnostackframe-编译指示_toc" href="#编译指示-asmnostackframe-编译指示">asmNoStackFrame 编译指示</a></li>
<li><a class="reference" id="编译指示-error-编译指示_toc" href="#编译指示-error-编译指示">error 编译指示</a></li>
<li><a class="reference" id="编译指示-fatal-编译指示_toc" href="#编译指示-fatal-编译指示">fatal 编译指示</a></li>
<li><a class="reference" id="编译指示-warning-编译指示_toc" href="#编译指示-warning-编译指示">warning 编译指示</a></li>
<li><a class="reference" id="编译指示-hint-编译指示_toc" href="#编译指示-hint-编译指示">hint 编译指示</a></li>
<li><a class="reference" id="编译指示-line-编译指示_toc" href="#编译指示-line-编译指示">line 编译指示</a></li>
<li><a class="reference" id="编译指示-linearscanend-编译指示_toc" href="#编译指示-linearscanend-编译指示">linearScanEnd 编译指示</a></li>
<li><a class="reference" id="编译指示-computedgoto-编译指示_toc" href="#编译指示-computedgoto-编译指示">computedGoto 编译指示</a></li>
<li><a class="reference" id="编译指示-unroll-编译指示_toc" href="#编译指示-unroll-编译指示">unroll 编译指示</a></li>
<li><a class="reference" id="编译指示-immediate-编译指示_toc" href="#编译指示-immediate-编译指示">immediate 编译指示</a></li>
<li><a class="reference" id="编译指示-compilation-option-pragmas_toc" href="#编译指示-compilation-option-pragmas">compilation option pragmas</a></li>
<li><a class="reference" id="编译指示-push-and-pop-编译指示_toc" href="#编译指示-push-and-pop-编译指示">push and pop 编译指示</a></li>
<li><a class="reference" id="编译指示-register-编译指示_toc" href="#编译指示-register-编译指示">register 编译指示</a></li>
<li><a class="reference" id="编译指示-global-编译指示_toc" href="#编译指示-global-编译指示">global 编译指示</a></li>
<li><a class="reference" id="编译指示-pragma-编译指示_toc" href="#编译指示-pragma-编译指示">pragma 编译指示</a></li>
<li><a class="reference" id="编译指示-disabling-certain-messages_toc" href="#编译指示-disabling-certain-messages">Disabling certain messages</a></li>
<li><a class="reference" id="编译指示-used-编译指示_toc" href="#编译指示-used-编译指示">used 编译指示</a></li>
<li><a class="reference" id="编译指示-experimental-编译指示_toc" href="#编译指示-experimental-编译指示">experimental 编译指示</a></li>
</ul><li><a class="reference" id="特定实现的编译指示_toc" href="#特定实现的编译指示">特定实现的编译指示</a></li>
<ul class="simple"><li><a class="reference" id="特定实现的编译指示-bitsize-编译指示_toc" href="#特定实现的编译指示-bitsize-编译指示">Bitsize 编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-volatile-编译指示_toc" href="#特定实现的编译指示-volatile-编译指示">Volatile 编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-nodecl-编译指示_toc" href="#特定实现的编译指示-nodecl-编译指示">NoDecl 编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-header-编译指示_toc" href="#特定实现的编译指示-header-编译指示">Header 编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-incompletestruct-编译指示_toc" href="#特定实现的编译指示-incompletestruct-编译指示">IncompleteStruct 编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-compile编译指示_toc" href="#特定实现的编译指示-compile编译指示">Compile编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-link编译指示_toc" href="#特定实现的编译指示-link编译指示">Link编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-passc编译指示_toc" href="#特定实现的编译指示-passc编译指示">PassC编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-passl编译指示_toc" href="#特定实现的编译指示-passl编译指示">PassL编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-emit编译指示_toc" href="#特定实现的编译指示-emit编译指示">Emit编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-importcpp编译指示_toc" href="#特定实现的编译指示-importcpp编译指示">ImportCpp编译指示</a></li>
<ul class="simple"><li><a class="reference" id="importcpp编译指示-命名空间_toc" href="#importcpp编译指示-命名空间">命名空间</a></li>
<li><a class="reference" id="importcpp编译指示-枚举importcpp_toc" href="#importcpp编译指示-枚举importcpp">枚举Importcpp</a></li>
<li><a class="reference" id="importcpp编译指示-过程importcpp_toc" href="#importcpp编译指示-过程importcpp">过程Importcpp</a></li>
<li><a class="reference" id="importcpp编译指示-包装构造函数_toc" href="#importcpp编译指示-包装构造函数">包装构造函数</a></li>
<li><a class="reference" id="importcpp编译指示-包装析构函数_toc" href="#importcpp编译指示-包装析构函数">包装析构函数</a></li>
<li><a class="reference" id="importcpp编译指示-对象的importcpp_toc" href="#importcpp编译指示-对象的importcpp">对象的Importcpp</a></li>
</ul><li><a class="reference" id="特定实现的编译指示-importobjc编译指示_toc" href="#特定实现的编译指示-importobjc编译指示">ImportObjC编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-codegendecl编译指示_toc" href="#特定实现的编译指示-codegendecl编译指示">CodegenDecl编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-injectstmt编译指示_toc" href="#特定实现的编译指示-injectstmt编译指示">InjectStmt编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-编译期定义的编译指示_toc" href="#特定实现的编译指示-编译期定义的编译指示">编译期定义的编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-自定义标注_toc" href="#特定实现的编译指示-自定义标注">自定义标注</a></li>
</ul><li><a class="reference" id="外部函数接口_toc" href="#外部函数接口">外部函数接口</a></li>
<ul class="simple"><li><a class="reference" id="外部函数接口-importc编译指示_toc" href="#外部函数接口-importc编译指示">Importc编译指示</a></li>
<li><a class="reference" id="外部函数接口-exportc编译指示_toc" href="#外部函数接口-exportc编译指示">Exportc编译指示</a></li>
<li><a class="reference" id="外部函数接口-extern编译指示_toc" href="#外部函数接口-extern编译指示">Extern编译指示</a></li>
<li><a class="reference" id="外部函数接口-bycopy编译指示_toc" href="#外部函数接口-bycopy编译指示">Bycopy编译指示</a></li>
<li><a class="reference" id="外部函数接口-byref编译指示_toc" href="#外部函数接口-byref编译指示">Byref编译指示</a></li>
<li><a class="reference" id="外部函数接口-varargs编译指示_toc" href="#外部函数接口-varargs编译指示">Varargs编译指示</a></li>
<li><a class="reference" id="外部函数接口-union编译指示_toc" href="#外部函数接口-union编译指示">Union编译指示</a></li>
<li><a class="reference" id="外部函数接口-packed编译指示_toc" href="#外部函数接口-packed编译指示">Packed编译指示</a></li>
<li><a class="reference" id="外部函数接口-用于导入的dynlib编译指示_toc" href="#外部函数接口-用于导入的dynlib编译指示">用于导入的Dynlib编译指示</a></li>
<li><a class="reference" id="外部函数接口-用于导出的dynlib编译指示_toc" href="#外部函数接口-用于导出的dynlib编译指示">用于导出的Dynlib编译指示</a></li>
</ul><li><a class="reference" id="线程_toc" href="#线程">线程</a></li>
<ul class="simple"><li><a class="reference" id="线程-thread编译指示_toc" href="#线程-thread编译指示">Thread编译指示</a></li>
<li><a class="reference" id="线程-gc安全_toc" href="#线程-gc安全">GC安全</a></li>
<li><a class="reference" id="线程-threadvar编译指示_toc" href="#线程-threadvar编译指示">Threadvar编译指示</a></li>
<li><a class="reference" id="线程-线程和异常_toc" href="#线程-线程和异常">线程和异常</a></li>
</ul>
</ul>

  </div>
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Authors:</th><td> Andreas Rumpf, Zahary Karadjov</td></tr>
<tr><th class="docinfo-name">Version:</th><td> 0.20.3</td></tr>
</tbody></table><blockquote><p>&quot;复杂度&quot;很像&quot;能量&quot;: 你可以将它从最终用户转移到一个/一些其他玩家，但总量对于给定的任务保持不变。-- Ran</p></blockquote>

<h1><a class="toc-backref" id="关于本文" href="#关于本文">关于本文</a></h1><p><strong>注意</strong> : 本文是草案！Nim的一些功能可能需要更精确的措辞。本手册不断发展为适当的规范。</p>
<p><strong>注意</strong> : Nim的实验特性在这里 <a class="reference external" href="manual_experimental.html">here</a> 。</p>
<p>本文描述Nim语言的词汇、语法，和语义。</p>
<p>学习如何编译Nim程序和生成文档见 <a class="reference external" href="nimc.html">Compiler User Guide</a> 和 <a class="reference external" href="docgen.html">DocGen Tools Guide</a> 。</p>
<p>语言构造用扩展巴科斯范式（BNF）解释，其中 <tt class="docutils literal"><span class="pre">(a)*</span></tt> 表示 0 或者更多 <tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">a+</span></tt> 表示1或更多 <tt class="docutils literal"><span class="pre">a</span></tt>, 以及 <tt class="docutils literal"><span class="pre">(a)?</span></tt> 表示可选 <em>a</em> 。小括号用来对元素进行分组。</p>
<p><tt class="docutils literal"><span class="pre">&amp;</span></tt> 是先行操作符; <tt class="docutils literal"><span class="pre">&amp;a</span></tt> 表示需要 <tt class="docutils literal"><span class="pre">a</span></tt> 但不被消耗。它将在下列规则中消耗。</p>
<p><tt class="docutils literal"><span class="pre">|</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt> 符号用于标记可选并且优先级最低。``/`` 是要求解析器尝试给定顺序的可选项的有序选择。 <tt class="docutils literal"><span class="pre">/</span></tt> 常用于确保语法没有歧义。</p>
<p>非终端符以小写字母开始，抽象终端符用大写。</p>
<p>逐字终端符（包括关键字）用 <tt class="docutils literal"><span class="pre">'</span></tt> 引用。示例:<pre>
ifStmt = 'if' expr ':' stmts ('elif' expr ':' stmts)* ('else' stmts)?</pre>
</p>
<p>二元操作符 <tt class="docutils literal"><span class="pre">^*</span></tt> 用于由第二个实参分隔的0或多次出现的简写；不像 <tt class="docutils literal"><span class="pre">^+</span></tt> 表示1或多个出现: <tt class="docutils literal"><span class="pre">a ^+ b</span></tt> 是 <tt class="docutils literal"><span class="pre">a (b a)*</span></tt> 的简写 <tt class="docutils literal"><span class="pre">a ^* b</span></tt> 是 <tt class="docutils literal"><span class="pre">(a (b a)*)?</span></tt> 的简写。示例:<pre>
arrayConstructor = '[' expr ^* ',' ']'</pre>
</p>
<p>Nim的其他部分，如作用域规则或运行时语义，都是非正式描述的。</p>

<h1><a class="toc-backref" id="定义" href="#定义">定义</a></h1><p>Nim代码指定一个计算，该计算作用于由称为 <span id="位置_1">位置</span> 的组件组成的内存。 变量基本上是位置的名称。每个变量和位置都是某种 <span id="类型_1">类型</span> 。 变量类型叫做 <span id="静态类型_1">静态类型</span> ，位置的类型叫做 <span id="动态类型_1">动态类型</span> 。 如果静态类型和动态类型不一样，它是动态类型的一个超类型或子类型。</p>
<blockquote><p><span id="标识符_1">标识符</span> 是声明为变量，类型，过程等的名称的符号。</p></blockquote>
<p>声明适用的程序区域叫做 <span id="作用域_1">作用域</span> 。作用域可以嵌套。 标识符的含义由声明标识符的最小封闭范围确定，除非重载解析规则另有说明。</p>
<p>表达式指定生成值或位置的计算。产生位置的表达式叫 <span id="左值_1">左值</span> 。左值可以表示位置或位置包含的值，具体取决于上下文。</p>
<p>Nim <span id="程序_1">程序</span> 由一个或多个包含Nim代码的文本 <span id="源文件_1">源文件</span> 构成。 它由Nim <span id="编译器_1">编译器</span> 处理成一个 <span id="可执行文件_1">可执行文件</span> 。 可执行文件的类型取决于编译器实现； 例如它可以是原生二进制或JavaScript源代码。</p>
<p>在典型的Nim程序中，多数代码编译成可执行文件。 但是，某些代码可以在 <span id="编译期_1">编译期</span> 执行 。 这可以包括宏定义使用的常量表达式，宏定义，和Nim过程。 编译期支持大部分Nim语言，但有一些限制 -- 详见 <a class="reference external" href="#restrictions-on-compileminustime-execution">Restrictions on Compile-Time Execution</a> 。 我们用术语 <span id="进行时_1">进行时</span> 来涵盖可执行文件中的编译时执行和代码执行。</p>
<p>编译器把Nim源代码解析为称为 <span id="抽象语法树_1">抽象语法树</span> (<span id="ast_1">AST</span>) 的内部数据结构 。 然后，在执行代码或编译成可执行文件前，通过 <span id="语义分析_1">语义分析</span> 变换AST。 这会添加语义信息，诸如表达式类型、标识符含义，以及某些情况下的表达式值。 语义分析期间的错误叫做 <span id="静态错误_1">静态错误</span> 。 未另行指定时，本手册中描述的错误是静态错误。</p>
<p><span id="运行时检查错误_1">运行时检查错误</span> 是实现在运行时检查并报告的错误。 报错此类错误的方法是通过 <em>引发异常</em> 或 <em>以致命错误退出</em> 。 但是，该实现提供了禁用这些 <span id="运行时检查_1">运行时检查</span> 的方法 . 有关详细信息，请参阅 <a class="reference external" href="#pragmas">pragmas</a> 部分。</p>
<p>检查的运行时错误是导致异常还是致命错误取决于实现。 因此以下程序无效；即使代码声称从越界数组访问中捕获 <tt class="docutils literal"><span class="pre">IndexError</span></tt> ，编译器也可以选择允许程序退出致命错误。</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">]</span>
<span class="Keyword">let</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">5</span>
<span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="CharLit">'N'</span>
<span class="Keyword">except</span> <span class="Identifier">IndexError</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;invalid index&quot;</span></pre><p><span id="未经检查的运行时错误_1">未经检查的运行时错误</span> 是一个不能保证被检测到的错误，并且可能导致任意的计算后续行为。 如果仅使用 <span id="safe_1">safe</span> 语言功能并且未禁用运行时检查，则不会发生未经检查的运行时错误。</p>
<p><span id="常量表达式_1">常量表达式</span> 是一个表达式，其值可以在出现的代码的语义分析期间计算。 它不是左值也没有副作用。 常量表达式不仅限于语义分析的功能，例如常量折叠;他们可以使用编译时执行所支持的所有Nim语言功能。 由于常量表达式可以用作语义分析的输入（例如用于定义数组边界），因此这种灵活性要求编译器交错语义分析和编译时代码执行。</p>
<p>在源代码中从上到下和从左到右进行图像语义分析是非常准确的，在必要时交错编译时代码执行以计算后续语义分析所需的值。 我们将在本文档后面看到，宏调用不仅需要这种交错，而且还会产生语义分析不能完全从上到下，从左到右进行的情况。</p>

<h1><a class="toc-backref" id="词汇分析" href="#词汇分析">词汇分析</a></h1>
<h2><a class="toc-backref" id="词汇分析-编码" href="#词汇分析-编码">编码</a></h2><p>所有Nim源文件都采用UTF-8编码（或其ASCII子集）。 其他编码不受支持。 可以使用任何标准平台行终端序列 - Unix使用ASCII LF（换行），Windows使用ASCII序列CR LF的（返回后跟换行），老的Macintosh使用ASCII CR（返回）字符。 无论什么平台，使用这些形式的效果是一样的。</p>

<h2><a class="toc-backref" id="词汇分析-缩进" href="#词汇分析-缩进">缩进</a></h2><p>Nim的标准语法描述了一个 <span id="缩进敏感_1">缩进敏感</span> 语言。 这意味着所有控制结构都可以通过缩进识别。 缩进仅由空格组成;制表符是不允许的。</p>
<p>缩进处理按如下方式实现：词法分析器使用前面的空格数注释以下标记;缩进不是一个单独的标记。 这个技巧允许只用1个先行标记解析Nim。</p>
<p>解析器使用由整数个空格组成的缩进堆栈级别。 缩进信息在解析器重要的位置上查询，否则被忽略：伪终端 <tt class="docutils literal"><span class="pre">IND{&gt;}</span></tt> 表示由比在堆栈顶部更多的空格构成； <tt class="docutils literal"><span class="pre">IND{=}</span></tt> 缩进具有相同数量的空格。 <tt class="docutils literal"><span class="pre">DED</span></tt> 是描述从堆栈弹出一个值的运作的伪代码， <tt class="docutils literal"><span class="pre">IND{&gt;}</span></tt> 意味着推到栈上。</p>
<p>使用这种表示法，我们现在可以轻松定义语法的核心：一个语句块（简化示例）:<pre>
ifStmt = 'if' expr ':' stmt
         (IND{=} 'elif' expr ':' stmt)*
         (IND{=} 'else' ':' stmt)?

simpleStmt = ifStmt / ...

stmt = IND{&gt;} stmt ^+ IND{=} DED  # list of statements
     / simpleStmt                 # or a simple statement</pre>
</p>

<h2><a class="toc-backref" id="词汇分析-注释" href="#词汇分析-注释">注释</a></h2><p>注释从字符串或字符文字外的任何地方开始，并带有哈希字符 <tt class="docutils literal"><span class="pre">#</span></tt> 。 注释包含 <tt class="docutils literal"><span class="pre">注释片段</span></tt> 的连接:idx: 。 评论文章以 <tt class="docutils literal"><span class="pre">#</span></tt> 开头，​​一直运行到行尾。 行尾字符属于该片段。 如果下一行只包含一个注释片段，而它与前一个片段之间没有其他符号，则它不会启动新注释：</p>
<pre class="listing"><span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>     <span class="Comment"># 这是跨行的单个注释。</span>
  <span class="Comment"># 扫描器合并这个块。</span>
  <span class="Comment"># 注释从这里继续。</span></pre><p><span id="文档注释_1">文档注释</span> 由两个开始 <tt class="docutils literal"><span class="pre">##</span></tt> 。 文档注释是符号；它们仅允许出现在输入文件的某个地方，因为它们属于语法树！</p>

<h2><a class="toc-backref" id="词汇分析-多行注释" href="#词汇分析-多行注释">多行注释</a></h2><p>从版本0.13.0开始，Nim支持多行注释。</p>
<pre class="listing"><span class="LongComment">#[注释这里.
多行
不是问题。]#</span></pre><p>多行注释支持嵌套：</p>
<pre class="listing"><span class="LongComment">#[  #[ 在已经注释代码中的多行注释]#
proc p[T](x: T) = discard
]#</span></pre><p>多行文档注释也存在并支持嵌套：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foo</span> <span class="Operator">=</span>
  <span class="LongComment">##[长文档注释。
  ]##</span></pre>
<h2><a class="toc-backref" id="词汇分析-标识符-amp-关键字" href="#词汇分析-标识符-amp-关键字">标识符 &amp; 关键字</a></h2><p>Nim中的标识符可以是任何字符、数字和由字母开始的下划线。不允许两个连续的下划线 <tt class="docutils literal"><span class="pre">__</span></tt> :<pre>
letter ::= 'A'..'Z' | 'a'..'z' | '\x80'..'\xff'
digit ::= '0'..'9'
IDENTIFIER ::= letter ( ['_'] (letter | digit) )*</pre>
</p>
<p>目前，序数值&gt; 127（非ASCII）的任何Unicode字符都被归类为 <tt class="docutils literal"><span class="pre">字母</span></tt> ，因此可能是标识符的一部分，但该语言的更高版本可能会指定某些Unicode字符来代替运算符字符。</p>
<p>下面预留的关键字不能用作标识符：</p>
<pre class="listing"><span class="Keyword">addr</span> <span class="Keyword">and</span> <span class="Keyword">as</span> <span class="Keyword">asm</span>
<span class="Keyword">bind</span> <span class="Keyword">block</span> <span class="Keyword">break</span>
<span class="Keyword">case</span> <span class="Keyword">cast</span> <span class="Keyword">concept</span> <span class="Keyword">const</span> <span class="Keyword">continue</span> <span class="Keyword">converter</span>
<span class="Keyword">defer</span> <span class="Keyword">discard</span> <span class="Keyword">distinct</span> <span class="Keyword">div</span> <span class="Keyword">do</span>
<span class="Keyword">elif</span> <span class="Keyword">else</span> <span class="Keyword">end</span> <span class="Keyword">enum</span> <span class="Keyword">except</span> <span class="Keyword">export</span>
<span class="Keyword">finally</span> <span class="Keyword">for</span> <span class="Keyword">from</span> <span class="Keyword">func</span>
<span class="Keyword">if</span> <span class="Keyword">import</span> <span class="Keyword">in</span> <span class="Keyword">include</span> <span class="Keyword">interface</span> <span class="Keyword">is</span> <span class="Keyword">isnot</span> <span class="Keyword">iterator</span>
<span class="Keyword">let</span>
<span class="Keyword">macro</span> <span class="Keyword">method</span> <span class="Keyword">mixin</span> <span class="Keyword">mod</span>
<span class="Keyword">nil</span> <span class="Keyword">not</span> <span class="Keyword">notin</span>
<span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Keyword">or</span> <span class="Keyword">out</span>
<span class="Keyword">proc</span> <span class="Keyword">ptr</span>
<span class="Keyword">raise</span> <span class="Keyword">ref</span> <span class="Keyword">return</span>
<span class="Keyword">shl</span> <span class="Keyword">shr</span> <span class="Keyword">static</span>
<span class="Keyword">template</span> <span class="Keyword">try</span> <span class="Keyword">tuple</span> <span class="Keyword">type</span>
<span class="Keyword">using</span>
<span class="Keyword">var</span>
<span class="Keyword">when</span> <span class="Keyword">while</span>
<span class="Keyword">xor</span>
<span class="Keyword">yield</span></pre><p>有些关键字未使用;它们是为语言的未来发展而保留的。</p>

<h2><a class="toc-backref" id="词汇分析-标识符相等性" href="#词汇分析-标识符相等性">标识符相等性</a></h2><p>两个标识符被认为是相等的如果下列算法返回真：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">sameIdentifier</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Keyword">and</span>
    <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">replace</span><span class="Punctuation">(</span><span class="StringLit">&quot;_&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">toLowerAscii</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">replace</span><span class="Punctuation">(</span><span class="StringLit">&quot;_&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">toLowerAscii</span></pre><p>这意味着只有首字母大小写敏感。 其他字母在ASCII范围内不区分大小写，并且忽略下划线。</p>
<p>这种相当不正统的标识符比较方法称为 <span id="部分不区分大小写_1">部分不区分大小写</span> 并且具有优于传统区分大小写的一些优点:</p>
<p>它允许程序员大多使用他们自己喜欢的拼写样式，无论是humpStyle还是snake_style，不同程序员编写的库不能使用不兼容的约定。 Nim感知编辑器或IDE可以将标识符显示为首选。 另一个优点是它使程序员不必记住标识符的确切拼写。关于第一个字母的例外允许明确地解析像 <tt class="docutils literal"><span class="pre">var foo：Foo</span></tt> 这样的公共代码。</p>
<p>请注意，此规则也适用于关键字，这意味着 <tt class="docutils literal"><span class="pre">notin</span></tt> 和 <tt class="docutils literal"><span class="pre">notIn</span></tt> 以及 <tt class="docutils literal"><span class="pre">not_in</span></tt> 是相同的， (全小写版本 (<tt class="docutils literal"><span class="pre">notin</span></tt>, <tt class="docutils literal"><span class="pre">isnot</span></tt>) 是写关键字的首选方式)。</p>
<p>从历史上看，Nim是一种完全 <span id="风格不敏感_1">风格不敏感</span> 语言。 这意味着它不区分大小写并且忽略了下划线，并且 <tt class="docutils literal"><span class="pre">foo</span></tt> 和 <tt class="docutils literal"><span class="pre">Foo</span></tt> 之间甚至没有区别。</p>

<h2><a class="toc-backref" id="词汇分析-字符串字面值" href="#词汇分析-字符串字面值">字符串字面值</a></h2><p>语法中的终端符号: <tt class="docutils literal"><span class="pre">STR_LIT</span></tt> 。</p>
<p>字符串文字可以通过匹配双引号来分隔，并且可以包含以下 <span id="转义序列_1">转义序列</span> :</p>
<table border="1" class="docutils"><tr><th>转义序列</th><th>含义</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">\p</span></tt></td><td>平台特定的换行: CRLF on Windows, LF on Unix</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\r</span></tt>, <tt class="docutils literal"><span class="pre">\c</span></tt></td><td><span id="carriage-return_1">carriage return</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\n</span></tt>, <tt class="docutils literal"><span class="pre">\l</span></tt></td><td><span id="line-feed_1">line feed</span> (often called <span id="newline_1">newline</span>)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\f</span></tt></td><td><span id="form-feed_1">form feed</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\t</span></tt></td><td><span id="tabulator_1">tabulator</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\v</span></tt></td><td><span id="vertical-tabulator_1">vertical tabulator</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\\</span></tt></td><td><span id="backslash_1">backslash</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\&quot;</span></tt></td><td><span id="quotation-mark_1">quotation mark</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\'</span></tt></td><td><span id="apostrophe_1">apostrophe</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\</span></tt> '0'..'9'+</td><td><span id="character-with-decimal-value-d_1">character with decimal value d</span>; all decimal digits directly following are used for the character</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\a</span></tt></td><td><span id="alert_1">alert</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\b</span></tt></td><td><span id="backspace_1">backspace</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\e</span></tt></td><td><span id="escape_1">escape</span> <span id="esc_1">[ESC]</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\x</span></tt> HH</td><td><span id="character-with-hex-value-hh_1">character with hex value HH</span>; exactly two hex digits are allowed</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\u</span></tt> HHHH</td><td><span id="unicode-codepoint-with-hex-value-hhhh_1">unicode codepoint with hex value HHHH</span>; exactly four hex digits are allowed</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\u</span></tt> {H+}</td><td><span id="unicode-codepoint_1">unicode codepoint</span>; all hex digits enclosed in <tt class="docutils literal"><span class="pre">{}</span></tt> are used for the codepoint</td></tr>
</table><p>Nim中的字符串可以包含任何8位值，甚至是嵌入的零。 但是，某些操作可能会将第一个二进制零解释为终止符。</p>

<h2><a class="toc-backref" id="词汇分析-三引用字符串字面值" href="#词汇分析-三引用字符串字面值">三引用字符串字面值</a></h2><p>语法中的终端符号: <tt class="docutils literal"><span class="pre">TRIPLESTR_LIT</span></tt>.</p>
<p>字符串文字也可以用三个双引号分隔 <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> ... <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> 。 这种形式的文字可能会持续几行，可能包含 <tt class="docutils literal"><span class="pre">&quot;</span></tt> 并且不解释任何转义序列。 为方便起见，当开头的 <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> 后面跟一个换行符 (开头 <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> 和换行符之间可能有空格）时,换行符（和前面的空格）不包含在字符串。 字符串文字的结尾由模式定义 <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;[^&quot;]</span></tt>, 所以:</p>
<pre class="listing"><span class="LongStringLit">&quot;&quot;&quot;&quot;long string within quotes&quot;&quot;&quot;&quot;</span></pre><p>生成:<pre>
&quot;long string within quotes&quot;</pre>
</p>

<h2><a class="toc-backref" id="词汇分析-原始字符串字面值" href="#词汇分析-原始字符串字面值">原始字符串字面值</a></h2><p>语法中的终端符号: <tt class="docutils literal"><span class="pre">RSTR_LIT</span></tt>.</p>
<p>还有原始字符串文字，前面带有字母 <tt class="docutils literal"><span class="pre">r</span></tt> (or <tt class="docutils literal"><span class="pre">R</span></tt>) 并通过匹配双引号（就像普通的字符串文字一样）分隔并且不解释转义序列。 这对于正则表达式或Windows路径特别方便：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">openFile</span><span class="Punctuation">(</span><span class="RawData">r&quot;C:\texts\text.txt&quot;</span><span class="Punctuation">)</span> <span class="Comment"># 原始字符串, 所以 ``\t`` 不是制表符。</span></pre><p>为了在原始字符串中生成一个单独的 <tt class="docutils literal"><span class="pre">&quot;</span></tt> , 必须使用两个:</p>
<pre class="listing"><span class="RawData">r&quot;a&quot;&quot;</span><span class="RawData">b&quot;</span></pre><p>Produces:<pre>
a&quot;b</pre>
</p>
<p><tt class="docutils literal"><span class="pre">r&quot;&quot;&quot;&quot;</span></tt> 这个符号是不可能的，因为三个引号引用了三引号字符串文字。 <tt class="docutils literal"><span class="pre">r&quot;&quot;&quot;</span></tt> 与 <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> 相同，因为三重引用的字符串文字也不解释转义序列。</p>

<h2><a class="toc-backref" id="词汇分析-广义原始字符串字面值" href="#词汇分析-广义原始字符串字面值">广义原始字符串字面值</a></h2><p>语法中的终端符号: <tt class="docutils literal"><span class="pre">GENERALIZED_STR_LIT</span></tt>, <tt class="docutils literal"><span class="pre">GENERALIZED_TRIPLESTR_LIT</span></tt> 。</p>
<p><tt class="docutils literal"><span class="pre">标识符&quot;字符串字面值&quot;</span></tt> 这种构造(标识符和开始引号之间没有空格)是广义原始字符串。 这是 <tt class="docutils literal"><span class="pre">identifier(r&quot;string literal&quot;)</span></tt> 的缩写， 所以它表示一个过程调用原始字符串文字作为唯一的参数。</p>
<p>广义原始字符串文字特别便于将小型语言直接嵌入到Nim中（例如正则表达式）。</p>
<p><tt class="docutils literal"><span class="pre">标识符&quot;&quot;&quot;字符串字面值&quot;&quot;&quot;</span></tt> 也存在。它是 <tt class="docutils literal"><span class="pre">标识符(&quot;&quot;&quot;字符串字面值&quot;&quot;&quot;)</span></tt> 的缩写。</p>

<h2><a class="toc-backref" id="词汇分析-字符字面值" href="#词汇分析-字符字面值">字符字面值</a></h2><p>字符文字用单引号 <tt class="docutils literal"><span class="pre">''</span></tt> 括起来，并且可以包含与字符串相同的转义序列 - 有一个例外：平台依赖的 <span id="newline_2">newline</span> (<tt class="docutils literal"><span class="pre">\p</span></tt>) 是不允许的，因为它可能比一个字符宽（通常是CR / LF对）。 以下是对字符字面值有效的 <span id="转义序列_2">转义序列</span> :</p>
<table border="1" class="docutils"><tr><th>转义序列</th><th>含义</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">\r</span></tt>, <tt class="docutils literal"><span class="pre">\c</span></tt></td><td><span id="carriage-return_2">carriage return</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\n</span></tt>, <tt class="docutils literal"><span class="pre">\l</span></tt></td><td><span id="line-feed_2">line feed</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\f</span></tt></td><td><span id="form-feed_2">form feed</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\t</span></tt></td><td><span id="tabulator_2">tabulator</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\v</span></tt></td><td><span id="vertical-tabulator_2">vertical tabulator</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\\</span></tt></td><td><span id="backslash_2">backslash</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\&quot;</span></tt></td><td><span id="quotation-mark_2">quotation mark</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\'</span></tt></td><td><span id="apostrophe_2">apostrophe</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\</span></tt> '0'..'9'+</td><td><span id="character-with-decimal-value-d_2">character with decimal value d</span>; all decimal digits directly following are used for the character</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\a</span></tt></td><td><span id="alert_2">alert</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\b</span></tt></td><td><span id="backspace_2">backspace</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\e</span></tt></td><td><span id="escape_2">escape</span> <span id="esc_2">[ESC]</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\x</span></tt> HH</td><td><span id="character-with-hex-value-hh_2">character with hex value HH</span>; exactly two hex digits are allowed</td></tr>
</table><p>字符不是Unicode字符，而是单个字节。</p>
<p>这样做的原因是效率：对于绝大多数用例，由于UTF-8是专门为此设计的，所得到的程序仍然可以正确处理UTF-8。 另一个原因是Nim因此可以依靠这个特性像其它算法一样有效地支持 <tt class="docutils literal"><span class="pre">array[char, int]</span></tt> 或 <tt class="docutils literal"><span class="pre">set[char]</span></tt> 。 <tt class="docutils literal"><span class="pre">Rune</span></tt> 类型用于Unicode字符，它可以表示任何Unicode字符。 <tt class="docutils literal"><span class="pre">Rune</span></tt> 在 <a class="reference external" href="unicode.html">unicode module</a> 声明。</p>

<h2><a class="toc-backref" id="词汇分析-数值常量" href="#词汇分析-数值常量">数值常量</a></h2><p>数值常量是单一类型，并具有以下形式:<pre>
hexdigit = digit | 'A'..'F' | 'a'..'f'
octdigit = '0'..'7'
bindigit = '0'..'1'
HEX_LIT = '0' ('x' | 'X' ) hexdigit ( ['_'] hexdigit )*
DEC_LIT = digit ( ['_'] digit )*
OCT_LIT = '0' 'o' octdigit ( ['_'] octdigit )*
BIN_LIT = '0' ('b' | 'B' ) bindigit ( ['_'] bindigit )*

INT_LIT = HEX_LIT
        | DEC_LIT
        | OCT_LIT
        | BIN_LIT

INT8_LIT = INT_LIT ['\''] ('i' | 'I') '8'
INT16_LIT = INT_LIT ['\''] ('i' | 'I') '16'
INT32_LIT = INT_LIT ['\''] ('i' | 'I') '32'
INT64_LIT = INT_LIT ['\''] ('i' | 'I') '64'

UINT_LIT = INT_LIT ['\''] ('u' | 'U')
UINT8_LIT = INT_LIT ['\''] ('u' | 'U') '8'
UINT16_LIT = INT_LIT ['\''] ('u' | 'U') '16'
UINT32_LIT = INT_LIT ['\''] ('u' | 'U') '32'
UINT64_LIT = INT_LIT ['\''] ('u' | 'U') '64'

exponent = ('e' | 'E' ) ['+' | '-'] digit ( ['_'] digit )*
FLOAT_LIT = digit (['_'] digit)* (('.' digit (['_'] digit)* [exponent]) |exponent)
FLOAT32_SUFFIX = ('f' | 'F') ['32']
FLOAT32_LIT = HEX_LIT '\'' FLOAT32_SUFFIX
            | (FLOAT_LIT | DEC_LIT | OCT_LIT | BIN_LIT) ['\''] FLOAT32_SUFFIX
FLOAT64_SUFFIX = ( ('f' | 'F') '64' ) | 'd' | 'D'
FLOAT64_LIT = HEX_LIT '\'' FLOAT64_SUFFIX
            | (FLOAT_LIT | DEC_LIT | OCT_LIT | BIN_LIT) ['\''] FLOAT64_SUFFIX</pre>
</p>
<p>从产品中可以看出，数值常数可以包含下划线以便于阅读。</p>
<p>整数和浮点文字可以用十进制（无前缀），二进制（前缀 <tt class="docutils literal"><span class="pre">0b</span></tt> ），八进制（前缀 <tt class="docutils literal"><span class="pre">0o</span></tt> ）和十六进制（前缀 <tt class="docutils literal"><span class="pre">0x</span></tt> ）表示法给出。</p>
<p>每个定义的数字类型都有一个文字。 以一撇开始的后缀 (''') 叫 <span id="类型后缀_1">类型后缀</span> 。</p>
<p>没有类型后缀的文字是整数类型，除非文字包含点或 <tt class="docutils literal"><span class="pre">E | e `` ，在这种情况下它是 ``浮动</span></tt> 类型。 整数类型是 <tt class="docutils literal"><span class="pre">int</span></tt> 如果字面值在 <tt class="docutils literal"><span class="pre">low(i32)..high(i32)</span></tt> 范围，否则是 <tt class="docutils literal"><span class="pre">int64</span></tt> 。 为了符号方便，类型后缀的撇号是可选的，如果它不是模糊的（只有具有类型后缀的十六进制浮点文字可能是不明确的）。</p>
<p>The type suffixes are:</p>
<table border="1" class="docutils"><tr><th>Type Suffix</th><th>Resulting type of literal</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i8</span></tt></td><td>int8</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i16</span></tt></td><td>int16</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i32</span></tt></td><td>int32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i64</span></tt></td><td>int64</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u</span></tt></td><td>uint</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u8</span></tt></td><td>uint8</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u16</span></tt></td><td>uint16</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u32</span></tt></td><td>uint32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u64</span></tt></td><td>uint64</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'f</span></tt></td><td>float32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'d</span></tt></td><td>float64</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'f32</span></tt></td><td>float32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'f64</span></tt></td><td>float64</td></tr>
</table><p>浮点文字也可以是二进制，八进制或十六进制表示法： 根据IEEE浮点标准， <tt class="docutils literal"><span class="pre">0B0_10001110100_0000101001000111101011101111111011000101001101001001'f64</span></tt> 约为 1.72826e35。</p>
<p>对文字进行边界检查，以使它们适合数据类型。 非基数10字面值主要用于标志和位模式表示，因此边界检查是在位宽而非值范围上完成的。 如果文字符合数据类型的位宽，则接受它。 因此：0b10000000'u8 == 0x80'u8 == 128，但是，0b10000000'i8 == 0x80'i8 == -1而不是导致溢出错误。</p>

<h2><a class="toc-backref" id="词汇分析-操作符" href="#词汇分析-操作符">操作符</a></h2><p>Nim允许用户定义的运算符。运算符是以下字符的任意组合</p>
<blockquote><p>=     +     -     *     /     &lt;     &gt; @     $     ~     &amp;     %     | !     ?     ^     .     :     
</p></blockquote>
<p>这些关键字也是操作符: <tt class="docutils literal"><span class="pre">and or not xor shl shr div mod in notin is isnot of</span></tt>.</p>
<p><span class="tok">.</span> <span class="tok">=</span>, <span class="tok">:</span>, <span class="tok">::</span> 不作为一般操作符；它们用于其他符号用途。</p>
<p><tt class="docutils literal"><span class="pre">*:</span></tt> 是一个特殊情况，被视为两个标记 <span class="tok">*</span> 和 <span class="tok">:</span> (为了支持 <tt class="docutils literal"><span class="pre">var v*: T</span></tt>)。</p>
<p><tt class="docutils literal"><span class="pre">not</span></tt> 关键字问题一元操作符， <tt class="docutils literal"><span class="pre">a not b</span></tt> 解析成 <tt class="docutils literal"><span class="pre">a(not b)</span></tt>, 不是 <tt class="docutils literal"><span class="pre">(a) not (b)</span></tt> 。</p>

<h2><a class="toc-backref" id="词汇分析-其它标记" href="#词汇分析-其它标记">其它标记</a></h2><p>以下字符串表示其他标记:<pre>
`   (    )     {    }     [    ]    ,  ;   [.    .]  {.   .}  (.  .)  [:</pre>
</p>
<p><span id="切片_1">切片</span> 运算符 <span class="tok">..</span> 优先于包含点的其它标记: <span class="tok">{..}</span> 是三个标记 <span class="tok">{</span>, <span class="tok">..</span>, <span class="tok">}</span> 而不是两个标记 <span class="tok">{.</span>, <span class="tok">.}</span> 。</p>

<h1><a class="toc-backref" id="句法" href="#句法">句法</a></h1><p>本节列出了Nim的标准语法。解析器如何处理缩进已在 <a class="reference external" href="#lexical-analysis">Lexical Analysis</a> 部分中描述。</p>
<p>Nim允许用户可定义的运算符。二元运算符具有11个不同的优先级。</p>

<h2><a class="toc-backref" id="句法-结合律" href="#句法-结合律">结合律</a></h2><p>第一个字符是 <tt class="docutils literal"><span class="pre">^</span></tt> 的二元运算符是右结合，所有其他二元运算符都是左结合。</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">^/</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">float</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span>
  <span class="Comment"># a right-associative division operator</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">/</span> <span class="Identifier">y</span>
<span class="Identifier">echo</span> <span class="DecNumber">12</span> <span class="Operator">^/</span> <span class="DecNumber">4</span> <span class="Operator">^/</span> <span class="DecNumber">8</span> <span class="Comment"># 24.0 (4 / 8 = 0.5, then 12 / 0.5 = 24.0)</span>
<span class="Identifier">echo</span> <span class="DecNumber">12</span>  <span class="Operator">/</span> <span class="DecNumber">4</span>  <span class="Operator">/</span> <span class="DecNumber">8</span> <span class="Comment"># 0.375 (12 / 4 = 3.0, then 3 / 8 = 0.375)</span></pre><hr />
<p>一元运算符总是比任何二元运算符优先: <tt class="docutils literal"><span class="pre">$a + b</span></tt> is <tt class="docutils literal"><span class="pre">($a) + b</span></tt> 而不是 <tt class="docutils literal"><span class="pre">$(a + b)</span></tt> 。</p>
<p>如果一元运算符的第一个字符是 <tt class="docutils literal"><span class="pre">@</span></tt> 它是 <span id="符印样_1">符印样</span> 运算符，比 <tt class="docutils literal"><span class="pre">主后缀</span></tt> 优先: <tt class="docutils literal"><span class="pre">@x.abc</span></tt> 解析成 <tt class="docutils literal"><span class="pre">(@x).abc</span></tt> 而 <tt class="docutils literal"><span class="pre">$x.abc</span></tt> 解析成 <tt class="docutils literal"><span class="pre">$(x.abc)</span></tt> 。</p>
<p>对于非关键字的二元运算符，优先级由以下规则确定：</p>
<p>以 <tt class="docutils literal"><span class="pre">-&gt;</span></tt>, <tt class="docutils literal"><span class="pre">~&gt;</span></tt> or <tt class="docutils literal"><span class="pre">=&gt;</span></tt> 结尾的运算符称为 <span id="箭头样_1">箭头样</span>, 优先级最低。</p>
<p>如果操作符以 <tt class="docutils literal"><span class="pre">=</span></tt> 结尾，并且它的第一个字符不是 <tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">!</span></tt>, <tt class="docutils literal"><span class="pre">=</span></tt>, <tt class="docutils literal"><span class="pre">~</span></tt>, <tt class="docutils literal"><span class="pre">?</span></tt>, 它是一个 <em>赋值运算符</em> 具有第二低的优先级。</p>
<p>否则优先级由第一个字符决定。</p>
<table border="1" class="docutils"><tr><th>优先级</th><th>运算符</th><th>首字符</th><th>终端符号</th></tr>
<tr><td>10 (highest)</td><td></td><td><tt class="docutils literal"><span class="pre">$ ^</span></tt></td><td>OP10</td></tr>
<tr><td>9</td><td><tt class="docutils literal"><span class="pre">* / div mod shl shr %</span></tt></td><td><tt class="docutils literal"><span class="pre">* % \ /</span></tt></td><td>OP9</td></tr>
<tr><td>8</td><td><tt class="docutils literal"><span class="pre">+ -</span></tt></td><td><tt class="docutils literal"><span class="pre">+ - ~ |</span></tt></td><td>OP8</td></tr>
<tr><td>7</td><td><tt class="docutils literal"><span class="pre">&amp;</span></tt></td><td><tt class="docutils literal"><span class="pre">&amp;</span></tt></td><td>OP7</td></tr>
<tr><td>6</td><td><tt class="docutils literal"><span class="pre">..</span></tt></td><td><tt class="docutils literal"><span class="pre">.</span></tt></td><td>OP6</td></tr>
<tr><td>5</td><td><tt class="docutils literal"><span class="pre">== &lt;= &lt; &gt;= &gt; != in notin is isnot not of</span></tt></td><td><tt class="docutils literal"><span class="pre">= &lt; &gt; !</span></tt></td><td>OP5</td></tr>
<tr><td>4</td><td><tt class="docutils literal"><span class="pre">and</span></tt></td><td></td><td>OP4</td></tr>
<tr><td>3</td><td><tt class="docutils literal"><span class="pre">or xor</span></tt></td><td></td><td>OP3</td></tr>
<tr><td>2</td><td></td><td><tt class="docutils literal"><span class="pre">@ : ?</span></tt></td><td>OP2</td></tr>
<tr><td>1</td><td><em>赋值运算符</em> (like <tt class="docutils literal"><span class="pre">+=</span></tt>, <tt class="docutils literal"><span class="pre">*=</span></tt>)</td><td></td><td>OP1</td></tr>
<tr><td>0 (lowest)</td><td><em>arrow like operator</em> (like <tt class="docutils literal"><span class="pre">-&gt;</span></tt>, <tt class="docutils literal"><span class="pre">=&gt;</span></tt>)</td><td></td><td>OP0</td></tr>
</table><p>运算符是否使用前缀运算符也受前面的空格影响（此版本的修改随版本0.13.0引入）：</p>
<pre class="listing"><span class="Identifier">echo</span> <span class="Operator">$</span><span class="Identifier">foo</span>
<span class="Comment"># is parsed as</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">foo</span><span class="Punctuation">)</span></pre><p>间距还决定了 <tt class="docutils literal"><span class="pre">(a, b)</span></tt> 是否被解析为调用的参数列表，或者它是否被解析为元组构造函数：</p>
<pre class="listing"><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">)</span> <span class="Comment"># 传1和2给echo</span></pre><pre class="listing"><span class="Identifier">echo</span> <span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">)</span> <span class="Comment"># 传元组(1, 2)给echo</span></pre>
<h2><a class="toc-backref" id="句法-语法" href="#句法-语法">语法</a></h2><p>语法的起始符号是 <tt class="docutils literal"><span class="pre">module</span></tt>.</p>
<pre># This file is generated by compiler/parser.nim.
module = stmt ^* (';' / IND{=})
comma = ',' COMMENT?
semicolon = ';' COMMENT?
colon = ':' COMMENT?
colcom = ':' COMMENT?
operator =  OP0 | OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9
         | 'or' | 'xor' | 'and'
         | 'is' | 'isnot' | 'in' | 'notin' | 'of'
         | 'div' | 'mod' | 'shl' | 'shr' | 'not' | 'static' | '..'
prefixOperator = operator
optInd = COMMENT? IND?
optPar = (IND{&gt;} | IND{=})?
simpleExpr = arrowExpr (OP0 optInd arrowExpr)* pragma?
arrowExpr = assignExpr (OP1 optInd assignExpr)*
assignExpr = orExpr (OP2 optInd orExpr)*
orExpr = andExpr (OP3 optInd andExpr)*
andExpr = cmpExpr (OP4 optInd cmpExpr)*
cmpExpr = sliceExpr (OP5 optInd sliceExpr)*
sliceExpr = ampExpr (OP6 optInd ampExpr)*
ampExpr = plusExpr (OP7 optInd plusExpr)*
plusExpr = mulExpr (OP8 optInd mulExpr)*
mulExpr = dollarExpr (OP9 optInd dollarExpr)*
dollarExpr = primary (OP10 optInd primary)*
symbol = '`' (KEYW|IDENT|literal|(operator|'('|')'|'['|']'|'{'|'}'|'=')+)+ '`'
       | IDENT | KEYW
exprColonEqExpr = expr (':'|'=' expr)?
exprList = expr ^+ comma
exprColonEqExprList = exprColonEqExpr (comma exprColonEqExpr)* (comma)?
dotExpr = expr '.' optInd (symbol | '[:' exprList ']')
explicitGenericInstantiation = '[:' exprList ']' ( '(' exprColonEqExpr ')' )?
qualifiedIdent = symbol ('.' optInd symbol)?
setOrTableConstr = '{' ((exprColonEqExpr comma)* | ':' ) '}'
castExpr = 'cast' '[' optInd typeDesc optPar ']' '(' optInd expr optPar ')'
parKeyw = 'discard' | 'include' | 'if' | 'while' | 'case' | 'try'
        | 'finally' | 'except' | 'for' | 'block' | 'const' | 'let'
        | 'when' | 'var' | 'mixin'
par = '(' optInd
          ( &amp;parKeyw complexOrSimpleStmt ^+ ';'
          | ';' complexOrSimpleStmt ^+ ';'
          | pragmaStmt
          | simpleExpr ( ('=' expr (';' complexOrSimpleStmt ^+ ';' )? )
                       | (':' expr (',' exprColonEqExpr     ^+ ',' )? ) ) )
          optPar ')'
literal = | INT_LIT | INT8_LIT | INT16_LIT | INT32_LIT | INT64_LIT
          | UINT_LIT | UINT8_LIT | UINT16_LIT | UINT32_LIT | UINT64_LIT
          | FLOAT_LIT | FLOAT32_LIT | FLOAT64_LIT
          | STR_LIT | RSTR_LIT | TRIPLESTR_LIT
          | CHAR_LIT
          | NIL
generalizedLit = GENERALIZED_STR_LIT | GENERALIZED_TRIPLESTR_LIT
identOrLiteral = generalizedLit | symbol | literal
               | par | arrayConstr | setOrTableConstr
               | castExpr
tupleConstr = '(' optInd (exprColonEqExpr comma?)* optPar ')'
arrayConstr = '[' optInd (exprColonEqExpr comma?)* optPar ']'
primarySuffix = '(' (exprColonEqExpr comma?)* ')' doBlocks?
      | doBlocks
      | '.' optInd symbol generalizedLit?
      | '[' optInd indexExprList optPar ']'
      | '{' optInd indexExprList optPar '}'
      | &amp;( '`'|IDENT|literal|'cast'|'addr'|'type') expr # command syntax
condExpr = expr colcom expr optInd
        ('elif' expr colcom expr optInd)*
         'else' colcom expr
ifExpr = 'if' condExpr
whenExpr = 'when' condExpr
pragma = '{.' optInd (exprColonExpr comma?)* optPar ('.}' | '}')
identVis = symbol opr?  # postfix position
identVisDot = symbol '.' optInd symbol opr?
identWithPragma = identVis pragma?
identWithPragmaDot = identVisDot pragma?
declColonEquals = identWithPragma (comma identWithPragma)* comma?
                  (':' optInd typeDesc)? ('=' optInd expr)?
identColonEquals = ident (comma ident)* comma?
     (':' optInd typeDesc)? ('=' optInd expr)?)
inlTupleDecl = 'tuple'
    [' optInd  (identColonEquals (comma/semicolon)?)*  optPar ']'
extTupleDecl = 'tuple'
    COMMENT? (IND{&gt;} identColonEquals (IND{=} identColonEquals)*)?
tupleClass = 'tuple'
paramList = '(' declColonEquals ^* (comma/semicolon) ')'
paramListArrow = paramList? ('-&gt;' optInd typeDesc)?
paramListColon = paramList? (':' optInd typeDesc)?
doBlock = 'do' paramListArrow pragmas? colcom stmt
procExpr = 'proc' paramListColon pragmas? ('=' COMMENT? stmt)?
distinct = 'distinct' optInd typeDesc
forStmt = 'for' (identWithPragma ^+ comma) 'in' expr colcom stmt
forExpr = forStmt
expr = (blockExpr
      | ifExpr
      | whenExpr
      | caseExpr
      | forExpr
      | tryExpr)
      / simpleExpr
typeKeyw = 'var' | 'out' | 'ref' | 'ptr' | 'shared' | 'tuple'
         | 'proc' | 'iterator' | 'distinct' | 'object' | 'enum'
primary = typeKeyw typeDescK
        /  prefixOperator* identOrLiteral primarySuffix*
        / 'bind' primary
typeDesc = simpleExpr
typeDefAux = simpleExpr
           | 'concept' typeClass
postExprBlocks = ':' stmt? ( IND{=} doBlock
                           | IND{=} 'of' exprList ':' stmt
                           | IND{=} 'elif' expr ':' stmt
                           | IND{=} 'except' exprList ':' stmt
                           | IND{=} 'else' ':' stmt )*
exprStmt = simpleExpr
         (( '=' optInd expr colonBody? )
         / ( expr ^+ comma
             doBlocks
              / macroColon
           ))?
importStmt = 'import' optInd expr
              ((comma expr)*
              / 'except' optInd (expr ^+ comma))
includeStmt = 'include' optInd expr ^+ comma
fromStmt = 'from' moduleName 'import' optInd expr (comma expr)*
returnStmt = 'return' optInd expr?
raiseStmt = 'raise' optInd expr?
yieldStmt = 'yield' optInd expr?
discardStmt = 'discard' optInd expr?
breakStmt = 'break' optInd expr?
continueStmt = 'break' optInd expr?
condStmt = expr colcom stmt COMMENT?
           (IND{=} 'elif' expr colcom stmt)*
           (IND{=} 'else' colcom stmt)?
ifStmt = 'if' condStmt
whenStmt = 'when' condStmt
whileStmt = 'while' expr colcom stmt
ofBranch = 'of' exprList colcom stmt
ofBranches = ofBranch (IND{=} ofBranch)*
                      (IND{=} 'elif' expr colcom stmt)*
                      (IND{=} 'else' colcom stmt)?
caseStmt = 'case' expr ':'? COMMENT?
            (IND{&gt;} ofBranches DED
            | IND{=} ofBranches)
tryStmt = 'try' colcom stmt &amp;(IND{=}? 'except'|'finally')
           (IND{=}? 'except' exprList colcom stmt)*
           (IND{=}? 'finally' colcom stmt)?
tryExpr = 'try' colcom stmt &amp;(optInd 'except'|'finally')
           (optInd 'except' exprList colcom stmt)*
           (optInd 'finally' colcom stmt)?
exceptBlock = 'except' colcom stmt
blockStmt = 'block' symbol? colcom stmt
blockExpr = 'block' symbol? colcom stmt
staticStmt = 'static' colcom stmt
deferStmt = 'defer' colcom stmt
asmStmt = 'asm' pragma? (STR_LIT | RSTR_LIT | TRIPLESTR_LIT)
genericParam = symbol (comma symbol)* (colon expr)? ('=' optInd expr)?
genericParamList = '[' optInd
  genericParam ^* (comma/semicolon) optPar ']'
pattern = '{' stmt '}'
indAndComment = (IND{&gt;} COMMENT)? | COMMENT?
routine = optInd identVis pattern? genericParamList?
  paramListColon pragma? ('=' COMMENT? stmt)? indAndComment
commentStmt = COMMENT
section(p) = COMMENT? p / (IND{&gt;} (p / COMMENT)^+IND{=} DED)
constant = identWithPragma (colon typeDesc)? '=' optInd expr indAndComment
enum = 'enum' optInd (symbol optInd ('=' optInd expr COMMENT?)? comma?)+
objectWhen = 'when' expr colcom objectPart COMMENT?
            ('elif' expr colcom objectPart COMMENT?)*
            ('else' colcom objectPart COMMENT?)?
objectBranch = 'of' exprList colcom objectPart
objectBranches = objectBranch (IND{=} objectBranch)*
                      (IND{=} 'elif' expr colcom objectPart)*
                      (IND{=} 'else' colcom objectPart)?
objectCase = 'case' identWithPragma ':' typeDesc ':'? COMMENT?
            (IND{&gt;} objectBranches DED
            | IND{=} objectBranches)
objectPart = IND{&gt;} objectPart^+IND{=} DED
           / objectWhen / objectCase / 'nil' / 'discard' / declColonEquals
object = 'object' pragma? ('of' typeDesc)? COMMENT? objectPart
typeClassParam = ('var' | 'out')? symbol
typeClass = typeClassParam ^* ',' (pragma)? ('of' typeDesc ^* ',')?
              &amp;IND{&gt;} stmt
typeDef = identWithPragmaDot genericParamList? '=' optInd typeDefAux
            indAndComment?
varTuple = '(' optInd identWithPragma ^+ comma optPar ')' '=' optInd expr
colonBody = colcom stmt doBlocks?
variable = (varTuple / identColonEquals) colonBody? indAndComment
bindStmt = 'bind' optInd qualifiedIdent ^+ comma
mixinStmt = 'mixin' optInd qualifiedIdent ^+ comma
pragmaStmt = pragma (':' COMMENT? stmt)?
simpleStmt = ((returnStmt | raiseStmt | yieldStmt | discardStmt | breakStmt
           | continueStmt | pragmaStmt | importStmt | exportStmt | fromStmt
           | includeStmt | commentStmt) / exprStmt) COMMENT?
complexOrSimpleStmt = (ifStmt | whenStmt | whileStmt
                    | tryStmt | forStmt
                    | blockStmt | staticStmt | deferStmt | asmStmt
                    | 'proc' routine
                    | 'method' routine
                    | 'iterator' routine
                    | 'macro' routine
                    | 'template' routine
                    | 'converter' routine
                    | 'type' section(typeDef)
                    | 'const' section(constant)
                    | ('let' | 'var' | 'using') section(variable)
                    | bindStmt | mixinStmt)
                    / simpleStmt
stmt = (IND{&gt;} complexOrSimpleStmt^+(IND{=} / ';') DED)
     / simpleStmt ^+ ';'
</pre>

<h1><a class="toc-backref" id="求值顺序" href="#求值顺序">求值顺序</a></h1><p>评估顺序是从左到右，从内到外，因为它是大多数其他命令式编程语言的典型：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Operator">$</span><span class="Identifier">arg</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">arg</span>

<span class="Keyword">discard</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Identifier">doAssert</span> <span class="Identifier">s</span> <span class="Operator">==</span> <span class="StringLit">&quot;123&quot;</span></pre><p>赋值也不例外，左侧表达式在右侧之前进行求值：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">v</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Keyword">proc</span> <span class="Identifier">getI</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">v</span>
  <span class="Identifier">inc</span> <span class="Identifier">v</span>

<span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">someCopy</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">b</span>

<span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">getI</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">getI</span><span class="Punctuation">(</span><span class="Punctuation">)</span>

<span class="Identifier">doAssert</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">]</span>

<span class="Identifier">v</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Identifier">someCopy</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">getI</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">getI</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Identifier">doAssert</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">]</span></pre><p>基本原理：与重载赋值或赋值类操作的一致性 <tt class="docutils literal"><span class="pre">a = b</span></tt> 可以读作 <tt class="docutils literal"><span class="pre">performSomeCopy(a, b)</span></tt>.</p>

<h1><a class="toc-backref" id="常量和常量表达式" href="#常量和常量表达式">常量和常量表达式</a></h1><p><span id="常量_1">常量</span> 是一个与常量表达式值绑定的符号。 常量表达式仅限于依赖于以下类别的值和操作，因为它们要么构建在语言中，要么在对常量表达式进行语义分析之前进行声明和求值：</p>
<ul class="simple"><li>字面值</li>
<li>内置运算符</li>
<li>之前声明的常量和编译时变量</li>
<li>之前声明过的宏和模板</li>
<li>之前声明的过程除了可能修改编译时变量之外没有任何副作用</li>
</ul>
<p>常量表达式可以包含可以在内部使用编译时支持的所有Nim功能的代码块（详见下一节）。 在这样的代码块中，可以声明变量然后稍后读取和更新它们，或者声明变量并将它们传递给修改它们的过程。 但是，此类块中的代码仍必须遵循上面列出的用于引用块外部的值和操作的限制。</p>
<p>访问和修改编译时变量的能力增加了常量表达式的灵活性。 例如，下面的代码在 <strong>编译时</strong> 打印Fibonacci数列的开头。 （这是对定义常量的灵活性的证明，而不是解决此问题的推荐样式！）</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">strformat</span>

<span class="Keyword">var</span> <span class="Identifier">fib_n</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Keyword">var</span> <span class="Identifier">fib_prev</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Keyword">var</span> <span class="Identifier">fib_prev_prev</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Identifier">next_fib</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">fib_n</span> <span class="Operator">&lt;</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
    <span class="Identifier">fib_n</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">fib_prev_prev</span> <span class="Operator">+</span> <span class="Identifier">fib_prev</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">fib_n</span><span class="Punctuation">)</span>
  <span class="Identifier">fib_prev_prev</span> <span class="Operator">=</span> <span class="Identifier">fib_prev</span>
  <span class="Identifier">fib_prev</span> <span class="Operator">=</span> <span class="Identifier">result</span>

<span class="Keyword">const</span> <span class="Identifier">f0</span> <span class="Operator">=</span> <span class="Identifier">next_fib</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">const</span> <span class="Identifier">f1</span> <span class="Operator">=</span> <span class="Identifier">next_fib</span><span class="Punctuation">(</span><span class="Punctuation">)</span>

<span class="Keyword">const</span> <span class="Identifier">display_fib</span> <span class="Operator">=</span> <span class="Keyword">block</span><span class="Punctuation">:</span>
  <span class="Keyword">const</span> <span class="Identifier">f2</span> <span class="Operator">=</span> <span class="Identifier">next_fib</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="RawData">fmt&quot;Fibonacci sequence: {f0}, {f1}, {f2}&quot;</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">3.</span><span class="Operator">.</span><span class="DecNumber">12</span><span class="Punctuation">:</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="RawData">fmt&quot;, {next_fib()}&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span>

<span class="Keyword">static</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">display_fib</span></pre>
<h1><a class="toc-backref" id="编译期执行限制" href="#编译期执行限制">编译期执行限制</a></h1><p>将在编译时执行的Nim代码不能使用以下语言功能：</p>
<ul class="simple"><li>方法</li>
<li>闭包迭代器</li>
<li><tt class="docutils literal"><span class="pre">cast</span></tt> 运算符</li>
<li>引用(指针)类型</li>
<li>外部函数接口（FFI）</li>
</ul>
<p>随着时间的推移，部分或全部这些限制可能会被取消。</p>

<h1><a class="toc-backref" id="类型" href="#类型">类型</a></h1><p>所有表达式都具有在语义分析期间已知的类型。 Nim是静态类型的。可以声明新类型，这实际上定义了可用于表示此自定义类型的标识符。</p>
<p>这些是主要的类型：</p>
<ul class="simple"><li>序数类型（由整数，bool，字符，枚举（及其子范围）类型组成）</li>
<li>浮点类型</li>
<li>字符串类型</li>
<li>结构化类型</li>
<li>引用 (指针)类型</li>
<li>过程类型</li>
<li>泛型类型</li>
</ul>

<h2><a class="toc-backref" id="类型-序数类型" href="#类型-序数类型">序数类型</a></h2><p>序数类型有以下特征：</p>
<ul class="simple"><li>序数类型是可数和有序的。该属性允许定义函数的操作 <tt class="docutils literal"><span class="pre">inc</span></tt>, <tt class="docutils literal"><span class="pre">ord</span></tt>, <tt class="docutils literal"><span class="pre">dec</span></tt> 。</li>
<li>序数值具有最小可能值。尝试进一步向下计数低于最小值会产生已检查的运行时或静态错误。</li>
<li>序数值具有最大可能值。尝试计数超过最大值会产生已检查的运行时或静态错误。</li>
</ul>
<p>整数，bool，字符和枚举类型（以及这些类型的子范围）属于序数类型。 出于简化实现的原因，类型 <tt class="docutils literal"><span class="pre">uint</span></tt> 和 <tt class="docutils literal"><span class="pre">uint64</span></tt> 不是序数类型。 （这将在该语言的更高版本中更改。）</p>
<p>如果基类型是序数类型，则不同类型是序数类型。</p>

<h2><a class="toc-backref" id="类型-预定义整数类型" href="#类型-预定义整数类型">预定义整数类型</a></h2><p>这些整数类型是预定义的：</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">int</span></tt></dt>
<dd>通用有符号整数类型;它的大小取决于平台，并且与指针大小相同。 一般应该使用这种类型。 没有类型后缀的整数文字是这种类型，如果它在 <tt class="docutils literal"><span class="pre">low(int32)... high(int32)</span></tt> 范围内，否则文字的类型是 <tt class="docutils literal"><span class="pre">int64</span></tt> 。</dd>
<dt>intXX</dt>
<dd>附加的有符号整数类型的XX位使用此命名方案（例如：int16是16位宽整数）。 当前的实现支持 <tt class="docutils literal"><span class="pre">int8</span></tt>, <tt class="docutils literal"><span class="pre">int16</span></tt>, <tt class="docutils literal"><span class="pre">int32</span></tt>, <tt class="docutils literal"><span class="pre">int64</span></tt> 。 这些类型的文字后缀为'iXX。</dd>
<dt><tt class="docutils literal"><span class="pre">uint</span></tt></dt>
<dd>通用的 <span id="无符号整型_1">无符号整型</span> ; 它的大小取决于平台，并且与指针大小相同。 类型后缀为 <tt class="docutils literal"><span class="pre">'u</span></tt> 的整数字面值就是这种类型。</dd>
<dt>uintXX</dt>
<dd>附加的无符号整数类型的XX位使用此命名方案（例如：uint16是16位宽的无符号整数）。 当前的实现支持 <tt class="docutils literal"><span class="pre">uint8</span></tt>, <tt class="docutils literal"><span class="pre">uint16</span></tt>, <tt class="docutils literal"><span class="pre">uint32</span></tt>, <tt class="docutils literal"><span class="pre">uint64</span></tt> 。 这些类型的字面值具有后缀 'uXX 。 无符号操作被全面封装; 不会导致上溢或下溢。</dd>
</dl>
<p>除了有符号和无符号整数的常用算术运算符 (<tt class="docutils literal"><span class="pre">+ - *</span></tt> etc.) 之外，还有一些运算符正式处理 <em>整型</em> 整数但将它们的参数视为 <em>无符号</em>: 它们主要用于向后与缺少无符号整数类型的旧版本语言的兼容性。 有符号整数的这些无符号运算使用 <tt class="docutils literal"><span class="pre">%</span></tt> 后缀作为约定：</p>
<table border="1" class="docutils"><tr><th>操作符</th><th>含义</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">a +% b</span></tt></td><td>无符号整型加法</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a -% b</span></tt></td><td>无符号整型减法</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a *% b</span></tt></td><td>无符号整型乘法</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a /% b</span></tt></td><td>无符号整型除法</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a %% b</span></tt></td><td>无符号整型取模</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a &lt;% b</span></tt></td><td>无符号比较 <tt class="docutils literal"><span class="pre">a</span></tt> 和 <tt class="docutils literal"><span class="pre">b</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a &lt;=% b</span></tt></td><td>无符号比较 <tt class="docutils literal"><span class="pre">a</span></tt> 和 <tt class="docutils literal"><span class="pre">b</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">ze(a)</span></tt></td><td>用零填充 <tt class="docutils literal"><span class="pre">a</span></tt> 的位，直到它具有 <tt class="docutils literal"><span class="pre">int</span></tt> 类型的宽度</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">toU8(a)</span></tt></td><td>8位无符号转换 <tt class="docutils literal"><span class="pre">a</span></tt>  (仍然是 <tt class="docutils literal"><span class="pre">int8</span></tt> 类型)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">toU16(a)</span></tt></td><td>16位无符号转换 <tt class="docutils literal"><span class="pre">a</span></tt>  (仍然是 <tt class="docutils literal"><span class="pre">int16</span></tt> 类型)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">toU32(a)</span></tt></td><td>32位无符号转换 <tt class="docutils literal"><span class="pre">a</span></tt>  (仍然是 <tt class="docutils literal"><span class="pre">int32</span></tt> 类型)</td></tr>
</table><p><span id="自动类型转换_1">自动类型转换</span> 在使用不同类型的整数类型的表达式中执行：较小的类型转换为较大的类型。</p>
<p><span id="缩小类型转换_1">缩小类型转换</span> 将较大的类型转换为较小的类型（例如 <tt class="docutils literal"><span class="pre">int32 - &gt; int16</span></tt> 。 <span id="扩展类型转换_1">扩展类型转换</span> 将较小的类型转换为较大的类型（例如 <tt class="docutils literal"><span class="pre">int16 - &gt; int32</span></tt> ）。 Nim中只有扩展类型转型是 <em>隐式的</em>:</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">myInt16</span> <span class="Operator">=</span> <span class="DecNumber">5</span><span class="Identifier">i16</span>
<span class="Keyword">var</span> <span class="Identifier">myInt</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="DecNumber">34</span>     <span class="Comment"># of type ``int16``</span>
<span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="Identifier">myInt</span>  <span class="Comment"># of type ``int``</span>
<span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="DecNumber">2</span><span class="Identifier">i32</span>   <span class="Comment"># of type ``int32``</span></pre><p>但是，如果字面值适合这个较小的类型并且这样的转换比其他隐式转换便宜，则 <tt class="docutils literal"><span class="pre">int</span></tt> 文字可以隐式转换为较小的整数类型，因此 <tt class="docutils literal"><span class="pre">myInt16 + 34</span></tt> 产生 <tt class="docutils literal"><span class="pre">int16</span></tt> 结果。</p>
<p>有关详细信息，请参阅 <a class="reference external" href="#type-relations-convertible-relation">可转换关系</a> 。</p>

<h2><a class="toc-backref" id="类型-子范围类型" href="#类型-子范围类型">子范围类型</a></h2><p>子范围类型是序数或浮点类型（基本类型）的值范围。</p>
<p>要定义子范围类型，必须指定其限制值 - 类型的最低值和最高值。例如：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Subrange</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">]</span>
  <span class="Identifier">PositiveFloat</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.0</span><span class="Operator">..</span><span class="Identifier">Inf</span><span class="Punctuation">]</span></pre><p><tt class="docutils literal"><span class="pre">Subrange</span></tt> 是整数的子范围，只能保存0到5的值。 <tt class="docutils literal"><span class="pre">PositiveFloat</span></tt> 定义所有正浮点值的子范围。 NaN不属于任何浮点类型的子范围。 将任何其他值分配给类型为 <tt class="docutils literal"><span class="pre">Subrange</span></tt> 的变量是检查的运行时错误（如果可以在语义分析期间确定，则为静态错误）。 允许从基本类型到其子类型之一（反之亦然）的分配。</p>
<p>子范围类型与其基类型具有相同的大小（Subrange示例中的 <tt class="docutils literal"><span class="pre">int</span></tt> ）。</p>

<h2><a class="toc-backref" id="类型-预定义浮点类型" href="#类型-预定义浮点类型">预定义浮点类型</a></h2><p>以下浮点类型是预定义的：</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">float</span></tt></dt>
<dd>通用浮点类型;它的大小曾经是平台相关的，但现在它总是映射到 <tt class="docutils literal"><span class="pre">float64</span></tt> 。一般应该使用这种类型。</dd>
<dt>floatXX</dt>
<dd>实现可以使用此命名方案定义XX位的其他浮点类型（例如：float64是64位宽的浮点数）。 当前的实现支持 <tt class="docutils literal"><span class="pre">float32</span></tt> 和 <tt class="docutils literal"><span class="pre">float64</span></tt> 。 这些类型的字面值具有后缀 'fXX 。</dd>
</dl>
<p>执行具有不同类型浮点类型的表达式中的自动类型转换：有关更多详细信息，请参阅 <tt class="docutils literal"><span class="pre">可转换关系</span></tt> 。 在浮点类型上执行的算术遵循IEEE标准。 整数类型不会自动转换为浮点类型，反之亦然。</p>
<p>IEEE标准定义了五种类型的浮点异常：</p>
<ul class="simple"><li>无效: 使用数学上无效的操作数的操作, 例如 0.0/0.0, sqrt(-1.0), 和log(-37.8).</li>
<li>除以零：除数为零，且除数是有限的非零数，例如1.0 / 0.0。</li>
<li>溢出：操作产生的结果超出指数范围，例如MAXDOUBLE + 0.0000000000001e308。</li>
<li>下溢：操作产生的结果太小而无法表示为正常数字，例如，MINDOUBLE * MINDOUBLE。</li>
<li>不精确：操作产生的结果无法用无限精度表示，例如，输入中的2.0 / 3.0，log（1.1）和0.1。</li>
</ul>
<p>IEEE异常在执行期间被忽略或映射到Nim异常: <span id="floatinvalidoperror_1">FloatInvalidOpError</span>, <span id="floatdivbyzeroerror_1">FloatDivByZeroError</span>, <span id="floatoverflowerror_1">FloatOverflowError</span>, <span id="floatunderflowerror_1">FloatUnderflowError</span>, 和 <span id="floatinexacterror_1">FloatInexactError</span> 。 这些异常继承自 <span id="floatingpointerror_1">FloatingPointError</span> 基类。</p>
<p>Nim提供了编译指示 <span id="nanchecks_1">nanChecks</span> 和 <span id="infchecks_1">infChecks</span> 控制是否忽略IEEE异常或捕获Nim异常：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">nanChecks</span><span class="Punctuation">:</span> <span class="Identifier">on</span><span class="Punctuation">,</span> <span class="Identifier">infChecks</span><span class="Punctuation">:</span> <span class="Identifier">on</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="FloatNumber">1.0</span>
<span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="FloatNumber">0.0</span>
<span class="Identifier">echo</span> <span class="Identifier">b</span> <span class="Operator">/</span> <span class="Identifier">b</span> <span class="Comment"># raises FloatInvalidOpError</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">/</span> <span class="Identifier">b</span> <span class="Comment"># raises FloatOverflowError</span></pre><p>在当前的实现中， <tt class="docutils literal"><span class="pre">FloatDivByZeroError</span></tt> 和 <tt class="docutils literal"><span class="pre">FloatInexactError</span></tt> 永远不会被引发。 <tt class="docutils literal"><span class="pre">FloatOverflowError</span></tt> 取代了 <tt class="docutils literal"><span class="pre">FloatDivByZeroError</span></tt> 。 还有一个 <span id="floatchecks_1">floatChecks</span> 编译指示用作 <tt class="docutils literal"><span class="pre">nanChecks</span></tt> 和 <tt class="docutils literal"><span class="pre">infChecks</span></tt> 的快捷方式。 <tt class="docutils literal"><span class="pre">floatChecks</span></tt> 默认关闭。</p>
<p>受 <tt class="docutils literal"><span class="pre">floatChecks</span></tt> 编译指示影响的唯一操作是浮点类型的 <tt class="docutils literal"><span class="pre">+</span></tt> ， <tt class="docutils literal"><span class="pre">-</span></tt> ， <tt class="docutils literal"><span class="pre">*</span></tt> ， <tt class="docutils literal"><span class="pre">/</span></tt> 运算符。</p>
<p>在语义分析期间，实现应始终使用最大精度来评估浮点指针值; 这表示在常量展开期间，表达式 <tt class="docutils literal"><span class="pre">0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64</span></tt> 求值为真。</p>

<h2><a class="toc-backref" id="类型-布尔类型" href="#类型-布尔类型">布尔类型</a></h2><p>布尔类型在Nim中命名为 <span id="bool_1">bool</span> 并且可以是两个预定义值之一 <tt class="docutils literal"><span class="pre">true</span></tt> 和 <tt class="docutils literal"><span class="pre">false</span></tt> 。 <tt class="docutils literal"><span class="pre">while</span></tt>, <tt class="docutils literal"><span class="pre">if</span></tt>, <tt class="docutils literal"><span class="pre">elif</span></tt>, <tt class="docutils literal"><span class="pre">when</span></tt> 中的语句需要是 <tt class="docutils literal"><span class="pre">bool</span></tt> 类型。</p>
<p>这种情况成立:<pre>
ord(false) == 0 and ord(true) == 1</pre>
</p>
<p>布尔类型定义了运算符 <tt class="docutils literal"><span class="pre">not, and, or, xor, &lt;, &lt;=, &gt;, &gt;=, !=, ==</span></tt> 。 <tt class="docutils literal"><span class="pre">and</span></tt> 和 <tt class="docutils literal"><span class="pre">or</span></tt> 运算符执行短路求值。示例:</p>
<pre class="listing"><span class="Keyword">while</span> <span class="Identifier">p</span> <span class="Operator">!=</span> <span class="Keyword">nil</span> <span class="Keyword">and</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">!=</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">:</span>
  <span class="Comment"># 如果 p == nil， p.name不被求值。</span>
  <span class="Identifier">p</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">next</span></pre><p>bool类型的大小是一个字节。</p>

<h2><a class="toc-backref" id="类型-字符类型" href="#类型-字符类型">字符类型</a></h2><p>字符类型在Nim中被命名为 <tt class="docutils literal"><span class="pre">char</span></tt> 。它的大小是一字节。 因此，它不能代表UTF-8字符，而是它的一部分。 这样做是出于效率：对于绝大多数用例，由于UTF-8是专门为此设计的，所得到的程序仍然可以正确处理UTF-8。 另一个原因是Nim可以有效地支持 <tt class="docutils literal"><span class="pre">array[char,int]</span></tt> 或 <tt class="docutils literal"><span class="pre">set[char]</span></tt> ，因为许多算法依赖于这个特性。 <tt class="docutils literal"><span class="pre">Rune</span></tt> 类型用于Unicode字符，它可以表示任何Unicode字符。 <tt class="docutils literal"><span class="pre">Rune</span></tt> 在 <a class="reference external" href="unicode.html">unicode module</a> 中声明。</p>

<h2><a class="toc-backref" id="类型-枚举类型" href="#类型-枚举类型">枚举类型</a></h2><p>枚举类型定义一个新类型，其值由指定的值组成。这些值是有序的。例：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Direction</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">north</span><span class="Punctuation">,</span> <span class="Identifier">east</span><span class="Punctuation">,</span> <span class="Identifier">south</span><span class="Punctuation">,</span> <span class="Identifier">west</span></pre><p>现在以下内容成立:<pre>
ord(north) == 0
ord(east) == 1
ord(south) == 2
ord(west) == 3

# 也允许:
ord(Direction.west) == 3</pre>
</p>
<p>因此, north &lt; east &lt; south &lt; west 。 比较运算符可以与枚举类型一起使用。 枚举值也可以使用它所在的枚举类型 <tt class="docutils literal"><span class="pre">Direction.nort</span></tt> 来限定，而不是 <tt class="docutils literal"><span class="pre">north</span></tt> 等。</p>
<p>为了更好地与其他编程语言连接，可以为枚举类型的字段分配显式序数值。 但是，序数值必须按升序排列。 未明确给出序数值的字段被赋予前一个字段+ 1的值。</p>
<p>显式有序枚举可以有 <em>洞</em> ：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">TokenType</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="DecNumber">89</span> <span class="Comment"># 洞是合法的</span></pre><p>但是，它不再是序数，因此不可能将这些枚举用作数组的索引类型。 过程 <tt class="docutils literal"><span class="pre">inc</span></tt>, <tt class="docutils literal"><span class="pre">dec</span></tt>, <tt class="docutils literal"><span class="pre">succ</span></tt> 和 <tt class="docutils literal"><span class="pre">pred</span></tt> 对于它们不可用。</p>
<p>编译器支持枚举的内置字符串化运算符 <tt class="docutils literal"><span class="pre">$</span></tt> 。 字符串化的结果可以通过显式给出要使用的字符串值来控制：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valueA</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="StringLit">&quot;my value A&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
    <span class="Identifier">valueB</span> <span class="Operator">=</span> <span class="StringLit">&quot;value B&quot;</span><span class="Punctuation">,</span>
    <span class="Identifier">valueC</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">,</span>
    <span class="Identifier">valueD</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">)</span></pre><p>从示例中可以看出，可以通过使用元组指定字段的序数值及其字符串值。 也可以只指定其中一个。</p>
<p>枚举可以使用 <tt class="docutils literal"><span class="pre">pure</span></tt> 编译指示进行标记，以便将其字段添加到特定模块特定的隐藏作用域，该作用域仅作为最后一次尝试进行查询。 只有没有歧义的符号才会添加到此范围。 但总是可以通过写为 <tt class="docutils literal"><span class="pre">MyEnum.value</span></tt> 的类型限定来访问:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valueA</span><span class="Punctuation">,</span> <span class="Identifier">valueB</span><span class="Punctuation">,</span> <span class="Identifier">valueC</span><span class="Punctuation">,</span> <span class="Identifier">valueD</span><span class="Punctuation">,</span> <span class="Identifier">amb</span>
  
  <span class="Identifier">OtherEnum</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valueX</span><span class="Punctuation">,</span> <span class="Identifier">valueY</span><span class="Punctuation">,</span> <span class="Identifier">valueZ</span><span class="Punctuation">,</span> <span class="Identifier">amb</span>


<span class="Identifier">echo</span> <span class="Identifier">valueA</span> <span class="Comment"># MyEnum.valueA</span>
<span class="Identifier">echo</span> <span class="Identifier">amb</span>    <span class="Comment"># 错误：不清楚它是MyEnum.amb还是OtherEnum.amb</span>
<span class="Identifier">echo</span> <span class="Identifier">MyEnum</span><span class="Operator">.</span><span class="Identifier">amb</span> <span class="Comment"># OK.</span></pre><p>要使用枚举实现位字段，请参阅 <a class="reference external" href="#set-type-bit-fields">Bit fields</a></p>

<h2><a class="toc-backref" id="类型-字符串类型" href="#类型-字符串类型">字符串类型</a></h2><p>所有字符串文字都是 <tt class="docutils literal"><span class="pre">string</span></tt> 类型。 Nim中的字符串与字符序列非常相似。 但是，Nim中的字符串都是以零结尾的并且具有长度字段。 可以用内置的 <tt class="docutils literal"><span class="pre">len</span></tt> 过程检索长度;长度永远不会计算终止零。</p>
<p>除非首先将字符串转换为 <tt class="docutils literal"><span class="pre">cstring</span></tt> 类型，否则无法访问终止零。 终止零确保可以在O(1)中完成此转换，无需任何分配。</p>
<p>字符串的赋值运算符始终复制字符串。 <tt class="docutils literal"><span class="pre">&amp;</span></tt> 运算符拼接字符串。</p>
<p>大多数原生Nim类型支持使用特殊的 <tt class="docutils literal"><span class="pre">$</span></tt> proc转换为字符串。</p>
<p>例如，当调用 <tt class="docutils literal"><span class="pre">echo</span></tt> proc时，会调用参数的内置字符串化操作：</p>
<pre class="listing"><span class="Identifier">echo</span> <span class="DecNumber">3</span> <span class="Comment"># 为 `int` 调用 `$`</span></pre><p>每当用户创建一个专门的对象时，该过程的实现提供了 <tt class="docutils literal"><span class="pre">string</span></tt> 表示。</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Identifier">Person</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Comment"># `$` 始终返回字符串</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot; is &quot;</span> <span class="Operator">&amp;</span>
          <span class="Operator">$</span><span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">age</span> <span class="Operator">&amp;</span> <span class="Comment"># we *need* the `$` in front of p.age which</span>
                   <span class="Comment"># is natively an integer to convert it to</span>
                   <span class="Comment"># a string</span>
          <span class="StringLit">&quot; years old.&quot;</span></pre><p>虽然也可以使用 <tt class="docutils literal"><span class="pre">$ p.name</span></tt> ，但字符串上的 <tt class="docutils literal"><span class="pre">$</span></tt> 操作什么都不做。 请注意，我们不能依赖于从 <tt class="docutils literal"><span class="pre">int</span></tt> 到 <tt class="docutils literal"><span class="pre">string` 的自动转换，就像 ``echo</span></tt> proc一样。</p>
<p>字符串按字典顺序进行比较。 所有比较运算符都可用。 字符串可以像数组一样索引（下限为0）。 与数组不同，它们可用于case语句：</p>
<pre class="listing"><span class="Keyword">case</span> <span class="Identifier">paramStr</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;-v&quot;</span><span class="Punctuation">:</span> <span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">options</span><span class="Punctuation">,</span> <span class="Identifier">optVerbose</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;-h&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;-?&quot;</span><span class="Punctuation">:</span> <span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">options</span><span class="Punctuation">,</span> <span class="Identifier">optHelp</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;invalid command line option!</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span></pre><p>按照惯例，所有字符串都是UTF-8字符串，但不强制执行。 例如，从二进制文件读取字符串时，它们只是一个字节序列。 索引操作 <tt class="docutils literal"><span class="pre">s[i]</span></tt> 表示 <tt class="docutils literal"><span class="pre">s</span></tt> 的第i个 <em>char</em> ，而不是第i个 <em>unichar</em> 。 来自 <a class="reference external" href="unicode.html">unicode module</a> 的迭代器 <tt class="docutils literal"><span class="pre">runes</span></tt> 可用于迭代所有Unicode字符。</p>

<h2><a class="toc-backref" id="类型-cstring类型" href="#类型-cstring类型">cstring类型</a></h2><p><tt class="docutils literal"><span class="pre">cstring</span></tt> 类型意味着 <tt class="docutils literal"><span class="pre">compatible string</span></tt> 是编译后端的字符串的原生表示。 对于C后端，``cstring`` 类型表示一个指向零终止char数组的指针，该数组与Ansi C中的 <tt class="docutils literal"><span class="pre">char*</span></tt> 类型兼容。 其主要目的在于与C轻松互通。 索引操作 <tt class="docutils literal"><span class="pre">s [i]</span></tt> 表示 <tt class="docutils literal"><span class="pre">s</span></tt> 的第i个 <em>char</em>;但是没有执行检查 <tt class="docutils literal"><span class="pre">cstring</span></tt> 的边界，使索引操作不安全。</p>
<p>为方便起见，Nim中的 <tt class="docutils literal"><span class="pre">string</span></tt> 可以隐式转换为 <tt class="docutils literal"><span class="pre">cstring</span></tt> 。 如果将Nim字符串传递给C风格的可变参数proc，它也会隐式转换为 <tt class="docutils literal"><span class="pre">cstring</span></tt> ：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;printf&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Punctuation">,</span>
                                  <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;stdio.h&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Identifier">printf</span><span class="Punctuation">(</span><span class="StringLit">&quot;This works %s&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;as expected&quot;</span><span class="Punctuation">)</span></pre><p>即使转换是隐式的，它也不是 <em>安全的</em> ：垃圾收集器不认为 <tt class="docutils literal"><span class="pre">cstring</span></tt> 是根，并且可能收集底层内存。 然而在实践中，这几乎从未发生过，因为GC保守地估计堆栈根。 可以使用内置过程 <tt class="docutils literal"><span class="pre">GC_ref</span></tt> 和 <tt class="docutils literal"><span class="pre">GC_unref</span></tt> 来保持字符串数据在少数情况下保持活动状态。</p>
<p>为返回字符串的cstrings定义了 <tt class="docutils literal"><span class="pre">$</span></tt> proc。因此，从cstring获取一个nim字符串：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">str</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;Hello!&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">cstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span> <span class="Operator">=</span> <span class="Identifier">str</span>
<span class="Keyword">var</span> <span class="Identifier">newstr</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">cstr</span></pre>
<h2><a class="toc-backref" id="类型-结构化类型" href="#类型-结构化类型">结构化类型</a></h2><p>结构化类型的变量可以同时保存多个值。 结构化类型可以嵌套到无限级别。 数组、序列、元组、对象和集合属于结构化类型。</p>

<h2><a class="toc-backref" id="类型-数组和序列类型" href="#类型-数组和序列类型">数组和序列类型</a></h2><p>数组是同类型的，这意味着数组中的每个元素都具有相同的类型。 数组总是具有指定为常量表达式的固定长度（开放数组除外）。 它们可以按任何序数类型索引。 参数 <tt class="docutils literal"><span class="pre">A</span></tt> 可以是 <em>开放数组</em> ，在这种情况下，它由0到 <tt class="docutils literal"><span class="pre">len（A）- 1</span></tt> 的整数索引。 数组表达式可以由数组构造函数 <tt class="docutils literal"><span class="pre">[]</span></tt> 构造。 数组表达式的元素类型是从第一个元素的类型推断出来的。 所有其他元素都需要隐式转换为此类型。</p>
<p>序列类似于数组，但动态长度可能在运行时期间发生变化（如字符串）。 序列实现为可增长的数组，在添加项目时分配内存块。 序列 <tt class="docutils literal"><span class="pre">S</span></tt> 始终用从0到 <tt class="docutils literal"><span class="pre">len(S)-1</span></tt> 的整数索引，并检查其边界。 序列可以由数组构造函数 <tt class="docutils literal"><span class="pre">[]</span></tt> 和数组一起构造，以序列运算符 <tt class="docutils literal"><span class="pre">@</span></tt> 。 为序列分配空间的另一种方法是调用内置的 <tt class="docutils literal"><span class="pre">newSeq</span></tt> 过程。</p>
<p>序列可以传递给 <em>开放数组</em> 类型的参数。</p>
<p>示例：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">IntArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># an array that is indexed with 0..5</span>
  <span class="Identifier">IntSeq</span> <span class="Operator">=</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># a sequence of integers</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">IntArray</span>
  <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">IntSeq</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span>  <span class="Comment"># [] is the array constructor</span>
<span class="Identifier">y</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Comment"># the @ turns the array into a sequence</span>

<span class="Keyword">let</span> <span class="Identifier">z</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="FloatNumber">1.0</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">]</span> <span class="Comment"># the type of z is array[0..3, float]</span></pre><p>数组或序列的下限可以由内置的proc <tt class="docutils literal"><span class="pre">low()</span></tt> 接收，上限由 <tt class="docutils literal"><span class="pre">high()</span></tt> 接收。 长度可以由 <tt class="docutils literal"><span class="pre">len()</span></tt> 接收。序列或开放数组的 <tt class="docutils literal"><span class="pre">low()</span></tt> 总是返回0，因为这是第一个有效索引。 可以使用 <tt class="docutils literal"><span class="pre">add()</span></tt> proc或 <tt class="docutils literal"><span class="pre">&amp;</span></tt> 运算符将元素追加到序列中，并使用 <tt class="docutils literal"><span class="pre">pop()</span></tt> proc删除（并获取）序列的最后一个元素。</p>
<p>符号 <tt class="docutils literal"><span class="pre">x [i]</span></tt> 可用于访问 <tt class="docutils literal"><span class="pre">x</span></tt> 的第i个元素。</p>
<p>数组始终是边界检查（静态或运行时）。可以通过编译指示禁用这些检查，或使用 <tt class="docutils literal"><span class="pre">--boundChecks：off</span></tt> 命令行开关调用编译器。</p>
<p>数组构造函数可以具有可读的显式索引：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Values</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valA</span><span class="Punctuation">,</span> <span class="Identifier">valB</span><span class="Punctuation">,</span> <span class="Identifier">valC</span>

<span class="Keyword">const</span>
  <span class="Identifier">lookupTable</span> <span class="Operator">=</span> <span class="Punctuation">[</span>
    <span class="Identifier">valA</span><span class="Punctuation">:</span> <span class="StringLit">&quot;A&quot;</span><span class="Punctuation">,</span>
    <span class="Identifier">valB</span><span class="Punctuation">:</span> <span class="StringLit">&quot;B&quot;</span><span class="Punctuation">,</span>
    <span class="Identifier">valC</span><span class="Punctuation">:</span> <span class="StringLit">&quot;C&quot;</span>
  <span class="Punctuation">]</span></pre><p>如果省略索引，则使用 <tt class="docutils literal"><span class="pre">succ(lastIndex)</span></tt> 作为索引值：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Values</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valA</span><span class="Punctuation">,</span> <span class="Identifier">valB</span><span class="Punctuation">,</span> <span class="Identifier">valC</span><span class="Punctuation">,</span> <span class="Identifier">valD</span><span class="Punctuation">,</span> <span class="Identifier">valE</span>

<span class="Keyword">const</span>
  <span class="Identifier">lookupTable</span> <span class="Operator">=</span> <span class="Punctuation">[</span>
    <span class="Identifier">valA</span><span class="Punctuation">:</span> <span class="StringLit">&quot;A&quot;</span><span class="Punctuation">,</span>
    <span class="StringLit">&quot;B&quot;</span><span class="Punctuation">,</span>
    <span class="Identifier">valC</span><span class="Punctuation">:</span> <span class="StringLit">&quot;C&quot;</span><span class="Punctuation">,</span>
    <span class="StringLit">&quot;D&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;e&quot;</span>
  <span class="Punctuation">]</span></pre>
<h2><a class="toc-backref" id="类型-开放数组（openarray）" href="#类型-开放数组（openarray）">开放数组（openarray）</a></h2><p>通常，固定大小的数组太不灵活了;程序应该能够处理不同大小的数组。 <span id="开放数组_1">开放数组</span> 类型只能用于参数。 开放数组总是从位置0开始用 <tt class="docutils literal"><span class="pre">int</span></tt> 索引。 <tt class="docutils literal"><span class="pre">len</span></tt> ， <tt class="docutils literal"><span class="pre">low</span></tt> 和 <tt class="docutils literal"><span class="pre">high</span></tt> 操作也可用于开放数组。 具有兼容基类型的任何数组都可以传递给开放数组形参，无关索引类型。 除了数组序列之外，还可以将序列传递给开放数组参数。</p>
<p>开放数组类型不能嵌套： 不支持多维开放数组，因为这种需求很少并且不能有效地完成。</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">testOpenArray</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Identifier">testOpenArray</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">,</span><span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">)</span>  <span class="Comment"># array[]</span>
<span class="Identifier">testOpenArray</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">,</span><span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># seq[]</span></pre>
<h2><a class="toc-backref" id="类型-可变参数" href="#类型-可变参数">可变参数</a></h2><p><tt class="docutils literal"><span class="pre">varargs</span></tt> 参数是一个开放数组参数，它还允许将可变数量的参数传递给过程。 编译器隐式地将参数列表转换为数组：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">)</span>
<span class="Comment"># 转换成:</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>仅当varargs参数是过程头中的最后一个参数时，才会执行此转换。 也可以在此上下文中执行类型转换：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="FloatNumber">4.0</span><span class="Punctuation">)</span>
<span class="Comment"># 转换成:</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="Operator">$</span><span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="FloatNumber">4.0</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>在这个例子中， <tt class="docutils literal"><span class="pre">$</span></tt> 应用于传递给参数 <tt class="docutils literal"><span class="pre">a</span></tt> 的任何参数。 （注意 <tt class="docutils literal"><span class="pre">$</span></tt> 对字符串是一个空操作。）</p>
<p>请注意，传递给 <tt class="docutils literal"><span class="pre">varargs</span></tt> 形参的显式数组构造函数不会隐式地构造另一个隐式数组：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">takeV</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">takeV</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># takeV的T是&quot;int&quot;, 不是&quot;int数组&quot;</span></pre><p><tt class="docutils literal"><span class="pre">varargs[typed]</span></tt> 被特别对待：它匹配任意类型的参数的变量列表，但 <em>始终</em> 构造一个隐式数组。</p>
<p>这是必需的，以便内置的 <tt class="docutils literal"><span class="pre">echo</span></tt> proc执行预期的操作：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">echo</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">typed</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">...</span><span class="Punctuation">}</span>

<span class="Identifier">echo</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span>
<span class="Comment"># 打印 &quot;@[1, 2, 3]&quot; 而不是 &quot;123&quot;</span></pre>
<h2><a class="toc-backref" id="类型-未检查数组" href="#类型-未检查数组">未检查数组</a></h2><p><tt class="docutils literal"><span class="pre">UncheckedArray[T]</span></tt> 类型是一种特殊的 <tt class="docutils literal"><span class="pre">数组</span></tt> ，编译器不检查它的边界。 这对于实现定制灵活大小的数组通常很有用。 另外，未检查数组转换为不确定大小的C数组：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MySeq</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">cap</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">UncheckedArray</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span></pre><p>大致生成C代码:</p>
<pre class="listing"><span class="Keyword">typedef</span> <span class="Keyword">struct</span> <span class="Punctuation">{</span>
  <span class="Identifier">NI</span> <span class="Identifier">len</span><span class="Punctuation">;</span>
  <span class="Identifier">NI</span> <span class="Identifier">cap</span><span class="Punctuation">;</span>
  <span class="Identifier">NI</span> <span class="Identifier">data</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span> <span class="Identifier">MySeq</span><span class="Punctuation">;</span></pre><p>未检查数组的基本类型可能不包含任何GC内存，但目前尚未检查。</p>
<p><strong>未来方向</strong>: 应该在未经检查的数组中允许GC内存，并且应该有一个关于GC如何确定数组的运行时大小的显式注释。</p>

<h2><a class="toc-backref" id="类型-元组和对象类型" href="#类型-元组和对象类型">元组和对象类型</a></h2><p>元组或对象类型的变量是异构存储容器。 元组或对象定义类型的各种命名 <em>字段</em> 。 元组还定义了字段的 <em>顺序</em> 。 元组用于异构存储类型，没有开销和很少的抽象可能性。 构造函数 <tt class="docutils literal"><span class="pre">()</span></tt> 可用于构造元组。 构造函数中字段的顺序必须与元组定义的顺序相匹配。 如果它们以相同的顺序指定相同类型的相同字段，则不同的元组类型 <em>等效</em> 。字段的 <em>名称</em> 也必须相同。</p>
<p>元组的赋值运算符复制每个组件。 对象的默认赋值运算符复制每个组件。 在 <a class="reference external" href="#typeminusboundminusoperationsminusoperator">type-bound-operations-operator</a> 中描述了赋值运算符的重载。</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># 代表人的类型：人由名字和年龄组成</span>
<span class="Keyword">var</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>
<span class="Comment"># 一样，但不太可读：</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">30</span><span class="Punctuation">)</span></pre><p>可以使用括号和尾随逗号构造具有一个未命名字段的元组：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">echoUnaryTuple</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">,</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>

<span class="Identifier">echoUnaryTuple</span> <span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="Punctuation">)</span></pre><p>事实上，每个元组结构都允许使用尾随逗号。</p>
<p>实现将字段对齐以获得最佳访问性能。 对齐与C编译器的方式兼容。</p>
<p>为了与 <tt class="docutils literal"><span class="pre">object</span></tt> 声明保持一致， <tt class="docutils literal"><span class="pre">type</span></tt> 部分中的元组也可以用缩进而不是 <tt class="docutils literal"><span class="pre">[]</span></tt> 来定义：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">tuple</span>   <span class="Comment"># 代表人的类型</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>   <span class="Comment"># 人由名字</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">natural</span>   <span class="Comment"># 和年龄组成</span></pre><p>对象提供了元组不具备的许多功能。 对象提供继承和信息隐藏。 对象在运行时可以访问它们的类型，因此 <tt class="docutils literal"><span class="pre">of</span></tt> 运算符可用于确定对象的类型。 <tt class="docutils literal"><span class="pre">of</span></tt> 运算符类似于Java中的 <tt class="docutils literal"><span class="pre">instanceof</span></tt> 运算符。</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">name</span><span class="Operator">*:</span> <span class="Identifier">string</span>   <span class="Comment"># *表示可以从其他模块访问`name`</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>        <span class="Comment"># 没有*表示该字段已隐藏</span>
  
  <span class="Identifier">Student</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Person</span> <span class="Comment"># 学生是人</span>
    <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="Identifier">int</span>                      <span class="Comment"># 有个id字段</span>

<span class="Keyword">var</span>
  <span class="Identifier">student</span><span class="Punctuation">:</span> <span class="Identifier">Student</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">student</span> <span class="Keyword">of</span> <span class="Identifier">Student</span><span class="Punctuation">)</span> <span class="Comment"># is true</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">student</span> <span class="Keyword">of</span> <span class="Identifier">Person</span><span class="Punctuation">)</span> <span class="Comment"># also true</span></pre><p>应该从定义模块外部可见的对象字段必须用 <tt class="docutils literal"><span class="pre">*</span></tt> 标记。 与元组相反，不同的对象类型永远不会 <em>等价</em> 。 没有祖先的对象是隐式的 <tt class="docutils literal"><span class="pre">final</span></tt> ，因此没有隐藏的类型字段。 可以使用 <tt class="docutils literal"><span class="pre">inheritable</span></tt> pragma来引入除 <tt class="docutils literal"><span class="pre">system.RootObj</span></tt> 之外的新根对象。</p>

<h2><a class="toc-backref" id="类型-对象构造" href="#类型-对象构造">对象构造</a></h2><p>对象也可以使用 <tt class="docutils literal"><span class="pre">对象构造表达式</span></tt> 创建:idx:, 具有语法 <tt class="docutils literal"><span class="pre">T（fieldA：valueA，fieldB：valueB，...）</span></tt> 其中 <tt class="docutils literal"><span class="pre">T</span></tt> 是 <tt class="docutils literal"><span class="pre">object</span></tt> 类型或 <tt class="docutils literal"><span class="pre">ref object</span></tt> 类型：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">student</span> <span class="Operator">=</span> <span class="Identifier">Student</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Anton&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre><p>请注意，与元组不同，对象需要字段名称及其值。 对于 <tt class="docutils literal"><span class="pre">ref object</span></tt> 类型，``system.new`` 是隐式调用的。</p>

<h2><a class="toc-backref" id="类型-对象变体" href="#类型-对象变体">对象变体</a></h2><p>在需要简单变体类型的某些情况下，对象层次结构通常有点过了。 对象变体是通过用于运行时类型灵活性的枚举类型区分的标记联合，对照如在其他语言中找到的 <em>sum类型</em> 和 <em>代数数据类型(ADT)</em> 的概念。</p>
<p>一个示例：</p>
<pre class="listing"><span class="Comment"># 这是一个如何在Nim中建模抽象语法树的示例</span>
<span class="Keyword">type</span>
  <span class="Identifier">NodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span>  <span class="Comment"># 不同的节点类型</span>
    <span class="Identifier">nkInt</span><span class="Punctuation">,</span>          <span class="Comment"># 带有整数值的叶节点</span>
    <span class="Identifier">nkFloat</span><span class="Punctuation">,</span>        <span class="Comment"># 带有浮点值的叶节点</span>
    <span class="Identifier">nkString</span><span class="Punctuation">,</span>       <span class="Comment"># 带有字符串值的叶节点</span>
    <span class="Identifier">nkAdd</span><span class="Punctuation">,</span>          <span class="Comment"># 加法</span>
    <span class="Identifier">nkSub</span><span class="Punctuation">,</span>          <span class="Comment"># 减法</span>
    <span class="Identifier">nkIf</span>            <span class="Comment"># if语句</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">NodeKind</span>  <span class="Comment"># ``kind`` 字段是鉴别字段</span>
    <span class="Keyword">of</span> <span class="Identifier">nkInt</span><span class="Punctuation">:</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Keyword">of</span> <span class="Identifier">nkFloat</span><span class="Punctuation">:</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="Identifier">float</span>
    <span class="Keyword">of</span> <span class="Identifier">nkString</span><span class="Punctuation">:</span> <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">nkSub</span><span class="Punctuation">:</span>
      <span class="Identifier">leftOp</span><span class="Punctuation">,</span> <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Keyword">of</span> <span class="Identifier">nkIf</span><span class="Punctuation">:</span>
      <span class="Identifier">condition</span><span class="Punctuation">,</span> <span class="Identifier">thenPart</span><span class="Punctuation">,</span> <span class="Identifier">elsePart</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>

<span class="Comment"># 创建一个新case对象:</span>
<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkIf</span><span class="Punctuation">,</span> <span class="Identifier">condition</span><span class="Punctuation">:</span> <span class="Keyword">nil</span><span class="Punctuation">)</span>
<span class="Comment"># 访问n.thenPart是有效的，因为 ``nkIf`` 分支是活动的</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">thenPart</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkFloat</span><span class="Punctuation">,</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="FloatNumber">2.0</span><span class="Punctuation">)</span>

<span class="Comment"># 以下语句引发了一个 `FieldError` 异常，因为n.kind的值不合适且 ``nkString`` 分支未激活：</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">strVal</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span>

<span class="Comment"># 无效：会更改活动对象分支：</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">=</span> <span class="Identifier">nkInt</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">leftOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
                          <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># valid：不更改活动对象分支：</span>
<span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">=</span> <span class="Identifier">nkSub</span></pre><p>从示例中可以看出，对象层次结构的优点是不需要在不同对象类型之间进行转换。 但是，访问无效对象字段会引发异常。</p>
<p>对象声明中 <tt class="docutils literal"><span class="pre">case</span></tt> 的语法紧跟着 <tt class="docutils literal"><span class="pre">case</span></tt> 语句的语法： <tt class="docutils literal"><span class="pre">case</span></tt> 部分中的分支也可以缩进。</p>
<p>在示例中，``kind`` 字段称为 <span id="鉴别字段_1">鉴别字段</span> : 为安全起见，不能对其进行地址限制，并且对其赋值受到限制：新值不得导致活动对象分支发生变化。 此外，在对象构造期间指定特定分支的字段时，必须将相应的鉴别字段值指定为常量表达式。</p>
<p>而不是更改活动对象分支，将内存中的旧对象完全替换为新对象：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">leftOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
                          <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># 更改节点的内容：</span>
<span class="Identifier">x</span><span class="Punctuation">[</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">NodeObj</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkString</span><span class="Punctuation">,</span> <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">)</span></pre><p>从版本0.20开始 <tt class="docutils literal"><span class="pre">system.reset</span></tt> 不能再用于支持对象分支的更改，因为这从来就不是完全内存安全的。</p>
<p>作为一项特殊规则，鉴别字段类型也可以使用 <tt class="docutils literal"><span class="pre">case</span></tt> 语句来限制。 如果 <tt class="docutils literal"><span class="pre">case</span></tt> 语句分支中的鉴别字段变量的可能值是所选对象分支的鉴别字段值的子集，则初始化被认为是有效的。 此分析仅适用于序数类型的不可变判别符，并忽略 <tt class="docutils literal"><span class="pre">elif</span></tt> 分支。</p>
<p>A small 示例：</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">unknownKind</span> <span class="Operator">=</span> <span class="Identifier">nkSub</span>

<span class="Comment"># 无效：不安全的初始化，因为类型字段不是静态已知的：</span>
<span class="Keyword">var</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">unknownKind</span><span class="Punctuation">,</span> <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="StringLit">&quot;y&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">case</span> <span class="Identifier">unknownKind</span>
<span class="Keyword">of</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">nkSub</span><span class="Punctuation">:</span>
  <span class="Comment"># valid：此分支的可能值是nkAdd / nkSub对象分支的子集：</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">unknownKind</span><span class="Punctuation">,</span> <span class="Identifier">leftOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;ignoring: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">unknownKind</span></pre>
<h2><a class="toc-backref" id="类型-集合类型" href="#类型-集合类型">集合类型</a></h2>The set type models the mathematical notion of a set. The set's basetype can only be an ordinal type of a certain size, namely:<ul class="simple"><li><tt class="docutils literal"><span class="pre">int8</span></tt>-<tt class="docutils literal"><span class="pre">int16</span></tt></li>
<li><tt class="docutils literal"><span class="pre">uint8</span></tt>/<tt class="docutils literal"><span class="pre">byte</span></tt>-<tt class="docutils literal"><span class="pre">uint16</span></tt></li>
<li><tt class="docutils literal"><span class="pre">char</span></tt></li>
<li><tt class="docutils literal"><span class="pre">enum</span></tt></li>
</ul>
<p>or equivalent. For signed integers the set's base type is defined to be in the range <tt class="docutils literal"><span class="pre">0 .. MaxSetElements-1</span></tt> where <tt class="docutils literal"><span class="pre">MaxSetElements</span></tt> is currently always 2^16.</p>
<p>The reason is that sets are implemented as high performance bit vectors. Attempting to declare a set with a larger type will result in an error:</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">int64</span><span class="Punctuation">]</span> <span class="Comment"># Error: set is too large</span></pre><p>Sets can be constructed via the set constructor: <tt class="docutils literal"><span class="pre">{}</span></tt> is the empty set. The empty set is type compatible with any concrete set type. The constructor can also be used to include elements (and ranges of elements):</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">CharSet</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">CharSet</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">}</span> <span class="Comment"># This constructs a set that contains the</span>
                         <span class="Comment"># letters from 'a' to 'z' and the digits</span>
                         <span class="Comment"># from '0' to '9'</span></pre><p>These operations are supported by sets:</p>
<table border="1" class="docutils"><tr><th>operation</th><th>meaning</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">A + B</span></tt></td><td>union of two sets</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A * B</span></tt></td><td>intersection of two sets</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A - B</span></tt></td><td>difference of two sets (A without B's elements)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A == B</span></tt></td><td>set equality</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A &lt;= B</span></tt></td><td>subset relation (A is subset of B or equal to B)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A &lt; B</span></tt></td><td>strict subset relation (A is a proper subset of B)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">e in A</span></tt></td><td>set membership (A contains element e)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">e notin A</span></tt></td><td>A does not contain element e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">contains(A, e)</span></tt></td><td>A contains element e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">card(A)</span></tt></td><td>the cardinality of A (number of elements in A)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">incl(A, elem)</span></tt></td><td>same as <tt class="docutils literal"><span class="pre">A = A + {elem}</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">excl(A, elem)</span></tt></td><td>same as <tt class="docutils literal"><span class="pre">A = A - {elem}</span></tt></td></tr>
</table>
<h3><a class="toc-backref" id="集合类型-bit-fields" href="#集合类型-bit-fields">Bit fields</a></h3><p>Sets are often used to define a type for the <em>flags</em> of a procedure. This is a cleaner (and type safe) solution than defining integer constants that have to be <tt class="docutils literal"><span class="pre">or</span></tt>'ed together.</p>
<p>Enum, sets and casting can be used together as in:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MyFlag</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">size</span><span class="Punctuation">:</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">A</span>
    <span class="Identifier">B</span>
    <span class="Identifier">C</span>
    <span class="Identifier">D</span>
  <span class="Identifier">MyFlags</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">MyFlag</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">MyFlags</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">cint</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">MyFlags</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">MyFlags</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">0</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">D</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">8</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">C</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">5</span>
<span class="Identifier">assert</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">{</span><span class="Punctuation">}</span>
<span class="Identifier">assert</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="DecNumber">7</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span><span class="Punctuation">,</span> <span class="Identifier">C</span><span class="Punctuation">}</span></pre><p>Note how the set turns enum values into powers of 2.</p>
<p>If using enums and sets with C, use distinct cint.</p>
<p>For interoperability with C see also the <a class="reference external" href="#implementation-specific-pragmas-bitsize-pragma">bitsize pragma</a>. </p>

<h2><a class="toc-backref" id="类型-引用和指针类型" href="#类型-引用和指针类型">引用和指针类型</a></h2><p>引用（类似于其他编程语言中的指针）是引入多对一关系的一种方式。 这意味着不同的引用可以指向并修改内存中的相同位置（也称为 <tt class="docutils literal"><span class="pre">别名</span></tt>:idx:)。</p>
<p>Nim区分 <span id="追踪_1">追踪</span>和 <span id="未追踪_1">未追踪</span> 引用。 未追踪引用也叫 <em>指针</em> 。 追踪引用指向垃圾回收堆中的对象，未追踪引用指向手动分配对象或内存中其它位置的对象。 因此，未追踪引用是 <em>不安全</em> 的。 然而，对于某些低级操作（访问硬件），未追踪引用是不可避免的。</p>
<p>使用 <strong>ref</strong> 关键字声明追踪引用，使用 <strong>ptr</strong> 关键字声明未追踪引用。 通常，`ptr T` 可以隐式转换为 <tt class="docutils literal"><span class="pre">pointer</span></tt> 类型。</p>
<p>空的下标 <tt class="docutils literal"><span class="pre">[]</span></tt> 表示法可以用来取代引用， <tt class="docutils literal"><span class="pre">addr</span></tt> 程序返回一个对象的地址。 地址始终是未经过引用的参考。 因此， <tt class="docutils literal"><span class="pre">addr</span></tt> 的使用是 <em>不安全的</em> 功能。</p>
<p><tt class="docutils literal"><span class="pre">.</span></tt> （访问元组和对象字段运算符）和 <tt class="docutils literal"><span class="pre">[]</span></tt> （数组/字符串/序列索引运算符）运算符对引用类型执行隐式解引用操作：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">var</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="DecNumber">9</span>
<span class="Comment"># 不必写n[].data; 实际上 n[].data是不推荐的！</span></pre><p>还对过程调用的第一个参数执行自动解引用。 但是目前这个功能只能通过 <tt class="docutils literal"><span class="pre">{.experimental：&quot;implicitDeref&quot;.}</span></tt> 来启用：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;implicitDeref&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">depth</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">NodeObj</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">depth</span>
<span class="Comment"># 也不必写n[].depth</span></pre><p>为了简化结构类型检查，递归元组无效：</p>
<pre class="listing"><span class="Comment"># 无效递归</span>
<span class="Keyword">type</span> <span class="Identifier">MyTuple</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">MyTuple</span><span class="Punctuation">]</span></pre><p>同样， <tt class="docutils literal"><span class="pre">T = ref T</span></tt> 是无效类型。</p>
<p>作为语法扩展 <tt class="docutils literal"><span class="pre">object</span></tt> 类型，如果在类型部分中通过 <tt class="docutils literal"><span class="pre">ref object</span></tt> 或 <tt class="docutils literal"><span class="pre">ptr object</span></tt> 符号声明，则可以是匿名的。 如果对象只应获取引用语义，则此功能非常有用：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>要分配新的追踪对象，必须使用内置过程 <tt class="docutils literal"><span class="pre">new</span></tt> 。 为了处理未追踪的内存，可以使用过程 <tt class="docutils literal"><span class="pre">alloc</span></tt> ， <tt class="docutils literal"><span class="pre">dealloc</span></tt> 和 <tt class="docutils literal"><span class="pre">realloc</span></tt> 。 系统模块的文档包含更多信息。</p>
<p>Nil ---</p>
<p>如果引用指向 <em>nothing</em> ，则它具有值 <tt class="docutils literal"><span class="pre">nil</span></tt> 。 <tt class="docutils literal"><span class="pre">nil</span></tt> 也是所有 <tt class="docutils literal"><span class="pre">ref</span></tt> 和 <tt class="docutils literal"><span class="pre">ptr</span></tt> 类型的默认值。 解除引用 <tt class="docutils literal"><span class="pre">nil</span></tt> 是一个不可恢复的致命运行时错误。 解除引用操作 <tt class="docutils literal"><span class="pre">p []</span></tt> 意味着 <tt class="docutils literal"><span class="pre">p</span></tt> 不是nil。 这可以通过实现来利用，以优化代码，如：</p>
<pre class="listing"><span class="Identifier">p</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">field</span> <span class="Operator">=</span> <span class="DecNumber">3</span>
<span class="Keyword">if</span> <span class="Identifier">p</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
  <span class="Comment"># 如果p为nil，``p []`` 会导致崩溃，</span>
  <span class="Comment"># 所以我们知道 ``p`` 总不是nil。</span>
  <span class="Identifier">action</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>Into:</p>
<pre class="listing"><span class="Identifier">p</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">field</span> <span class="Operator">=</span> <span class="DecNumber">3</span>
<span class="Identifier">action</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p><em>注意</em> ：这与用于解引用NULL指针的C的“未定义行为”不具有可比性。</p>

<h2><a class="toc-backref" id="类型-将gc内存和-ptr-混用" href="#类型-将gc内存和-ptr-混用">将GC内存和 <tt class="docutils literal"><span class="pre">ptr</span></tt> 混用</a></h2><p>如果未追踪对象包含追踪对象（如追踪引用，字符串或序列），则需要特别小心：为了正确释放所有内容，必须在手动释放未追踪内存之前调用内置过程 <tt class="docutils literal"><span class="pre">GCunref</span></tt> ：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Data</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">]</span>

<span class="Comment"># 为堆上的Data分配内存：</span>
<span class="Keyword">var</span> <span class="Identifier">d</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Keyword">ptr</span> <span class="Identifier">Data</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">alloc0</span><span class="Punctuation">(</span><span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">Data</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Comment"># 在垃圾收集堆上创建一个新字符串：</span>
<span class="Identifier">d</span><span class="Operator">.</span><span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span>

<span class="Comment"># 告诉GC不再需要该字符串：</span>
<span class="Identifier">GCunref</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Operator">.</span><span class="Identifier">s</span><span class="Punctuation">)</span>

<span class="Comment"># 释放内存:</span>
<span class="Identifier">dealloc</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Punctuation">)</span></pre><p>没有 <tt class="docutils literal"><span class="pre">GCunref</span></tt> 调用，为 <tt class="docutils literal"><span class="pre">d.s</span></tt> 字符串分配的内存永远不会被释放。 该示例还演示了低级编程的两个重要特性： <tt class="docutils literal"><span class="pre">sizeof</span></tt> proc以字节为单位返回类型或值的大小。 <tt class="docutils literal"><span class="pre">cast</span></tt> 运算符可以绕过类型系统：编译器被强制处理``alloc0``调用的结果（返回一个无类型的指针），就好像它是 <tt class="docutils literal"><span class="pre">ptr Data</span></tt> 类型。 只有在不可避免的情况下才能进行强转：它会破坏类型安全性并且错误可能导致隐蔽的崩溃。</p>
<p><strong>注意</strong>: 该示例仅起作用，因为内存初始化为零（ <tt class="docutils literal"><span class="pre">alloc0</span></tt> 而不是 <tt class="docutils literal"><span class="pre">alloc</span></tt> 执行此操作）： <tt class="docutils literal"><span class="pre">d.s</span></tt> 因此初始化为二进制零，字符串赋值可以处理。 在将垃圾收集数据与非托管内存混合时，需要知道这样的低级细节。</p>

<h2><a class="toc-backref" id="类型-not-nil注解" href="#类型-not-nil注解">Not nil注解</a></h2><p><tt class="docutils literal"><span class="pre">nil</span></tt> 是有效值的所有类型都可以注释为使用 <tt class="docutils literal"><span class="pre">not nil</span></tt> 注释将 <tt class="docutils literal"><span class="pre">nil</span></tt> 排除：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">PObject</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">TObj</span> <span class="Keyword">not</span> <span class="Keyword">nil</span>
  <span class="Identifier">TProc</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Keyword">not</span> <span class="Keyword">nil</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PObject</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;not nil&quot;</span>

<span class="Comment"># 编译器捕获:</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Keyword">nil</span><span class="Punctuation">)</span>

<span class="Comment"># 和这个:</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PObject</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>编译器确保每个代码路径初始化包含非空指针的变量。此分析的细节仍在此处指定。</p>

<h2><a class="toc-backref" id="类型-过程类型" href="#类型-过程类型">过程类型</a></h2><p>过程类型在内部是指向过程的指针。 <tt class="docutils literal"><span class="pre">nil</span></tt> 是过程类型变量的允许值。 Nim使用过程类型来实现 <span id="函数式_1">函数式</span> 编程技术。</p>
<p>Examples:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">printItem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Operator">...</span>

<span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">printItem</span><span class="Punctuation">)</span>  <span class="Comment"># 无法编译，因为调用约定不同</span></pre><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">OnMouseMove</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">onMouseMove</span><span class="Punctuation">(</span><span class="Identifier">mouseX</span><span class="Punctuation">,</span> <span class="Identifier">mouseY</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 有默认的调用约定</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;x: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">mouseX</span><span class="Punctuation">,</span> <span class="StringLit">&quot; y: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">mouseY</span>

<span class="Keyword">proc</span> <span class="Identifier">setOnMouseMove</span><span class="Punctuation">(</span><span class="Identifier">mouseMoveEvent</span><span class="Punctuation">:</span> <span class="Identifier">OnMouseMove</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Comment"># 可以, 'onMouseMove'有默认的调用约定，它是兼容的</span>
<span class="Comment"># 到 'closure':</span>
<span class="Identifier">setOnMouseMove</span><span class="Punctuation">(</span><span class="Identifier">onMouseMove</span><span class="Punctuation">)</span></pre><p>过程类型的一个微妙问题是过程的调用约定会影响类型兼容性：过程类型只有在具有相同的调用约定时才是兼容的。 作为一个特殊的扩展，调用约定 <tt class="docutils literal"><span class="pre">nimcall</span></tt> 的过程可以传递给一个参数，该参数需要调用约定 <tt class="docutils literal"><span class="pre">closure</span></tt> 的proc。</p>
<p>Nim支持这些 <span id="调用约定_1">调用约定</span>：</p>
<p><span id="nimcall_1">nimcall</span> 是用于Nim <strong>proc</strong> 的默认约定。它与 <tt class="docutils literal"><span class="pre">fastcall</span></tt> 相同，但仅适用于支持 <tt class="docutils literal"><span class="pre">fastcall</span></tt> 的C编译器。</p>
<dl class="docutils"><dt><span id="closure_1">closure</span></dt>
<dd>是缺少任何pragma注释的 <strong>过程类型</strong> 的默认调用约定。 它表示该过程具有隐藏的隐式形参（*环境*）。 具有调用约定 <tt class="docutils literal"><span class="pre">closure</span></tt> 的过程变量占用两个机器字：一个用于proc指针，另一个用于指向隐式传递环境的指针。</dd>
<dt><span id="stdcall_1">stdcall</span></dt>
<dd>这是微软指定的stdcall约定。生成的C过程使用 <tt class="docutils literal"><span class="pre">__stdcall</span></tt> 关键字声明。</dd>
<dt><span id="cdecl_1">cdecl</span></dt>
<dd>cdecl约定意味着过程应使用与C编译器相同的约定。 在Windows下，生成的C过程使用 <tt class="docutils literal"><span class="pre">__cdecl</span></tt> 关键字声明。</dd>
<dt><span id="safecall_1">safecall</span></dt>
<dd>这是微软指定的safecall约定。 生成的C过程使用 <tt class="docutils literal"><span class="pre">__safecall</span></tt> 关键字声明。 <em>安全</em> 一词指的是所有硬件寄存器都应被推送到硬件堆栈。</dd>
<dt><span id="inline_1">inline</span></dt>
<dd>内联约定意味着调用者不应该调用该过程，而是直接内联其代码。 请注意，Nim不是内联的，而是将其留给C编译器;它生成 <tt class="docutils literal"><span class="pre">__inline</span></tt> 程序。 这只是编译器的一个提示：编译器可能完全忽略它，它可能内联没有标记为 <tt class="docutils literal"><span class="pre">inline</span></tt> 的过程。</dd>
<dt><span id="fastcall_1">fastcall</span></dt>
<dd>Fastcall对不同的C编译器意味着不同的东西，不论C的 <tt class="docutils literal"><span class="pre">__fastcall</span></tt> 意义是什么。</dd>
<dt><span id="syscall_1">syscall</span></dt>
<dd>系统调用约定与C中的 <tt class="docutils literal"><span class="pre">__syscall</span></tt> 相同，用于中断。</dd>
<dt><span id="noconv_1">noconv</span></dt>
<dd>生成的C代码将没有任何显式调用约定，因此使用C编译器的默认调用约定。 这是必需的，因为Nim对程序的默认调用约定是 <tt class="docutils literal"><span class="pre">fastcall</span></tt> 来提高速度。</dd>
</dl>
<p>大多数调用约定仅适用于Windows 32位平台。</p>
<p>默认调用约定是 <tt class="docutils literal"><span class="pre">nimcall</span></tt> ，除非它是内部proc（proc中的proc）。 对于内部过程，无论是否访问其环境，都会执行分析。 如果它这样做，它有调用约定 <tt class="docutils literal"><span class="pre">closure</span></tt> ，否则它有调用约定 <tt class="docutils literal"><span class="pre">nimcall</span></tt> 。</p>

<h2><a class="toc-backref" id="类型-distinct类型" href="#类型-distinct类型">Distinct类型</a></h2><p><tt class="docutils literal"><span class="pre">distinct</span></tt> 类型是从 <span id="基类型_1">基类型</span>  派生的新类型与它的基类型不兼容。 特别是，它是一种不同类型的基本属性，它 <em>并不</em> 意味着它和基本类型之间的子类型关系。 允许从不同类型到其基本类型的显式类型转换，反之亦然。另请参阅 <tt class="docutils literal"><span class="pre">distinctBase</span></tt> 以获得逆操作。</p>
<p>如果基类型是序数类型，则不同类型是序数类型。</p>

<h3><a class="toc-backref" id="distinct类型-模拟货币" href="#distinct类型-模拟货币">模拟货币</a></h3><p>可以使用不同的类型来模拟不同的物理 <tt class="docutils literal"><span class="pre">单位</span></tt>:idx: 比如具有数字基类型。 以下示例模拟货币。</p>
<p>货币计算中不应混合不同的货币。 不同类型是模拟不同货币的完美工具：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Dollar</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>
  <span class="Identifier">Euro</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>

<span class="Keyword">var</span>
  <span class="Identifier">d</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span>
  <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Euro</span>

<span class="Identifier">echo</span> <span class="Identifier">d</span> <span class="Operator">+</span> <span class="DecNumber">12</span>
<span class="Comment"># 错误：无法添加没有单位的数字和 ``美元``</span></pre><p><tt class="docutils literal"><span class="pre">d + 12.Dollar</span></tt> 也不允许，因为 <tt class="docutils literal"><span class="pre">+</span></tt> 为 <tt class="docutils literal"><span class="pre">int</span></tt> (在其它类型之中)定义, 而没有为 <tt class="docutils literal"><span class="pre">Dollar</span></tt> 定义。 因此需要定义美元的 <tt class="docutils literal"><span class="pre">+</span></tt> ：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Dollar</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>将一美元乘以一美元是没有意义的，但可以不带单位相乘；对除法同样成立：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Dollar</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="Identifier">y</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Dollar</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">*</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span> <span class="Operator">...</span></pre><p>这很快变得乏味。 实现是琐碎的，编译器不应该生成所有这些代码只是为了以后优化它 - 毕竟美元 <tt class="docutils literal"><span class="pre">+</span></tt> 应该生成与整型 <tt class="docutils literal"><span class="pre">+</span></tt> 相同的二进制代码。 编译指示 <span id="borrow_1">borrow</span> 旨在解决这个问题；原则上它会生成以上的琐碎实现：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p><tt class="docutils literal"><span class="pre">borrow</span></tt> 编译指示使编译器使用与处理distinct类型的基类型的proc相同的实现，因此不会生成任何代码。</p>
<p>但似乎所有这些样板代码都需要为 <tt class="docutils literal"><span class="pre">欧元</span></tt> 货币重复。这可以通过 <a class="reference external" href="#模板">模板</a> 解决。</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">additive</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  
  <span class="Comment"># 一元运算符:</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">multiplicative</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">base</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">mod</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">comparable</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&lt;</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&lt;=</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">defineCurrency</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">base</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">type</span>
    <span class="Identifier">typ</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">base</span>
  <span class="Identifier">additive</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">)</span>
  <span class="Identifier">multiplicative</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">base</span><span class="Punctuation">)</span>
  <span class="Identifier">comparable</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">)</span>

<span class="Identifier">defineCurrency</span><span class="Punctuation">(</span><span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Identifier">defineCurrency</span><span class="Punctuation">(</span><span class="Identifier">Euro</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span></pre><p>借用编译指示还可用于注释不同类型以允许某些内置操作被提升：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Foo</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
  
  <span class="Identifier">Bar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Punctuation">:</span> <span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">Foo</span>

<span class="Keyword">var</span> <span class="Identifier">bb</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Bar</span>
<span class="Identifier">new</span> <span class="Identifier">bb</span>
<span class="Comment"># 字段访问有效</span>
<span class="Identifier">bb</span><span class="Operator">.</span><span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">90</span>
<span class="Identifier">bb</span><span class="Operator">.</span><span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span></pre><p>目前只有点访问符可以用这种方式借用。</p>

<h3><a class="toc-backref" id="distinct类型-避免sql注入攻击" href="#distinct类型-避免sql注入攻击">避免SQL注入攻击</a></h3><p>从Nim传递到SQL数据库的SQL语句可能被模拟为字符串。 但是，使用字符串模板并填充值很容易受到 <span id="sql注入攻击_1">SQL注入攻击</span>:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">strutils</span>

<span class="Keyword">proc</span> <span class="Identifier">query</span><span class="Punctuation">(</span><span class="Identifier">db</span><span class="Punctuation">:</span> <span class="Identifier">DbHandle</span><span class="Punctuation">,</span> <span class="Identifier">statement</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span>
  <span class="Identifier">username</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Identifier">db</span><span class="Operator">.</span><span class="Identifier">query</span><span class="Punctuation">(</span><span class="StringLit">&quot;SELECT FROM users WHERE name = '$1'&quot;</span> <span class="Operator">%</span> <span class="Identifier">username</span><span class="Punctuation">)</span>
<span class="Comment"># 可怕的安全漏洞，但编译没有问题</span></pre><p>通过将包含SQL的字符串与不包含SQL的字符串区分开来可以避免这种情况。 不同类型提供了一种引入与 <tt class="docutils literal"><span class="pre">string</span></tt> 不兼容的新字符串类型 <tt class="docutils literal"><span class="pre">SQL</span></tt> 的方法：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">SQL</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">string</span>

<span class="Keyword">proc</span> <span class="Identifier">query</span><span class="Punctuation">(</span><span class="Identifier">db</span><span class="Punctuation">:</span> <span class="Identifier">DbHandle</span><span class="Punctuation">,</span> <span class="Identifier">statement</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span>
  <span class="Identifier">username</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Identifier">db</span><span class="Operator">.</span><span class="Identifier">query</span><span class="Punctuation">(</span><span class="StringLit">&quot;SELECT FROM users WHERE name = '$1'&quot;</span> <span class="Operator">%</span> <span class="Identifier">username</span><span class="Punctuation">)</span>
<span class="Comment"># 静态错误：`query` 需要一个SQL字符串！</span></pre><p>它是抽象类型的基本属性，它们 <em>并不</em> 意味着抽象类型与其基类型之间的子类型关系。 允许从 <tt class="docutils literal"><span class="pre">string</span></tt> 到 <tt class="docutils literal"><span class="pre">SQL</span></tt> 的显式类型转换：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">strutils</span><span class="Punctuation">,</span> <span class="Identifier">sequtils</span>

<span class="Keyword">proc</span> <span class="Identifier">properQuote</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span> <span class="Operator">=</span>
  <span class="Comment"># 为SQL语句正确引用字符串</span>
  <span class="Keyword">return</span> <span class="Identifier">SQL</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">%</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">frmt</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span><span class="Punctuation">,</span> <span class="Identifier">values</span><span class="Punctuation">:</span> <span class="Identifier">openarray</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span> <span class="Operator">=</span>
  <span class="Comment"># 引用每个论点：</span>
  <span class="Keyword">let</span> <span class="Identifier">v</span> <span class="Operator">=</span> <span class="Identifier">values</span><span class="Operator">.</span><span class="Identifier">mapIt</span><span class="Punctuation">(</span><span class="Identifier">SQL</span><span class="Punctuation">,</span> <span class="Identifier">properQuote</span><span class="Punctuation">(</span><span class="Identifier">it</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Comment"># we need a temporary type for the type conversion :-(</span>
  <span class="Keyword">type</span> <span class="Identifier">StrSeq</span> <span class="Operator">=</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span>
  <span class="Comment"># 调用 strutils.`%`:</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">SQL</span><span class="Punctuation">(</span><span class="Identifier">string</span><span class="Punctuation">(</span><span class="Identifier">frmt</span><span class="Punctuation">)</span> <span class="Operator">%</span> <span class="Identifier">StrSeq</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Identifier">db</span><span class="Operator">.</span><span class="Identifier">query</span><span class="Punctuation">(</span><span class="StringLit">&quot;SELECT FROM users WHERE name = '$1'&quot;</span><span class="Operator">.</span><span class="Identifier">SQL</span> <span class="Operator">%</span> <span class="Punctuation">[</span><span class="Identifier">username</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>现在我们有针对SQL注入攻击的编译时检查。 因为 <tt class="docutils literal"><span class="pre">&quot;&quot;.SQL</span></tt> 转换为 <tt class="docutils literal"><span class="pre">SQL(&quot;&quot;)</span></tt> 不需要新的语法来获得漂亮的 <tt class="docutils literal"><span class="pre">SQL</span></tt> 字符串文字。 假设的 <tt class="docutils literal"><span class="pre">SQL</span></tt> 类型实际上存在于库中，作为 <a class="reference external" href="db_sqlite.html">db_sqlite</a> 等模块的 <a class="reference external" href="db_sqlite.html＃TSqlQuery">TSqlQuery类型</a> 。</p>

<h2><a class="toc-backref" id="类型-自动类型" href="#类型-自动类型">自动类型</a></h2><p><tt class="docutils literal"><span class="pre">auto</span></tt> 类型只能用于返回类型和参数。 对于返回类型，它会使编译器从过程体中推断出类型：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">returnsInt</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">auto</span> <span class="Operator">=</span> <span class="DecNumber">1984</span></pre><p>对于形参，它现在是创建隐式的泛型例程：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">auto</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre><p>同:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">[</span><span class="Identifier">T1</span><span class="Punctuation">,</span> <span class="Identifier">T2</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">T1</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">T2</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre><p>然而，该语言的更高版本可能会将其更改为从方法体 <tt class="docutils literal"><span class="pre">推断形参类型</span></tt> 。 然后上面的 <tt class="docutils literal"><span class="pre">foo</span></tt> 将被拒绝，因为形参的类型不能从空的 <tt class="docutils literal"><span class="pre">discard</span></tt> 语句中推断出来。</p>

<h1><a class="toc-backref" id="类型关系" href="#类型关系">类型关系</a></h1><p>以下部分定义了描述编译器类型检查所需类型的几个关系。</p>

<h2><a class="toc-backref" id="类型关系-类型相等性" href="#类型关系-类型相等性">类型相等性</a></h2><p>Nim对大多数类型使用结构类型等价。 仅对于对象，枚举和不同类型使用名称等价。 <em>伪代码中</em> 的以下算法确定类型相等：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">,</span>
                   <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">HashSet</span><span class="Punctuation">[</span><span class="Punctuation">(</span><span class="Identifier">PType</span><span class="Punctuation">,</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span><span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Keyword">in</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
    <span class="Keyword">of</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">intXX</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">floatXX</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">cstring</span><span class="Punctuation">,</span> <span class="Identifier">pointer</span><span class="Punctuation">,</span>
        <span class="Identifier">bool</span><span class="Punctuation">,</span> <span class="Keyword">nil</span><span class="Punctuation">,</span> <span class="Identifier">void</span><span class="Punctuation">:</span>
      <span class="Comment"># 叶类型: 类型等价; 不做更多检查</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">ref</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">,</span> <span class="Keyword">var</span><span class="Punctuation">,</span> <span class="Identifier">set</span><span class="Punctuation">,</span> <span class="Identifier">seq</span><span class="Punctuation">,</span> <span class="Identifier">openarray</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">range</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
        <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeA</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeA</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeB</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeB</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">array</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Keyword">tuple</span><span class="Punctuation">:</span>
      <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Punctuation">:</span>
        <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span>
          <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">false</span>
        <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">object</span><span class="Punctuation">,</span> <span class="Keyword">enum</span><span class="Punctuation">,</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span>
    <span class="Keyword">of</span> <span class="Keyword">proc</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">callingConvention</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">callingConvention</span>

<span class="Keyword">proc</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">HashSet</span><span class="Punctuation">[</span><span class="Punctuation">(</span><span class="Identifier">PType</span><span class="Punctuation">,</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="Punctuation">}</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span></pre><p>由于类型可以是有环图，因此上述算法需要辅助集合 <tt class="docutils literal"><span class="pre">s</span></tt> 来检测这种情况</p>

<h2><a class="toc-backref" id="类型关系-类型相等与类型区分" href="#类型关系-类型相等与类型区分">类型相等与类型区分</a></h2><p>以下算法（伪代码）确定两种类型是否相等而不是 <tt class="docutils literal"><span class="pre">不同</span></tt> 类型。 为简洁起见，省略了辅助集 <tt class="docutils literal"><span class="pre">s</span></tt> 的循环检查：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
    <span class="Keyword">of</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">intXX</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">floatXX</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">cstring</span><span class="Punctuation">,</span> <span class="Identifier">pointer</span><span class="Punctuation">,</span>
        <span class="Identifier">bool</span><span class="Punctuation">,</span> <span class="Keyword">nil</span><span class="Punctuation">,</span> <span class="Identifier">void</span><span class="Punctuation">:</span>
      <span class="Comment"># leaf type: kinds identical; nothing more to check</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">ref</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">,</span> <span class="Keyword">var</span><span class="Punctuation">,</span> <span class="Identifier">set</span><span class="Punctuation">,</span> <span class="Identifier">seq</span><span class="Punctuation">,</span> <span class="Identifier">openarray</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">range</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
        <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeA</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeA</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeB</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeB</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">array</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Keyword">tuple</span><span class="Punctuation">:</span>
      <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Punctuation">:</span>
        <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span>
          <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">false</span>
        <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Keyword">object</span><span class="Punctuation">,</span> <span class="Keyword">enum</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span>
    <span class="Keyword">of</span> <span class="Keyword">proc</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">callingConvention</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">callingConvention</span>
  <span class="Keyword">elif</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">elif</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="类型关系-子类型关系" href="#类型关系-子类型关系">子类型关系</a></h2><p>如果对象 <tt class="docutils literal"><span class="pre">a</span></tt> 继承自 <tt class="docutils literal"><span class="pre">b</span></tt>, <tt class="docutils literal"><span class="pre">a</span></tt> 是 <tt class="docutils literal"><span class="pre">b</span></tt> 的类型。 这种了类型关系扩展到 <tt class="docutils literal"><span class="pre">var</span></tt>, <tt class="docutils literal"><span class="pre">ref</span></tt>, <tt class="docutils literal"><span class="pre">ptr</span></tt> :</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
    <span class="Keyword">of</span> <span class="Keyword">object</span><span class="Punctuation">:</span>
      <span class="Keyword">var</span> <span class="Identifier">aa</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span>
      <span class="Keyword">while</span> <span class="Identifier">aa</span> <span class="Operator">!=</span> <span class="Keyword">nil</span> <span class="Keyword">and</span> <span class="Identifier">aa</span> <span class="Operator">!=</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">aa</span> <span class="Operator">=</span> <span class="Identifier">aa</span><span class="Operator">.</span><span class="Identifier">baseType</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">aa</span> <span class="Operator">==</span> <span class="Identifier">b</span>
    <span class="Keyword">of</span> <span class="Keyword">var</span><span class="Punctuation">,</span> <span class="Keyword">ref</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="类型关系-可转换关系" href="#类型关系-可转换关系">可转换关系</a></h2><p>类型 <tt class="docutils literal"><span class="pre">a</span></tt> 可 <strong>隐式</strong> 转换到类型 <tt class="docutils literal"><span class="pre">b</span></tt> 如果下列算法返回真：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">isImplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Keyword">or</span> <span class="Identifier">isCovariant</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
  <span class="Keyword">of</span> <span class="Identifier">int</span><span class="Punctuation">:</span>     <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int8</span><span class="Punctuation">,</span> <span class="Identifier">int16</span><span class="Punctuation">,</span> <span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">uint</span><span class="Punctuation">,</span> <span class="Identifier">uint8</span><span class="Punctuation">,</span> <span class="Identifier">uint16</span><span class="Punctuation">,</span>
                             <span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">int8</span><span class="Punctuation">:</span>    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int16</span><span class="Punctuation">,</span> <span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">int16</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">int32</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint</span><span class="Punctuation">:</span>    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint8</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint16</span><span class="Punctuation">,</span> <span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint16</span><span class="Punctuation">:</span>  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint32</span><span class="Punctuation">:</span>  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">float</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">float32</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float64</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">float64</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">seq</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">openArray</span> <span class="Keyword">and</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
  <span class="Keyword">of</span> <span class="Identifier">array</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">openArray</span> <span class="Keyword">and</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
    <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span> <span class="Operator">==</span> <span class="Identifier">char</span> <span class="Keyword">and</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Operator">.</span><span class="Identifier">rangeA</span> <span class="Operator">==</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">cstring</span>
  <span class="Keyword">of</span> <span class="Identifier">cstring</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">pointer</span>
  <span class="Keyword">of</span> <span class="Identifier">string</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">cstring</span></pre><p>Nim为 <tt class="docutils literal"><span class="pre">范围</span></tt> 类型构造函数执行了隐式转换。</p>
<p>设 <tt class="docutils literal"><span class="pre">a0</span></tt>, <tt class="docutils literal"><span class="pre">b0</span></tt> 为类型 <tt class="docutils literal"><span class="pre">T</span></tt>.</p>
<p>设 <tt class="docutils literal"><span class="pre">A = range[a0..b0]</span></tt> 为实参类型, <tt class="docutils literal"><span class="pre">F</span></tt> 正式的形参类型。 从 <tt class="docutils literal"><span class="pre">A</span></tt> 到 <tt class="docutils literal"><span class="pre">F</span></tt> 存在隐式转换，如果 <tt class="docutils literal"><span class="pre">a0 &gt;= low(F) 且 b0 &lt;= high(F)</span></tt> 且 <tt class="docutils literal"><span class="pre">T</span></tt> 各 <tt class="docutils literal"><span class="pre">F</span></tt> 是有符号或无符号整型。</p>
<p>如果以下算法返回true，则类型 <tt class="docutils literal"><span class="pre">a</span></tt>  可 <strong>显式</strong> 转换为类型 <tt class="docutils literal"><span class="pre">b</span></tt> ：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">isIntegralType</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">isOrdinal</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">)</span> <span class="Keyword">or</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float64</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">isExplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Keyword">if</span> <span class="Identifier">isImplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">isIntegralType</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="Identifier">isIntegralType</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Keyword">or</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span></pre><p>可转换关系可以通过用户定义的类型 <span id="converter_1">converter</span> 来放宽。</p>
<pre class="listing"><span class="Keyword">converter</span> <span class="Identifier">toInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">chr</span><span class="Punctuation">:</span> <span class="Identifier">char</span> <span class="Operator">=</span> <span class="CharLit">'a'</span>

<span class="Comment"># 隐式转换发生在这里</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">chr</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># =&gt; 97</span>
<span class="Comment"># 你也可以使用显式转换</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">chr</span><span class="Operator">.</span><span class="Identifier">toInt</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># =&gt; 97</span></pre><p>如果 <tt class="docutils literal"><span class="pre">a</span></tt> 是左值并且 <tt class="docutils literal"><span class="pre">typeEqualsOrDistinct(T, type(a))</span></tt> 成立， 类型转换 <tt class="docutils literal"><span class="pre">T(a)</span></tt> 也是左值。</p>

<h2><a class="toc-backref" id="类型关系-赋值兼容性" href="#类型关系-赋值兼容性">赋值兼容性</a></h2><p>表达式 <tt class="docutils literal"><span class="pre">b</span></tt> 可以赋给表达式 <tt class="docutils literal"><span class="pre">a</span></tt> 如果 <tt class="docutils literal"><span class="pre">a</span></tt> 是 <tt class="docutils literal"><span class="pre">左值</span></tt> 并且 <tt class="docutils literal"><span class="pre">isImplicitlyConvertible(b.typ, a.typ)</span></tt> 成立。</p>

<h1><a class="toc-backref" id="重载解析" href="#重载解析">重载解析</a></h1><p>在调用 <tt class="docutils literal"><span class="pre">p(args)</span></tt> 中选择匹配最佳的例程 <tt class="docutils literal"><span class="pre">p</span></tt> 。 如果多个例程同样匹配，则在语义分析期间报告歧义。</p>
<p>args中的每个arg都需要匹配。参数可以匹配的方式有多种不同的类别。 设 <tt class="docutils literal"><span class="pre">f</span></tt> 是形式参数的类型， <tt class="docutils literal"><span class="pre">a</span></tt> 是参数的类型。</p>
<ol class="simple"><li>准确匹配: <tt class="docutils literal"><span class="pre">a</span></tt> 和 <tt class="docutils literal"><span class="pre">f</span></tt> 是相同类型。</li>
<li>字面匹配: <tt class="docutils literal"><span class="pre">a</span></tt> is an integer literal of value <tt class="docutils literal"><span class="pre">v</span></tt> and <tt class="docutils literal"><span class="pre">f</span></tt> is a signed or unsigned integer type and <tt class="docutils literal"><span class="pre">v</span></tt> is in <tt class="docutils literal"><span class="pre">f</span></tt>'s range. Or:  <tt class="docutils literal"><span class="pre">a</span></tt> is a floating point literal of value <tt class="docutils literal"><span class="pre">v</span></tt> and <tt class="docutils literal"><span class="pre">f</span></tt> is a floating point type and <tt class="docutils literal"><span class="pre">v</span></tt> is in <tt class="docutils literal"><span class="pre">f</span></tt>'s range.</li>
<li>泛型匹配: <tt class="docutils literal"><span class="pre">f</span></tt> 是泛型类型且 <tt class="docutils literal"><span class="pre">a</span></tt> 匹配, 例如 <tt class="docutils literal"><span class="pre">a</span></tt> 是 <tt class="docutils literal"><span class="pre">int</span></tt> 且 <tt class="docutils literal"><span class="pre">f</span></tt> 是泛型限制 (受限) 形参类型 (像 <tt class="docutils literal"><span class="pre">[T]</span></tt> 或 <tt class="docutils literal"><span class="pre">[T: int|char]</span></tt>.</li>
<li>子范围或子类型匹配： <tt class="docutils literal"><span class="pre">a</span></tt> is a <tt class="docutils literal"><span class="pre">range[T]</span></tt> and <tt class="docutils literal"><span class="pre">T</span></tt> matches <tt class="docutils literal"><span class="pre">f</span></tt> exactly. Or: <tt class="docutils literal"><span class="pre">a</span></tt> is a subtype of <tt class="docutils literal"><span class="pre">f</span></tt>.</li>
<li>整数转换匹配: <tt class="docutils literal"><span class="pre">a</span></tt> 可转换为 <tt class="docutils literal"><span class="pre">f</span></tt> 且 <tt class="docutils literal"><span class="pre">f</span></tt> 和 <tt class="docutils literal"><span class="pre">a</span></tt> 是同样的整数或浮点类型。</li>
<li>转换匹配: <tt class="docutils literal"><span class="pre">a</span></tt> 可能通过用户定义的转换器转换为 <tt class="docutils literal"><span class="pre">f</span></tt> 。</li>
</ol>
<p>这些匹配类别具有优先级：完全匹配优于文字匹配，并且优于通用匹配等。 在下面的 <tt class="docutils literal"><span class="pre">count(p, m)</span></tt> 计算 <tt class="docutils literal"><span class="pre">m</span></tt> 匹配过程 <tt class="docutils literal"><span class="pre">p</span></tt> 的匹配数。</p>
<p>A routine <tt class="docutils literal"><span class="pre">p</span></tt> matches better than a routine <tt class="docutils literal"><span class="pre">q</span></tt> if the following algorithm returns true:<pre>
for each matching category m in [&quot;exact match&quot;, &quot;literal match&quot;,
                                &quot;generic match&quot;, &quot;subtype match&quot;,
                                &quot;integral match&quot;, &quot;conversion match&quot;]:
  if count(p, m) &gt; count(q, m): return true
  elif count(p, m) == count(q, m):
    discard &quot;continue with next category m&quot;
  else:
    return false
return &quot;ambiguous&quot;</pre>
</p>
<p>一些示例：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;int&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">takesInt</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;T&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int16</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;int16&quot;</span>

<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># &quot;int&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int32</span>
<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># &quot;T&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int16</span>
<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Comment"># &quot;int16&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">4</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">)</span> <span class="Comment"># &quot;T&quot;</span></pre><p>如果算法返回 &quot;歧义&quot; 则执行进一步消歧: 如果参数 <tt class="docutils literal"><span class="pre">a</span></tt> 通过子类型关系匹配 <tt class="docutils literal"><span class="pre">p</span></tt> 的参数类型 <tt class="docutils literal"><span class="pre">f</span></tt> 和 <tt class="docutils literal"><span class="pre">q</span></tt> 的 <tt class="docutils literal"><span class="pre">g</span></tt> ，则考虑继承深度：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">A</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
  <span class="Identifier">B</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">A</span>
  <span class="Identifier">C</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">B</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;A&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">B</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;B&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">C</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Comment"># not ambiguous, calls 'B', not 'A' since B is a subtype of A</span>
<span class="Comment"># but not vice versa:</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">pp</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">obj2</span><span class="Punctuation">:</span> <span class="Identifier">B</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;A B&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">pp</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">B</span><span class="Punctuation">,</span> <span class="Identifier">obj2</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;B A&quot;</span>

<span class="Comment"># but this is ambiguous:</span>
<span class="Identifier">pp</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">)</span></pre><p>同样，对于通用匹配，匹配的结果中首选最特化的泛型类型：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">gen</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Keyword">ref</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;ref ref T&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">gen</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;ref T&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">gen</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;T&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">int</span>
<span class="Identifier">gen</span><span class="Punctuation">(</span><span class="Identifier">ri</span><span class="Punctuation">)</span> <span class="Comment"># &quot;ref T&quot;</span></pre>
<h2><a class="toc-backref" id="重载解析-基于-var-t-的重载" href="#重载解析-基于-var-t-的重载">基于 'var T' 的重载</a></h2><p>如果形式参数 <tt class="docutils literal"><span class="pre">f</span></tt> 是除了普通类型检查外的 <tt class="docutils literal"><span class="pre">var T</span></tt> 类型， 则检查实参是否 <span id="左值_2">左值</span> 。 <tt class="docutils literal"><span class="pre">var T</span></tt> 比 <tt class="docutils literal"><span class="pre">T</span></tt> 更好地匹配。</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">sayHi</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Comment"># 匹配非var整型</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">x</span>
<span class="Keyword">proc</span> <span class="Identifier">sayHi</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Comment"># 匹配var整型</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">+</span> <span class="DecNumber">10</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">sayHello</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">m</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Comment"># 可改变的x</span>
  <span class="Identifier">echo</span> <span class="Identifier">sayHi</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 匹配sayHi的非var版本</span>
  <span class="Identifier">echo</span> <span class="Identifier">sayHi</span><span class="Punctuation">(</span><span class="Identifier">m</span><span class="Punctuation">)</span> <span class="Comment"># 匹配sayHi的var版本</span>

<span class="Identifier">sayHello</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Comment"># 3</span>
            <span class="Comment"># 13</span></pre>
<h2><a class="toc-backref" id="重载解析-无类型的延迟类型解析" href="#重载解析-无类型的延迟类型解析">无类型的延迟类型解析</a></h2><p><strong>注意</strong>: <span id="未解析_1">未解析</span> 表达式是为没有执行符号查找和类型检查的表达式。</p>
<p>由于未声明为 <tt class="docutils literal"><span class="pre">立即</span></tt> 的模板和宏参与重载分析，因此必须有一种方法将未解析的表达式传递给模板或宏。</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">rem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">rem</span> <span class="Identifier">unresolvedExpression</span><span class="Punctuation">(</span><span class="Identifier">undeclaredIdentifier</span><span class="Punctuation">)</span></pre><p><tt class="docutils literal"><span class="pre">untyped</span></tt> 类型的参数总是匹配任何参数（只要有任何参数传递给它）。</p>
<p>但是必须注意，因为其他重载可能触发参数的解析：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">rem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Identifier">rem</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Comment"># 未声明的标识符：'unresolvedExpression'</span>
<span class="Identifier">rem</span> <span class="Identifier">unresolvedExpression</span><span class="Punctuation">(</span><span class="Identifier">undeclaredIdentifier</span><span class="Punctuation">)</span></pre><p><tt class="docutils literal"><span class="pre">untyped</span></tt> 和 <tt class="docutils literal"><span class="pre">varargs [untyped]</span></tt> 是这种意义上唯一的惰性元类型，其他元类型 <tt class="docutils literal"><span class="pre">typed</span></tt> 和 <tt class="docutils literal"><span class="pre">typedesc</span></tt> 并不是惰性的。</p>

<h2><a class="toc-backref" id="重载解析-可变参数匹配" href="#重载解析-可变参数匹配">可变参数匹配</a></h2><p>见 <a class="reference external" href="#types-varargs">Varargs</a>.</p>

<h1><a class="toc-backref" id="语句和表达式" href="#语句和表达式">语句和表达式</a></h1><p>Nim使用通用语句/表达式范例：与表达式相比，语句不会产生值。 但是，有些表达式是语句。</p>
<p>语句分为 <span id="简单语句_1">简单语句</span> 和 <span id="复杂语句_1">复杂语句</span> 。 简单语句是不能包含像赋值，调用或者 <tt class="docutils literal"><span class="pre">return</span></tt> 的语句； 复杂语句可以包含其它语句。 为了避免 <span id="dangling-else问题_1">dangling else问题</span>, 复杂语句必须缩进。 细节可以在语法中找到。</p>

<h2><a class="toc-backref" id="语句和表达式-语句列表表达式" href="#语句和表达式-语句列表表达式">语句列表表达式</a></h2><p>语句也可以出现在类似于 <tt class="docutils literal"><span class="pre">(stmt1; stmt2; ...; ex)</span></tt> 的表达式上下文中。 语句也可以出现在表达式上下文中。 这叫做语句列表表达式或 <tt class="docutils literal"><span class="pre">(;)</span></tt> 。 <tt class="docutils literal"><span class="pre">(stmt1; stmt2; ...; ex)</span></tt> 的类型是 <tt class="docutils literal"><span class="pre">ex</span></tt> 的类型。 所有其他语句必须是 <tt class="docutils literal"><span class="pre">void</span></tt> 类型。 (可以用 <tt class="docutils literal"><span class="pre">discard</span></tt> 生成 <tt class="docutils literal"><span class="pre">void</span></tt> 类型。) <tt class="docutils literal"><span class="pre">(;)</span></tt> 不引入新作用域。</p>

<h2><a class="toc-backref" id="语句和表达式-discard表达式" href="#语句和表达式-discard表达式">Discard表达式</a></h2><p>示例:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Keyword">discard</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># 丢弃 `p` 的返回值</span></pre><p><tt class="docutils literal"><span class="pre">discard</span></tt> 语句评估其副作用的表达式，并丢弃表达式的结果。</p>
<p>在不使用discard语句的情况下忽略过程的返回值是一个静态错误。</p>
<p>如果使用 <span id="discardable_1">discardable</span> 编译指示声明了被调用的proc或iterator，则可以隐式忽略返回值：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">discardable</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># now valid</span></pre><p>空 <tt class="docutils literal"><span class="pre">discard</span></tt> 语句通常用作null语句:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">classify</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">of</span> <span class="Identifier">SymChars</span><span class="Punctuation">,</span> <span class="CharLit">'_'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;an identifier&quot;</span>
  <span class="Keyword">of</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;a number&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">discard</span></pre>
<h2><a class="toc-backref" id="语句和表达式-void上下文" href="#语句和表达式-void上下文">Void上下文</a></h2><p>在语句列表中，除最后一个表达式之外的每个表达式都需要具有类型 <tt class="docutils literal"><span class="pre">void</span></tt> 。 除了这个规则之外，对内置 <tt class="docutils literal"><span class="pre">result</span></tt> 符号的赋值也会触发后续表达式的强制 <tt class="docutils literal"><span class="pre">void</span></tt> 上下文：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">invalid</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;foo&quot;</span>
  <span class="StringLit">&quot;invalid&quot;</span>  <span class="Comment"># 错误: 'string' 类型值必须丢弃</span></pre><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">valid</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">317</span>
  <span class="StringLit">&quot;valid&quot;</span></pre>
<h2><a class="toc-backref" id="语句和表达式-var语句" href="#语句和表达式-var语句">Var语句</a></h2><p>Var语句声明新的局部变量和全局变量并初始化它们。 逗号分隔的变量列表可用于指定相同类型的变量：</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>如果给出初始值设定项，则可以省略该类型：该变量的类型与初始化表达式的类型相同。 如果没有初始化表达式，变量总是使用默认值初始化。 默认值取决于类型，并且在二进制中始终为零。</p>
<table border="1" class="docutils"><tr><th>类型</th><th>默认值</th></tr>
<tr><td>any integer type</td><td>0</td></tr>
<tr><td>any float</td><td>0.0</td></tr>
<tr><td>char</td><td>'\0'</td></tr>
<tr><td>bool</td><td>false</td></tr>
<tr><td>ref or pointer type</td><td>nil</td></tr>
<tr><td>procedural type</td><td>nil</td></tr>
<tr><td>sequence</td><td><tt class="docutils literal"><span class="pre">@[]</span></tt></td></tr>
<tr><td>string</td><td><tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt></td></tr>
<tr><td>tuple[x: A, y: B, ...]</td><td>(default(A), default(B), ...) (analogous for objects)</td></tr>
<tr><td>array[0..., T]</td><td>[default(T), ...]</td></tr>
<tr><td>range[T]</td><td>default(T); this may be out of the valid range</td></tr>
<tr><td>T = enum</td><td>cast<a class="reference external" href="0">T</a>; this may be an invalid value</td></tr>
</table><p>出于优化原因，可以使用 <span id="noinit_1">noinit</span> 编译指示来避免隐式初始化:</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noInit</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">1023</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">]</span></pre><p>如果一个proc用 <tt class="docutils literal"><span class="pre">noinit</span></tt> 编译指示注释，则指的是它隐含的 <tt class="docutils literal"><span class="pre">result</span></tt> 变量：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">returnUndefinedValue</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noinit</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre><p>隐式初始化可以用 <span id="requiresinit_1">requiresInit</span> 类型编译指示阻止。 编译器需要对对象及其所有字段进行显式初始化。 然而它执行 <span id="控制流分析_1">控制流分析</span> 证明变量已经初始化并且不依赖于语法属性：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MyObject</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">requiresInit</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 以下内容有效：</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span>
  <span class="Keyword">if</span> <span class="Identifier">someCondition</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Comment"># use x</span></pre>
<h2><a class="toc-backref" id="语句和表达式-let语句" href="#语句和表达式-let语句">Let语句</a></h2><p><tt class="docutils literal"><span class="pre">let``语句声明了新的本地和全局 `单次赋值`:idx: 变量并绑定值。 语法与 ``var</span></tt> 语句的语法相同，只是关键字 <tt class="docutils literal"><span class="pre">var</span></tt> 被替换为关键字 <tt class="docutils literal"><span class="pre">let</span></tt> 。 Let变量不是左值因此不能传递给``var``参数，也不能采用它们的地址。他们无法分配新值。</p>
<p>对于let变量，可以使用与普通变量相同的编译指示。</p>

<h2><a class="toc-backref" id="语句和表达式-元组解包" href="#语句和表达式-元组解包">元组解包</a></h2><p>在 <tt class="docutils literal"><span class="pre">var</span></tt> 或 <tt class="docutils literal"><span class="pre">let</span></tt> 语句中可以执行元组解包。 特殊标识符 <tt class="docutils literal"><span class="pre">_</span></tt> 可以用来忽略元组的某些部分：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">returnsTuple</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>

<span class="Keyword">let</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">_</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">returnsTuple</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="语句和表达式-常量段" href="#语句和表达式-常量段">常量段</a></h2><p>const部分声明其值为常量表达式的常量：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">strutils</span>
<span class="Keyword">const</span>
  <span class="Identifier">roundPi</span> <span class="Operator">=</span> <span class="FloatNumber">3.1415</span>
  <span class="Identifier">constEval</span> <span class="Operator">=</span> <span class="Identifier">contains</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">)</span> <span class="Comment"># computed at compile time!</span></pre><p>声明后，常量符号可用作常量表达式。</p>
<p>详见 <a class="reference external" href="#constants-and-constant-expressions">Constants and Constant Expressions</a> 。</p>

<h2><a class="toc-backref" id="语句和表达式-静态语句和表达式" href="#语句和表达式-静态语句和表达式">静态语句和表达式</a></h2><p>静态语句/表达式显式需要编译时执行。 甚至一些具有副作用的代码也允许在静态块中：</p>
<pre class="listing"><span class="Keyword">static</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;echo at compile time&quot;</span></pre><p>在编译时可以执行哪些Nim代码存在限制; 详见 <a class="reference external" href="#restrictions-on-compileminustime-execution">Restrictions on Compile-Time Execution</a> 。 如果编译器无法在编译时执行块，那么这是一个静态错误。</p>

<h2><a class="toc-backref" id="语句和表达式-if语句" href="#语句和表达式-if语句">If语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>

<span class="Keyword">if</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;Andreas&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;What a nice name!&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Don't you have a name?&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Boring name...&quot;</span></pre><p><tt class="docutils literal"><span class="pre">if</span></tt> 语句是在控制流中创建分支的简单方法：计算关键字 <tt class="docutils literal"><span class="pre">if</span></tt> 之后的表达式，如果为真，则执行 <tt class="docutils literal"><span class="pre">:</span></tt> 之后的相应语句。 这一直持续到最后一个 <tt class="docutils literal"><span class="pre">elif</span></tt> 。 如果所有条件都失败，则执行 <tt class="docutils literal"><span class="pre">else</span></tt> 部分。 如果没有 <tt class="docutils literal"><span class="pre">else</span></tt> 部分，则继续执行下一个语句。</p>
<p>在 <tt class="docutils literal"><span class="pre">if</span></tt> 语句中，新的作用域在 <tt class="docutils literal"><span class="pre">if</span></tt> 或 <tt class="docutils literal"><span class="pre">elif</span></tt> 或 <tt class="docutils literal"><span class="pre">else</span></tt> 关键字之后立即开始，并在相应的 <em>then</em> 块之后结束。</p>
<p>出于可视化目的，作用域已包含在 <tt class="docutils literal"><span class="pre">{| |}</span></tt> 在以下示例中</p>
<p>示例：</p>
<pre class="listing"><span class="Keyword">if</span> <span class="Punctuation">{</span><span class="Operator">|</span> <span class="Punctuation">(</span><span class="Keyword">let</span> <span class="Identifier">m</span> <span class="Operator">=</span> <span class="Identifier">input</span> <span class="Operator">=~</span> <span class="RawData">re&quot;(\w+)=\w+&quot;</span><span class="Punctuation">;</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">isMatch</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;key &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="StringLit">&quot; value &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span>  <span class="Operator">|</span><span class="Punctuation">}</span>
<span class="Keyword">elif</span> <span class="Punctuation">{</span><span class="Operator">|</span> <span class="Punctuation">(</span><span class="Keyword">let</span> <span class="Identifier">m</span> <span class="Operator">=</span> <span class="Identifier">input</span> <span class="Operator">=~</span> <span class="RawData">re&quot;&quot;</span><span class="Punctuation">;</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">isMatch</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;new m in this scope&quot;</span>  <span class="Operator">|</span><span class="Punctuation">}</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Punctuation">{</span><span class="Operator">|</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;m not declared here&quot;</span>  <span class="Operator">|</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="语句和表达式-case语句" href="#语句和表达式-case语句">Case语句</a></h2><p>示例:</p>
<pre class="listing"><span class="Keyword">case</span> <span class="Identifier">readline</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;delete-everything&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;restart-computer&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;permission denied&quot;</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;go-for-a-walk&quot;</span><span class="Punctuation">:</span>     <span class="Identifier">echo</span> <span class="StringLit">&quot;please yourself&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>                   <span class="Identifier">echo</span> <span class="StringLit">&quot;unknown command&quot;</span>

<span class="Comment"># 允许分支缩进; 冒号也是可选的</span>
<span class="Comment"># 在选择表达式后:</span>
<span class="Keyword">case</span> <span class="Identifier">readline</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;delete-everything&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;restart-computer&quot;</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;permission denied&quot;</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;go-for-a-walk&quot;</span><span class="Punctuation">:</span>     <span class="Identifier">echo</span> <span class="StringLit">&quot;please yourself&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>                   <span class="Identifier">echo</span> <span class="StringLit">&quot;unknown command&quot;</span></pre><p><tt class="docutils literal"><span class="pre">case</span></tt> 语句类似于if语句，但它表示多分支选择。</p>
<p>评估关键字 <tt class="docutils literal"><span class="pre">case</span></tt> 之后的表达式，如果它的值在 <em>slicelist</em> 中，则执行在 <tt class="docutils literal"><span class="pre">of</span></tt> 关键字之后的相应语句。</p>
<p>如果该值不在任何给定的 <em>slicelist</em> 中，则执行 <tt class="docutils literal"><span class="pre">else</span></tt> 部分。 如果没有 <tt class="docutils literal"><span class="pre">else</span></tt> 部分而且 <tt class="docutils literal"><span class="pre">expr</span></tt> 可以保持在 <tt class="docutils literal"><span class="pre">slicelist</span></tt> 中的所有可能值，则会发生静态错误。 这仅适用于序数类型的表达式。 <tt class="docutils literal"><span class="pre">expr</span></tt> 的“所有可能的值”由 <tt class="docutils literal"><span class="pre">expr</span></tt> 的类型决定。 为了阻止静态错误，应该使用带有空 <tt class="docutils literal"><span class="pre">discard</span></tt> 语句的 <tt class="docutils literal"><span class="pre">else</span></tt> 部分。</p>
<p>对于非序数类型，不可能列出每个可能的值，因此这些值总是需要 <tt class="docutils literal"><span class="pre">else</span></tt> 部分。</p>
<p>因为在语义分析期间检查case语句的详尽性，所以每个 <tt class="docutils literal"><span class="pre">of</span></tt> 分支中的值必须是常量表达式。 此限制还允许编译器生成更高性能的代码。</p>
<p>作为一种特殊的语义扩展，case语句的 <tt class="docutils literal"><span class="pre">of</span></tt> 分支中的表达式可以计算为集合或数组构造函数;然后将集合或数组扩展为其元素列表：</p>
<pre class="listing"><span class="Keyword">const</span>
  <span class="Identifier">SymChars</span><span class="Punctuation">:</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'A'</span><span class="Operator">..</span><span class="CharLit">'Z'</span><span class="Punctuation">,</span> <span class="CharLit">'\x80'</span><span class="Operator">..</span><span class="CharLit">'\xFF'</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">classify</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">of</span> <span class="Identifier">SymChars</span><span class="Punctuation">,</span> <span class="CharLit">'_'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;an identifier&quot;</span>
  <span class="Keyword">of</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;a number&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;other&quot;</span>

<span class="Comment"># is equivalent to:</span>
<span class="Keyword">proc</span> <span class="Identifier">classify</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">of</span> <span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'A'</span><span class="Operator">..</span><span class="CharLit">'Z'</span><span class="Punctuation">,</span> <span class="CharLit">'\x80'</span><span class="Operator">..</span><span class="CharLit">'\xFF'</span><span class="Punctuation">,</span> <span class="CharLit">'_'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;an identifier&quot;</span>
  <span class="Keyword">of</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;a number&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;other&quot;</span></pre>
<h2><a class="toc-backref" id="语句和表达式-when语句" href="#语句和表达式-when语句">When语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">when</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on a 16 bit system!&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">4</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on a 32 bit system!&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">8</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on a 64 bit system!&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;cannot happen!&quot;</span></pre><p><tt class="docutils literal"><span class="pre">when</span></tt> 语句几乎与 <tt class="docutils literal"><span class="pre">if</span></tt> 语句完全相同，但有一些例外：</p>
<ul class="simple"><li>每个条件 (<tt class="docutils literal"><span class="pre">expr</span></tt>) 必须是一个类型为 <tt class="docutils literal"><span class="pre">bool</span></tt> 的常量表达式。</li>
<li>语句不打开新作用域。</li>
<li>属于计算结果为true的表达式的语句由编译器翻译，其他语句不检查语义。</li>
</ul>
<p><tt class="docutils literal"><span class="pre">when</span></tt> 语句启用条件编译技术。 作为一种特殊的语法扩展，``when`` 结构也可以在 <tt class="docutils literal"><span class="pre">object</span></tt> 定义中使用。</p>

<h2><a class="toc-backref" id="语句和表达式-when-nimvm语句" href="#语句和表达式-when-nimvm语句">When nimvm语句</a></h2><p><tt class="docutils literal"><span class="pre">nimvm</span></tt> 是一个特殊的符号，可以用作 <tt class="docutils literal"><span class="pre">when nimvm</span></tt> 语句的表达式来区分编译时和可执行文件之间的执行路径。</p>
<p>示例：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">someProcThatMayRunInCompileTime</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">when</span> <span class="Identifier">nimvm</span><span class="Punctuation">:</span>
    <span class="Comment"># 编译时采用这个分支。</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Comment"># 可执行文件中采用这个分支</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Keyword">const</span> <span class="Identifier">ctValue</span> <span class="Operator">=</span> <span class="Identifier">someProcThatMayRunInCompileTime</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">rtValue</span> <span class="Operator">=</span> <span class="Identifier">someProcThatMayRunInCompileTime</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">ctValue</span> <span class="Operator">==</span> <span class="Identifier">true</span><span class="Punctuation">)</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">rtValue</span> <span class="Operator">==</span> <span class="Identifier">false</span><span class="Punctuation">)</span></pre><p><tt class="docutils literal"><span class="pre">when nimvm</span></tt> 语句必须满足以下要求：</p>
<ul class="simple"><li>Its expression must always be <tt class="docutils literal"><span class="pre">nimvm</span></tt>. More complex expressions are not allowed.</li>
<li>It must not contain <tt class="docutils literal"><span class="pre">elif</span></tt> branches.</li>
<li>It must contain <tt class="docutils literal"><span class="pre">else</span></tt> branch.</li>
<li>Code in branches must not affect semantics of the code that follows the <tt class="docutils literal"><span class="pre">when nimvm</span></tt> statement. E.g. it must not define symbols that are used in the following code.</li>
</ul>

<h2><a class="toc-backref" id="语句和表达式-return语句" href="#语句和表达式-return语句">Return语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">return</span> <span class="DecNumber">40</span><span class="Operator">+</span><span class="DecNumber">2</span></pre><p>The <tt class="docutils literal"><span class="pre">return</span></tt> statement ends the execution of the current procedure. It is only allowed in procedures. If there is an <tt class="docutils literal"><span class="pre">expr</span></tt>, this is syntactic sugar for:</p>
<pre class="listing"><span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">expr</span>
<span class="Keyword">return</span> <span class="Identifier">result</span></pre><p><tt class="docutils literal"><span class="pre">return</span></tt> without an expression is a short notation for <tt class="docutils literal"><span class="pre">return result</span></tt> if the proc has a return type. The <span id="result_1">result</span> variable is always the return value of the procedure. It is automatically declared by the compiler. As all variables, <tt class="docutils literal"><span class="pre">result</span></tt> is initialized to (binary) zero:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">returnZero</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># implicitly returns 0</span></pre>
<h2><a class="toc-backref" id="语句和表达式-yield语句" href="#语句和表达式-yield语句">Yield语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">yield</span> <span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">yield</span></tt> statement is used instead of the <tt class="docutils literal"><span class="pre">return</span></tt> statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but execution is passed back to the iterator if the next iteration starts. See the section about iterators (<a class="reference external" href="#iterators-and-the-for-statement">Iterators and the for statement</a>) for further information.</p>

<h2><a class="toc-backref" id="语句和表达式-block语句" href="#语句和表达式-block语句">Block语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">found</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Keyword">block</span> <span class="Identifier">myblock</span><span class="Punctuation">:</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">3</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">j</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">3</span><span class="Punctuation">:</span>
      <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">j</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="DecNumber">7</span><span class="Punctuation">:</span>
        <span class="Identifier">found</span> <span class="Operator">=</span> <span class="Identifier">true</span>
        <span class="Keyword">break</span> <span class="Identifier">myblock</span> <span class="Comment"># leave the block, in this case both for-loops</span>
<span class="Identifier">echo</span> <span class="Identifier">found</span></pre><p>The block statement is a means to group statements to a (named) <tt class="docutils literal"><span class="pre">block</span></tt>. Inside the block, the <tt class="docutils literal"><span class="pre">break</span></tt> statement is allowed to leave the block immediately. A <tt class="docutils literal"><span class="pre">break</span></tt> statement can contain a name of a surrounding block to specify which block is to leave.</p>

<h2><a class="toc-backref" id="语句和表达式-break语句" href="#语句和表达式-break语句">Break语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">break</span></pre><p>The <tt class="docutils literal"><span class="pre">break</span></tt> statement is used to leave a block immediately. If <tt class="docutils literal"><span class="pre">symbol</span></tt> is given, it is the name of the enclosing block that is to leave. If it is absent, the innermost block is left.</p>

<h2><a class="toc-backref" id="语句和表达式-while语句" href="#语句和表达式-while语句">While语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;Please tell me your password:&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">pw</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">while</span> <span class="Identifier">pw</span> <span class="Operator">!=</span> <span class="StringLit">&quot;12345&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Wrong password! Next try:&quot;</span>
  <span class="Identifier">pw</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">while</span></tt> statement is executed until the <tt class="docutils literal"><span class="pre">expr</span></tt> evaluates to false. Endless loops are no error. <tt class="docutils literal"><span class="pre">while</span></tt> statements open an <tt class="docutils literal"><span class="pre">implicit block</span></tt>, so that they can be left with a <tt class="docutils literal"><span class="pre">break</span></tt> statement.</p>

<h2><a class="toc-backref" id="语句和表达式-continue语句" href="#语句和表达式-continue语句">Continue语句</a></h2><p>A <tt class="docutils literal"><span class="pre">continue</span></tt> statement leads to the immediate next iteration of the surrounding loop construct. It is only allowed within a loop. A continue statement is syntactic sugar for a nested block:</p>
<pre class="listing"><span class="Keyword">while</span> <span class="Identifier">expr1</span><span class="Punctuation">:</span>
  <span class="Identifier">stmt1</span>
  <span class="Keyword">continue</span>
  <span class="Identifier">stmt2</span></pre><p>Is equivalent to:</p>
<pre class="listing"><span class="Keyword">while</span> <span class="Identifier">expr1</span><span class="Punctuation">:</span>
  <span class="Keyword">block</span> <span class="Identifier">myBlockName</span><span class="Punctuation">:</span>
    <span class="Identifier">stmt1</span>
    <span class="Keyword">break</span> <span class="Identifier">myBlockName</span>
    <span class="Identifier">stmt2</span></pre>
<h2><a class="toc-backref" id="语句和表达式-汇编语句" href="#语句和表达式-汇编语句">汇编语句</a></h2><p>The direct embedding of assembler code into Nim code is supported by the unsafe <tt class="docutils literal"><span class="pre">asm</span></tt> statement. Identifiers in the assembler code that refer to Nim identifiers shall be enclosed in a special character which can be specified in the statement's pragmas. The default special character is <tt class="docutils literal"><span class="pre">'`'</span></tt>:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">stackTrace</span><span class="Punctuation">:</span><span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">addInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># a in eax, and b in edx</span>
  <span class="Keyword">asm</span> <span class="LongStringLit">&quot;&quot;&quot;
      mov eax, `a`
      add eax, `b`
      jno theEnd
      call `raiseOverflow`
    theEnd:
  &quot;&quot;&quot;</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>If the GNU assembler is used, quotes and newlines are inserted automatically:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">addInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">asm</span> <span class="LongStringLit">&quot;&quot;&quot;
    addl %%ecx, %%eax
    jno 1
    call `raiseOverflow`
    1:
    :&quot;=a&quot;(`result`)
    :&quot;a&quot;(`a`), &quot;c&quot;(`b`)
  &quot;&quot;&quot;</span></pre><p>Instead of:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">addInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">asm</span> <span class="LongStringLit">&quot;&quot;&quot;
    &quot;addl %%ecx, %%eax\n&quot;
    &quot;jno 1\n&quot;
    &quot;call `raiseOverflow`\n&quot;
    &quot;1: \n&quot;
    :&quot;=a&quot;(`result`)
    :&quot;a&quot;(`a`), &quot;c&quot;(`b`)
  &quot;&quot;&quot;</span></pre>
<h2><a class="toc-backref" id="语句和表达式-using语句" href="#语句和表达式-using语句">Using语句</a></h2><p>The using statement provides syntactic convenience in modules where the same parameter names and types are used over and over. Instead of:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Context</span><span class="Punctuation">;</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Keyword">proc</span> <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Context</span><span class="Punctuation">;</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">,</span> <span class="Identifier">counter</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Keyword">proc</span> <span class="Identifier">baz</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Context</span><span class="Punctuation">;</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span></pre><p>One can tell the compiler about the convention that a parameter of name <tt class="docutils literal"><span class="pre">c</span></tt> should default to type <tt class="docutils literal"><span class="pre">Context</span></tt>, <tt class="docutils literal"><span class="pre">n</span></tt> should default to <tt class="docutils literal"><span class="pre">Node</span></tt> etc.:</p>
<pre class="listing"><span class="Keyword">using</span>
  <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Context</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
  <span class="Identifier">counter</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Keyword">proc</span> <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">,</span> <span class="Identifier">counter</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Keyword">proc</span> <span class="Identifier">baz</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Identifier">mixedMode</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">;</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 'c' is inferred to be of the type 'Context'</span>
  <span class="Comment"># 'n' is inferred to be of the type 'Node'</span>
  <span class="Comment"># But 'x' and 'y' are of type 'int'.</span></pre><p>The <tt class="docutils literal"><span class="pre">using</span></tt> section uses the same indentation based grouping syntax as a <tt class="docutils literal"><span class="pre">var</span></tt> or <tt class="docutils literal"><span class="pre">let</span></tt> section.</p>
<p>Note that <tt class="docutils literal"><span class="pre">using</span></tt> is not applied for <tt class="docutils literal"><span class="pre">template</span></tt> since untyped template parameters default to the type <tt class="docutils literal"><span class="pre">system.untyped</span></tt>.</p>
<p>Mixing parameters that should use the <tt class="docutils literal"><span class="pre">using</span></tt> declaration with parameters that are explicitly typed is possible and requires a semicolon between them.</p>

<h2><a class="toc-backref" id="语句和表达式-if表达式" href="#语句和表达式-if表达式">If表达式</a></h2><p>An <tt class="docutils literal"><span class="pre">if expression</span></tt> is almost like an if statement, but it is an expression. 示例：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Operator">&gt;</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="DecNumber">9</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="DecNumber">10</span></pre><p>An if expression always results in a value, so the <tt class="docutils literal"><span class="pre">else</span></tt> part is required. <tt class="docutils literal"><span class="pre">Elif</span></tt> parts are also allowed.</p>

<h2><a class="toc-backref" id="语句和表达式-when表达式" href="#语句和表达式-when表达式">When表达式</a></h2><p>Just like an <tt class="docutils literal"><span class="pre">if expression</span></tt>, but corresponding to the when statement.</p>

<h2><a class="toc-backref" id="语句和表达式-case表达式" href="#语句和表达式-case表达式">Case表达式</a></h2><p>The <tt class="docutils literal"><span class="pre">case expression</span></tt> is again very similar to the case statement:</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">favoriteFood</span> <span class="Operator">=</span> <span class="Keyword">case</span> <span class="Identifier">animal</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;dog&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;bones&quot;</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;cat&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;mice&quot;</span>
  <span class="Keyword">elif</span> <span class="Identifier">animal</span><span class="Operator">.</span><span class="RawData">endsWith&quot;whale&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;plankton&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;I'm not sure what to serve, but everybody loves ice cream&quot;</span>
    <span class="StringLit">&quot;ice cream&quot;</span></pre><p>As seen in the above example, the case expression can also introduce side effects. When multiple statements are given for a branch, Nim will use the last expression as the result value.</p>

<h2><a class="toc-backref" id="语句和表达式-block表达式" href="#语句和表达式-block表达式">Block表达式</a></h2><p>A <tt class="docutils literal"><span class="pre">block expression</span></tt> is almost like a block statement, but it is an expression that uses last expression under the block as the value. It is similar to the statement list expression, but the statement list expression does not open new block scope.</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Keyword">block</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">fib</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">]</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">:</span>
    <span class="Identifier">fib</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">fib</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">+</span> <span class="Identifier">fib</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span>
  <span class="Identifier">fib</span></pre>
<h2><a class="toc-backref" id="语句和表达式-table构造函数" href="#语句和表达式-table构造函数">Table构造函数</a></h2><p>表构造函数是数组构造函数的语法糖：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="StringLit">&quot;key1&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;value1&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;key2&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;key3&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;value2&quot;</span><span class="Punctuation">}</span>

<span class="Comment"># is the same as:</span>
<span class="Punctuation">[</span><span class="Punctuation">(</span><span class="StringLit">&quot;key1&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value1&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="StringLit">&quot;key2&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value2&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="StringLit">&quot;key3&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value2&quot;</span><span class="Punctuation">)</span><span class="Punctuation">]</span></pre><p>The empty table can be written <tt class="docutils literal"><span class="pre">{:}</span></tt> (in contrast to the empty set which is <tt class="docutils literal"><span class="pre">{}</span></tt>) which is thus another way to write as the empty array constructor <tt class="docutils literal"><span class="pre">[]</span></tt>. This slightly unusual way of supporting tables has lots of advantages:</p>
<ul class="simple"><li>The order of the (key,value)-pairs is preserved, thus it is easy to support ordered dicts with for example <tt class="docutils literal"><span class="pre">{key: val}.newOrderedTable</span></tt>.</li>
<li>A table literal can be put into a <tt class="docutils literal"><span class="pre">const</span></tt> section and the compiler can easily put it into the executable's data section just like it can for arrays and the generated data section requires a minimal amount of memory.</li>
<li>Every table implementation is treated equal syntactically.</li>
<li>Apart from the minimal syntactic sugar the language core does not need to know about tables.</li>
</ul>

<h2><a class="toc-backref" id="语句和表达式-类型转换" href="#语句和表达式-类型转换">类型转换</a></h2><p>Syntactically a <tt class="docutils literal"><span class="pre">type conversion</span></tt> is like a procedure call, but a type name replaces the procedure name. A type conversion is always safe in the sense that a failure to convert a type to another results in an exception (if it cannot be determined statically).</p>
<p>Ordinary procs are often preferred over type conversions in Nim: For instance, <tt class="docutils literal"><span class="pre">$</span></tt> is the <tt class="docutils literal"><span class="pre">toString</span></tt> operator by convention and <tt class="docutils literal"><span class="pre">toFloat</span></tt> and <tt class="docutils literal"><span class="pre">toInt</span></tt> can be used to convert from floating point to integer or vice versa.</p>
<p>A type conversion can also be used to disambiguate overloaded routines:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;int&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;string&quot;</span>

<span class="Keyword">let</span> <span class="Identifier">procVar</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">)</span>
<span class="Identifier">procVar</span><span class="Punctuation">(</span><span class="StringLit">&quot;a&quot;</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="语句和表达式-类型强转" href="#语句和表达式-类型强转">类型强转</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>Type casts are a crude mechanism to interpret the bit pattern of an expression as if it would be of another type. Type casts are only needed for low-level programming and are inherently unsafe.</p>

<h2><a class="toc-backref" id="语句和表达式-addr操作符" href="#语句和表达式-addr操作符">addr操作符</a></h2><p>The <tt class="docutils literal"><span class="pre">addr</span></tt> operator returns the address of an l-value. If the type of the location is <tt class="docutils literal"><span class="pre">T</span></tt>, the <tt class="docutils literal"><span class="pre">addr</span></tt> operator result is of the type <tt class="docutils literal"><span class="pre">ptr T</span></tt>. An address is always an untraced reference. Taking the address of an object that resides on the stack is <strong>unsafe</strong>, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through <tt class="docutils literal"><span class="pre">let</span></tt> statements:</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">t1</span> <span class="Operator">=</span> <span class="StringLit">&quot;Hello&quot;</span>
<span class="Keyword">var</span>
  <span class="Identifier">t2</span> <span class="Operator">=</span> <span class="Identifier">t1</span>
  <span class="Identifier">t3</span> <span class="Punctuation">:</span> <span class="Identifier">pointer</span> <span class="Operator">=</span> <span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">t2</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">t2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; ref 0x7fff6b71b670 --&gt; 0x10bb81050&quot;Hello&quot;</span>
<span class="Identifier">echo</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Keyword">ptr</span> <span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">t3</span><span class="Punctuation">)</span><span class="Punctuation">[</span><span class="Punctuation">]</span>
<span class="Comment"># --&gt; Hello</span>
<span class="Comment"># The following line doesn't compile:</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">t1</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># Error: expression has no address</span></pre>
<h2><a class="toc-backref" id="语句和表达式-unsafeaddr操作符" href="#语句和表达式-unsafeaddr操作符">unsafeAddr操作符</a></h2><p>For easier interoperability with other compiled languages such as C, retrieving the address of a <tt class="docutils literal"><span class="pre">let</span></tt> variable, a parameter or a <tt class="docutils literal"><span class="pre">for</span></tt> loop variable, the <tt class="docutils literal"><span class="pre">unsafeAddr</span></tt> operation can be used:</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">myArray</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span>
<span class="Identifier">foreignProcThatTakesAnAddr</span><span class="Punctuation">(</span><span class="Identifier">unsafeAddr</span> <span class="Identifier">myArray</span><span class="Punctuation">)</span></pre>
<h1><a class="toc-backref" id="过程" href="#过程">过程</a></h1><p>What most programming languages call <span id="methods_1">methods</span> or <span id="functions_1">functions</span> are called <span id="procedures_1">procedures</span> in Nim. A procedure declaration consists of an identifier, zero or more formal parameters, a return value type and a block of code. Formal parameters are declared as a list of identifiers separated by either comma or semicolon. A parameter is given a type by <tt class="docutils literal"><span class="pre">: typename</span></tt>. The type applies to all parameters immediately before it, until either the beginning of the parameter list, a semicolon separator or an already typed parameter, is reached. The semicolon can be used to make separation of types and subsequent identifiers more distinct.</p>
<pre class="listing"><span class="Comment"># Using only commas</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">d</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Comment"># Using semicolon for visual distinction</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">d</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Comment"># Will fail: a is untyped since ';' stops type propagation.</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">;</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">d</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>A parameter may be declared with a default value which is used if the caller does not provide a value for the argument.</p>
<pre class="listing"><span class="Comment"># b is optional with 47 as its default value</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">47</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>Parameters can be declared mutable and so allow the proc to modify those arguments, by using the type modifier <tt class="docutils literal"><span class="pre">var</span></tt>.</p>
<pre class="listing"><span class="Comment"># &quot;returning&quot; a value to the caller through the 2nd argument</span>
<span class="Comment"># Notice that the function uses no actual return value at all (ie void)</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">inp</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">outp</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">outp</span> <span class="Operator">=</span> <span class="Identifier">inp</span> <span class="Operator">+</span> <span class="DecNumber">47</span></pre><p>If the proc declaration has no body, it is a <span id="forward_1">forward</span> declaration. If the proc returns a value, the procedure body can access an implicitly declared variable named <span id="result_2">result</span> that represents the return value. Procs can be overloaded. The overloading resolution algorithm determines which proc is the best match for the arguments.</p>
<p>示例：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">toLower</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">char</span> <span class="Operator">=</span> <span class="Comment"># toLower for characters</span>
  <span class="Keyword">if</span> <span class="Identifier">c</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="CharLit">'A'</span><span class="Operator">..</span><span class="CharLit">'Z'</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">chr</span><span class="Punctuation">(</span><span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Punctuation">(</span><span class="Identifier">ord</span><span class="Punctuation">(</span><span class="CharLit">'a'</span><span class="Punctuation">)</span> <span class="Operator">-</span> <span class="Identifier">ord</span><span class="Punctuation">(</span><span class="CharLit">'A'</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">c</span>

<span class="Keyword">proc</span> <span class="Identifier">toLower</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Comment"># toLower for strings</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newString</span><span class="Punctuation">(</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">toLower</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># calls toLower for characters; no recursion!</span></pre><p>Calling a procedure can be done in many different ways:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">false</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Comment"># call with positional arguments      # parameter bindings:</span>
<span class="Identifier">callme</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span><span class="Punctuation">,</span> <span class="Identifier">true</span><span class="Punctuation">)</span>       <span class="Comment"># (x=0, y=1, s=&quot;abc&quot;, c='\t', b=true)</span>
<span class="Comment"># call with named and positional arguments:</span>
<span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Operator">=</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Operator">=</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abd&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span><span class="Punctuation">)</span>         <span class="Comment"># (x=0, y=1, s=&quot;abd&quot;, c='\t', b=false)</span>
<span class="Comment"># call with named arguments (order is not relevant):</span>
<span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Operator">=</span><span class="CharLit">'\t'</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Operator">=</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Operator">=</span><span class="DecNumber">0</span><span class="Punctuation">)</span>              <span class="Comment"># (x=0, y=1, s=&quot;&quot;, c='\t', b=false)</span>
<span class="Comment"># call as a command statement: no () needed:</span>
<span class="Identifier">callme</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span>              <span class="Comment"># (x=0, y=1, s=&quot;abc&quot;, c='\t', b=false)</span></pre><p>A procedure may call itself recursively.</p>
<p><span id="operators_1">Operators</span> are procedures with a special operator symbol as identifier:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Comment"># converts an integer to a string; this is a prefix operator.</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">intToStr</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>Operators with one parameter are prefix operators, operators with two parameters are infix operators. (However, the parser distinguishes these from the operator's position within an expression.) There is no way to declare postfix operators: all postfix operators are built-in and handled by the grammar explicitly.</p>
<p>Any operator can be called like an ordinary proc with the '<tt class="docutils literal"><span class="pre">opr</span></tt>' notation. (Thus an operator can have more than two parameters):</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># Multiply and add</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">*</span> <span class="Identifier">b</span> <span class="Operator">+</span> <span class="Identifier">c</span>

<span class="Identifier">assert</span> <span class="Punctuation">`</span><span class="Operator">*+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="过程-导出标记" href="#过程-导出标记">导出标记</a></h2><p>If a declared symbol is marked with an <span id="asterisk_1">asterisk</span> it is exported from the current module:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">exportedEcho</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="Identifier">s</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">;</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newStringOfCap</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">*</span> <span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">a</span>

<span class="Keyword">var</span> <span class="Identifier">exportedVar</span><span class="Operator">*:</span> <span class="Identifier">int</span>
<span class="Keyword">const</span> <span class="Identifier">exportedConst</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="DecNumber">78</span>
<span class="Keyword">type</span>
  <span class="Identifier">ExportedType</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">exportedField</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre>
<h2><a class="toc-backref" id="过程-方法调用语法" href="#过程-方法调用语法">方法调用语法</a></h2><p>For object oriented programming, the syntax <tt class="docutils literal"><span class="pre">obj.method(args)</span></tt> can be used instead of <tt class="docutils literal"><span class="pre">method(obj, args)</span></tt>. The parentheses can be omitted if there are no remaining arguments: <tt class="docutils literal"><span class="pre">obj.len</span></tt> (instead of <tt class="docutils literal"><span class="pre">len(obj)</span></tt>).</p>
<p>This method call syntax is not restricted to objects, it can be used to supply any type of first argument for procedures:</p>
<pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Comment"># is the same as echo len &quot;abc&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">toUpper</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">,</span> <span class="CharLit">'c'</span><span class="Punctuation">}</span><span class="Operator">.</span><span class="Identifier">card</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hallo&quot;</span><span class="Punctuation">)</span> <span class="Comment"># the same as writeLine(stdout, &quot;Hallo&quot;)</span></pre><p>Another way to look at the method call syntax is that it provides the missing postfix notation.</p>
<p>The method call syntax conflicts with explicit generic instantiations: <tt class="docutils literal"><span class="pre">p[T](x)</span></tt> cannot be written as <tt class="docutils literal"><span class="pre">x.p[T]</span></tt> because <tt class="docutils literal"><span class="pre">x.p[T]</span></tt> is always parsed as <tt class="docutils literal"><span class="pre">(x.p)[T]</span></tt>.</p>
<p>See also: <a class="reference external" href="#templates-limitations-of-the-method-call-syntax">Limitations of the method call syntax</a> .</p>
<p>The <tt class="docutils literal"><span class="pre">[: ]</span></tt> notation has been designed to mitigate this issue: <tt class="docutils literal"><span class="pre">x.p[:T]</span></tt> is rewritten by the parser to <tt class="docutils literal"><span class="pre">p[T](x)</span></tt>, <tt class="docutils literal"><span class="pre">x.p[:T](y)</span></tt> is rewritten to <tt class="docutils literal"><span class="pre">p[T](x, y)</span></tt>. Note that <tt class="docutils literal"><span class="pre">[: ]</span></tt> has no AST representation, the rewrite is performed directly in the parsing step.</p>

<h2><a class="toc-backref" id="过程-属性" href="#过程-属性">属性</a></h2><p>Nim has no need for <em>get-properties</em>: Ordinary get-procedures that are called with the <em>method call syntax</em> achieve the same. But setting a value is different; for this a special setter syntax is needed:</p>
<pre class="listing"><span class="Comment"># Module asocket</span>
<span class="Keyword">type</span>
  <span class="Identifier">Socket</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">host</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># cannot be accessed from the outside of the module</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Identifier">host</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Socket</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## setter of hostAddr.</span>
  <span class="Comment">## This accesses the 'host' field and is not a recursive call to</span>
  <span class="Comment">## ``host=`` because the builtin dot access is preferred if it is</span>
  <span class="Comment">## avaliable:</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">host</span> <span class="Operator">=</span> <span class="Identifier">value</span>

<span class="Keyword">proc</span> <span class="Identifier">host</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## getter of hostAddr</span>
  <span class="Comment">## This accesses the 'host' field and is not a recursive call to</span>
  <span class="Comment">## ``host`` because the builtin dot access is preferred if it is</span>
  <span class="Comment">## avaliable:</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">host</span></pre><pre class="listing"><span class="Comment"># module B</span>
<span class="Keyword">import</span> <span class="Identifier">asocket</span>
<span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span>
<span class="Identifier">new</span> <span class="Identifier">s</span>
<span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">host</span> <span class="Operator">=</span> <span class="DecNumber">34</span>  <span class="Comment"># same as `host=`(s, 34)</span></pre><p>A proc defined as <tt class="docutils literal"><span class="pre">f=</span></tt> (with the trailing <tt class="docutils literal"><span class="pre">=</span></tt>) is called a <span id="setter_1">setter</span>. A setter can be called explicitly via the common backticks notation:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Identifier">f</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span><span class="Punctuation">;</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">discard</span>

<span class="Punctuation">`</span><span class="Identifier">f</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">myObject</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value&quot;</span><span class="Punctuation">)</span></pre><p><tt class="docutils literal"><span class="pre">f=</span></tt> can be called implicitly in the pattern <tt class="docutils literal"><span class="pre">x.f = value</span></tt> if and only if the type of <tt class="docutils literal"><span class="pre">x</span></tt> does not have a field named <tt class="docutils literal"><span class="pre">f</span></tt> or if <tt class="docutils literal"><span class="pre">f</span></tt> is not visible in the current module. These rules ensure that object fields and accessors can have the same name. Within the module <tt class="docutils literal"><span class="pre">x.f</span></tt> is then always interpreted as field access and outside the module it is interpreted as an accessor proc call.</p>

<h2><a class="toc-backref" id="过程-命令调用语法" href="#过程-命令调用语法">命令调用语法</a></h2><p>Routines can be invoked without the <tt class="docutils literal"><span class="pre">()</span></tt> if the call is syntactically a statement. This command invocation syntax also works for expressions, but then only a single argument may follow. This restriction means <tt class="docutils literal"><span class="pre">echo f 1, f 2</span></tt> is parsed as <tt class="docutils literal"><span class="pre">echo(f(1), f(2))</span></tt> and not as <tt class="docutils literal"><span class="pre">echo(f(1, f(2)))</span></tt>. The method call syntax may be used to provide one more argument in this case:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">optarg</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>
<span class="Keyword">proc</span> <span class="Identifier">singlearg</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">20</span><span class="Operator">*</span><span class="Identifier">x</span>

<span class="Identifier">echo</span> <span class="Identifier">optarg</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">singlearg</span> <span class="DecNumber">2</span>  <span class="Comment"># prints &quot;1 40&quot;</span>

<span class="Keyword">let</span> <span class="Identifier">fail</span> <span class="Operator">=</span> <span class="Identifier">optarg</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">optarg</span> <span class="DecNumber">8</span>   <span class="Comment"># Wrong. Too many arguments for a command call</span>
<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">optarg</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">optarg</span> <span class="DecNumber">8</span><span class="Punctuation">)</span>  <span class="Comment"># traditional procedure call with 2 arguments</span>
<span class="Keyword">let</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="FloatNumber">1.</span><span class="Identifier">optarg</span> <span class="Identifier">optarg</span> <span class="DecNumber">8</span>    <span class="Comment"># same thing as above, w/o the parenthesis</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="Identifier">y</span></pre><p>The command invocation syntax also can't have complex expressions as arguments. For 示例： (<a class="reference external" href="#anonymous-procs">anonymous procs</a>), <tt class="docutils literal"><span class="pre">if</span></tt>, <tt class="docutils literal"><span class="pre">case</span></tt> or <tt class="docutils literal"><span class="pre">try</span></tt>. Function calls with no arguments still needs () to distinguish between a call and the function itself as a first class value.</p>

<h2><a class="toc-backref" id="过程-闭包" href="#过程-闭包">闭包</a></h2><p>Procedures can appear at the top level in a module as well as inside other scopes, in which case they are called nested procs. A nested proc can access local variables from its enclosing scope and if it does so it becomes a closure. Any captured variables are stored in a hidden additional argument to the closure (its environment) and they are accessed by reference by both the closure and its enclosing scope (i.e. any modifications made to them are visible in both places). The closure environment may be allocated on the heap or on the stack if the compiler determines that this would be safe.</p>

<h3><a class="toc-backref" id="闭包-在循环中创建闭包" href="#闭包-在循环中创建闭包">在循环中创建闭包</a></h3><p>Since closures capture local variables by reference it is often not wanted behavior inside loop bodies. See <a class="reference external" href="system.html#closureScope">closureScope</a> for details on how to change this behavior.</p>

<h2><a class="toc-backref" id="过程-anonymous-procs" href="#过程-anonymous-procs">Anonymous Procs</a></h2><p>Procs can also be treated as expressions, in which case it's allowed to omit the proc's name.</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">cities</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="StringLit">&quot;Frankfurt&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Tokyo&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;New York&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Kyiv&quot;</span><span class="Punctuation">]</span>

<span class="Identifier">cities</span><span class="Operator">.</span><span class="Identifier">sort</span><span class="Punctuation">(</span><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>Procs as expressions can appear both as nested procs and inside top level executable code.</p>

<h2><a class="toc-backref" id="过程-函数" href="#过程-函数">函数</a></h2><p>The <tt class="docutils literal"><span class="pre">func</span></tt> keyword introduces a shortcut for a <span id="nosideeffect_1">noSideEffect</span> proc.</p>
<pre class="listing"><span class="Keyword">func</span> <span class="Identifier">binarySearch</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">elem</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>Is short for:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">binarySearch</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">elem</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noSideEffect</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="过程-不可重载的内置" href="#过程-不可重载的内置">不可重载的内置</a></h2><p>The following builtin procs cannot be overloaded for reasons of implementation simplicity (they require specialized semantic checking):<pre>
declared, defined, definedInScope, compiles, sizeOf,
is, shallowCopy, getAst, astToStr, spawn, procCall</pre>
</p>
<p>Thus they act more like keywords than like ordinary identifiers; unlike a keyword however, a redefinition may <span id="shadow_1">shadow</span> the definition in the <tt class="docutils literal"><span class="pre">system</span></tt> module. From this list the following should not be written in dot notation <tt class="docutils literal"><span class="pre">x.f</span></tt> since <tt class="docutils literal"><span class="pre">x</span></tt> cannot be type checked before it gets passed to <tt class="docutils literal"><span class="pre">f</span></tt>:<pre>
declared, defined, definedInScope, compiles, getAst, astToStr</pre>
</p>

<h2><a class="toc-backref" id="过程-var形参" href="#过程-var形参">Var形参</a></h2><p>参数的类型可以使用 <tt class="docutils literal"><span class="pre">var</span></tt> 关键字作为前缀：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span>
  <span class="Identifier">remainder</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Comment"># modifies x and y</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">y</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre><p>In the example, <tt class="docutils literal"><span class="pre">res</span></tt> and <tt class="docutils literal"><span class="pre">remainder</span></tt> are <tt class="docutils literal"><span class="pre">var parameters</span></tt>. Var parameters can be modified by the procedure and the changes are visible to the caller. The argument passed to a var parameter has to be an l-value. Var parameters are implemented as hidden pointers. The above example is equivalent to:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">res</span><span class="Punctuation">[</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span>
  <span class="Identifier">remainder</span><span class="Punctuation">[</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">y</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre><p>In the examples, var parameters or pointers are used to provide two return values. This can be done in a cleaner way by returning a tuple:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">t</span> <span class="Operator">=</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">res</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">remainder</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre><p>One can use <span id="tuple-unpacking_1">tuple unpacking</span> to access the tuple's fields:</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment"># tuple unpacking</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">y</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre><p><strong>Note</strong>: <tt class="docutils literal"><span class="pre">var</span></tt> parameters are never necessary for efficient parameter passing. Since non-var parameters cannot be modified the compiler is always free to pass arguments by reference if it considers it can speed up execution.</p>

<h2><a class="toc-backref" id="过程-var返回类型" href="#过程-var返回类型">Var返回类型</a></h2><p>A proc, converter or iterator may return a <tt class="docutils literal"><span class="pre">var</span></tt> type which means that the returned value is an l-value and can be modified by the caller:</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">g</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">proc</span> <span class="Identifier">writeAccessToG</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">g</span>

<span class="Identifier">writeAccessToG</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="DecNumber">6</span>
<span class="Identifier">assert</span> <span class="Identifier">g</span> <span class="Operator">==</span> <span class="DecNumber">6</span></pre><p>It is a static error if the implicitly introduced pointer could be used to access a location beyond its lifetime:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">writeAccessToG</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">g</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">g</span> <span class="Comment"># Error!</span></pre><p>For iterators, a component of a tuple return type can have a <tt class="docutils literal"><span class="pre">var</span></tt> type too:</p>
<pre class="listing"><span class="Keyword">iterator</span> <span class="Identifier">mpairs</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">key</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">val</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>In the standard library every name of a routine that returns a <tt class="docutils literal"><span class="pre">var</span></tt> type starts with the prefix <tt class="docutils literal"><span class="pre">m</span></tt> per convention.</p>
Memory safety for returning by <tt class="docutils literal"><span class="pre">var T</span></tt> is ensured by a simple borrowing rule: If <tt class="docutils literal"><span class="pre">result</span></tt> does not refer to a location pointing to the heap (that is in <tt class="docutils literal"><span class="pre">result = X</span></tt> the <tt class="docutils literal"><span class="pre">X</span></tt> involves a <tt class="docutils literal"><span class="pre">ptr</span></tt> or <tt class="docutils literal"><span class="pre">ref</span></tt> access) then it has to be deviated by the routine's first parameter:<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">forward</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Comment"># ok, deviated from the first parameter.</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">param</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Comment"># we know 'forward' provides a view into the location deviated by</span>
  <span class="Comment"># its first argument 'x'.</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">forward</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># Error: location is derived from ``x``</span>
                      <span class="Comment"># which is not p's first parameter and lives</span>
                      <span class="Comment"># on the stack.</span></pre><p>In other words, the lifetime of what <tt class="docutils literal"><span class="pre">result</span></tt> points to is attached to the lifetime of the first parameter and that is enough knowledge to verify memory safety at the callsite. </p>

<h3><a class="toc-backref" id="var返回类型-未来的方向" href="#var返回类型-未来的方向">未来的方向</a></h3><p>Later versions of Nim can be more precise about the borrowing rule with a syntax like:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">other</span><span class="Punctuation">:</span> <span class="Identifier">Y</span><span class="Punctuation">;</span> <span class="Identifier">container</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">X</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span> <span class="Keyword">from</span> <span class="Identifier">container</span></pre><p>Here <tt class="docutils literal"><span class="pre">var T from container</span></tt> explicitly exposes that the location is deviated from the second parameter (called 'container' in this case). The syntax <tt class="docutils literal"><span class="pre">var T from p</span></tt> specifies a type <tt class="docutils literal"><span class="pre">varTy[T, 2]</span></tt> which is incompatible with <tt class="docutils literal"><span class="pre">varTy[T, 1]</span></tt>.</p>

<h2><a class="toc-backref" id="过程-下标操作符重载" href="#过程-下标操作符重载">下标操作符重载</a></h2><p>The <tt class="docutils literal"><span class="pre">[]</span></tt> subscript operator for arrays/openarrays/sequences can be overloaded.</p>

<h1><a class="toc-backref" id="多方法" href="#多方法">多方法</a></h1><p><strong>Note:</strong> Starting from Nim 0.20, to use multi-methods one must explicitly pass <tt class="docutils literal"><span class="pre">--multimethods:on</span></tt> when compiling.</p>
<p>Procedures always use static dispatch. Multi-methods use dynamic dispatch. For dynamic dispatch to work on an object it should be a reference type.</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Expression</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span> <span class="Comment">## abstract base class for an expression</span>
  <span class="Identifier">Literal</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Expression</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">PlusExpr</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Expression</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">base</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># override this base method</span>
  <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Literal</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Keyword">return</span> <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">x</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">PlusExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># watch out: relies on dynamic binding</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Literal</span> <span class="Operator">=</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">x</span>

<span class="Keyword">proc</span> <span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PlusExpr</span> <span class="Operator">=</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">b</span>

<span class="Identifier">echo</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>In the example the constructors <tt class="docutils literal"><span class="pre">newLit</span></tt> and <tt class="docutils literal"><span class="pre">newPlus</span></tt> are procs because they should use static binding, but <tt class="docutils literal"><span class="pre">eval</span></tt> is a method because it requires dynamic binding.</p>
<p>As can be seen in the example, base methods have to be annotated with the <span id="base_1">base</span> pragma. The <tt class="docutils literal"><span class="pre">base</span></tt> pragma also acts as a reminder for the programmer that a base method <tt class="docutils literal"><span class="pre">m</span></tt> is used as the foundation to determine all the effects that a call to <tt class="docutils literal"><span class="pre">m</span></tt> might cause.</p>
<p><strong>Note</strong>: Compile-time execution is not (yet) supported for methods.</p>
<p><strong>Note</strong>: Starting from Nim 0.20, generic methods are deprecated.</p>

<h2><a class="toc-backref" id="多方法-通过proccall禁止动态方法解析" href="#多方法-通过proccall禁止动态方法解析">通过procCall禁止动态方法解析</a></h2><p>Dynamic method resolution can be inhibited via the builtin <span id="systemdotproccall_1">system.procCall</span>. This is somewhat comparable to the <span id="super_1">super</span> keyword that traditional OOP languages offer.</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Thing</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
  <span class="Identifier">Unit</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Thing</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">method</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">base</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;base&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># Call the base method:</span>
  <span class="Identifier">procCall</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">Thing</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;1&quot;</span></pre>
<h1><a class="toc-backref" id="迭代器和for语句" href="#迭代器和for语句">迭代器和for语句</a></h1><p>The <span id="for_1">for</span> statement is an abstract mechanism to iterate over the elements of a container. It relies on an <span id="iterator_1">iterator</span> to do so. Like <tt class="docutils literal"><span class="pre">while</span></tt> statements, <tt class="docutils literal"><span class="pre">for</span></tt> statements open an <span id="implicit-block_1">implicit block</span>, so that they can be left with a <tt class="docutils literal"><span class="pre">break</span></tt> statement.</p>
<p>The <tt class="docutils literal"><span class="pre">for</span></tt> loop declares iteration variables - their scope reaches until the end of the loop body. The iteration variables' types are inferred by the return type of the iterator.</p>
<p>An iterator is similar to a procedure, except that it can be called in the context of a <tt class="docutils literal"><span class="pre">for</span></tt> loop. Iterators provide a way to specify the iteration over an abstract type. A key role in the execution of a <tt class="docutils literal"><span class="pre">for</span></tt> loop plays the <tt class="docutils literal"><span class="pre">yield</span></tt> statement in the called iterator. Whenever a <tt class="docutils literal"><span class="pre">yield</span></tt> statement is reached the data is bound to the <tt class="docutils literal"><span class="pre">for</span></tt> loop variables and control continues in the body of the <tt class="docutils literal"><span class="pre">for</span></tt> loop. The iterator's local variables and execution state are automatically saved between calls. 示例：</p>
<pre class="listing"><span class="Comment"># this definition exists in the system module</span>
<span class="Keyword">iterator</span> <span class="Identifier">items</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">char</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span>

<span class="Keyword">for</span> <span class="Identifier">ch</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="StringLit">&quot;hello world&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Comment"># `ch` is an iteration variable</span>
  <span class="Identifier">echo</span> <span class="Identifier">ch</span></pre><p>The compiler generates code as if the programmer would have written this:</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Keyword">while</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">ch</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
  <span class="Identifier">echo</span> <span class="Identifier">ch</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span></pre><p>If the iterator yields a tuple, there can be as many iteration variables as there are components in the tuple. The i'th iteration variable's type is the type of the i'th component. In other words, implicit tuple unpacking in a for loop context is supported.</p>

<h2><a class="toc-backref" id="迭代器和for语句-隐式items和pairs调用" href="#迭代器和for语句-隐式items和pairs调用">隐式items和pairs调用</a></h2><p>If the for loop expression <tt class="docutils literal"><span class="pre">e</span></tt> does not denote an iterator and the for loop has exactly 1 variable, the for loop expression is rewritten to <tt class="docutils literal"><span class="pre">items(e)</span></tt>; ie. an <tt class="docutils literal"><span class="pre">items</span></tt> iterator is implicitly invoked:</p>
<pre class="listing"><span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">,</span><span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="Identifier">x</span></pre><p>If the for loop has exactly 2 variables, a <tt class="docutils literal"><span class="pre">pairs</span></tt> iterator is implicitly invoked.</p>
<p>Symbol lookup of the identifiers <tt class="docutils literal"><span class="pre">items</span></tt>/<tt class="docutils literal"><span class="pre">pairs</span></tt> is performed after the rewriting step, so that all overloads of <tt class="docutils literal"><span class="pre">items</span></tt>/<tt class="docutils literal"><span class="pre">pairs</span></tt> are taken into account.</p>

<h2><a class="toc-backref" id="迭代器和for语句-第一类迭代器" href="#迭代器和for语句-第一类迭代器">第一类迭代器</a></h2><p>There are 2 kinds of iterators in Nim: <em>inline</em> and <em>closure</em> iterators. An <span id="inline-iterator_1">inline iterator</span> is an iterator that's always inlined by the compiler leading to zero overhead for the abstraction, but may result in a heavy increase in code size.</p>
<p>Caution: the body of a for loop over an inline iterator is inlined into each <tt class="docutils literal"><span class="pre">yield</span></tt> statement appearing in the iterator code, so ideally the code should be refactored to contain a single yield when possible to avoid code bloat.</p>
<p>Inline iterators are second class citizens; They can be passed as parameters only to other inlining code facilities like templates, macros and other inline iterators.</p>
<p>In contrast to that, a <span id="closure-iterator_1">closure iterator</span> can be passed around more freely:</p>
<pre class="listing"><span class="Keyword">iterator</span> <span class="Identifier">count0</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">yield</span> <span class="DecNumber">0</span>

<span class="Keyword">iterator</span> <span class="Identifier">count2</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Keyword">yield</span> <span class="Identifier">x</span>
  <span class="Identifier">inc</span> <span class="Identifier">x</span>
  <span class="Keyword">yield</span> <span class="Identifier">x</span>

<span class="Keyword">proc</span> <span class="Identifier">invoke</span><span class="Punctuation">(</span><span class="Identifier">iter</span><span class="Punctuation">:</span> <span class="Keyword">iterator</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Identifier">iter</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="Identifier">x</span>

<span class="Identifier">invoke</span><span class="Punctuation">(</span><span class="Identifier">count0</span><span class="Punctuation">)</span>
<span class="Identifier">invoke</span><span class="Punctuation">(</span><span class="Identifier">count2</span><span class="Punctuation">)</span></pre><p>Closure iterators and inline iterators have some restrictions:</p>
<ol class="simple"><li>For now, a closure iterator cannot be executed at compile time.</li>
<li><tt class="docutils literal"><span class="pre">return</span></tt> is allowed in a closure iterator but not in an inline iterator (but rarely useful) and ends the iteration.</li>
<li>Neither inline nor closure iterators can be recursive.</li>
<li>Neither inline nor closure iterators have the special <tt class="docutils literal"><span class="pre">result</span></tt> variable.</li>
<li>Closure iterators are not supported by the js backend.</li>
</ol>
<p>Iterators that are neither marked <tt class="docutils literal"><span class="pre">{.closure.}</span></tt> nor <tt class="docutils literal"><span class="pre">{.inline.}</span></tt> explicitly default to being inline, but this may change in future versions of the implementation.</p>
<p>The <tt class="docutils literal"><span class="pre">iterator</span></tt> type is always of the calling convention <tt class="docutils literal"><span class="pre">closure</span></tt> implicitly; the following example shows how to use iterators to implement a <span id="collaborative-tasking_1">collaborative tasking</span> system:</p>
<pre class="listing"><span class="Comment"># simple tasking:</span>
<span class="Keyword">type</span>
  <span class="Identifier">Task</span> <span class="Operator">=</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span>

<span class="Keyword">iterator</span> <span class="Identifier">a1</span><span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: A&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: B&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: C&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: D&quot;</span>

<span class="Keyword">iterator</span> <span class="Identifier">a2</span><span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a2: A&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a2: B&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a2: C&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">runTasks</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">Task</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">ticker</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">ticker</span> <span class="Keyword">mod</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">]</span>
    <span class="Keyword">if</span> <span class="Identifier">finished</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">break</span>
    <span class="Identifier">x</span><span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">)</span>
    <span class="Identifier">inc</span> <span class="Identifier">ticker</span>

<span class="Identifier">runTasks</span><span class="Punctuation">(</span><span class="Identifier">a1</span><span class="Punctuation">,</span> <span class="Identifier">a2</span><span class="Punctuation">)</span></pre><p>The builtin <tt class="docutils literal"><span class="pre">system.finished</span></tt> can be used to determine if an iterator has finished its operation; no exception is raised on an attempt to invoke an iterator that has already finished its work.</p>
<p>Note that <tt class="docutils literal"><span class="pre">system.finished</span></tt> is error prone to use because it only returns <tt class="docutils literal"><span class="pre">true</span></tt> one iteration after the iterator has finished:</p>
<pre class="listing"><span class="Keyword">iterator</span> <span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Keyword">while</span> <span class="Identifier">x</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Identifier">x</span>
    <span class="Identifier">inc</span> <span class="Identifier">x</span>

<span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">mycount</span> <span class="Comment"># instantiate the iterator</span>
<span class="Keyword">while</span> <span class="Keyword">not</span> <span class="Identifier">finished</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">c</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>

<span class="Comment"># Produces</span>
<span class="DecNumber">1</span>
<span class="DecNumber">2</span>
<span class="DecNumber">3</span>
<span class="DecNumber">0</span></pre><p>Instead this code has to be used:</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">mycount</span> <span class="Comment"># instantiate the iterator</span>
<span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">value</span> <span class="Operator">=</span> <span class="Identifier">c</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>
  <span class="Keyword">if</span> <span class="Identifier">finished</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">break</span> <span class="Comment"># and discard 'value'!</span>
  <span class="Identifier">echo</span> <span class="Identifier">value</span></pre><p>It helps to think that the iterator actually returns a pair <tt class="docutils literal"><span class="pre">(value, done)</span></tt> and <tt class="docutils literal"><span class="pre">finished</span></tt> is used to access the hidden <tt class="docutils literal"><span class="pre">done</span></tt> field.</p>
<p>Closure iterators are <em>resumable functions</em> and so one has to provide the arguments to every call. To get around this limitation one can capture parameters of an outer factory proc:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span>
    <span class="Keyword">while</span> <span class="Identifier">x</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
      <span class="Keyword">yield</span> <span class="Identifier">x</span>
      <span class="Identifier">inc</span> <span class="Identifier">x</span>

<span class="Keyword">let</span> <span class="Identifier">foo</span> <span class="Operator">=</span> <span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span>

<span class="Keyword">for</span> <span class="Identifier">f</span> <span class="Keyword">in</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">f</span></pre>
<h1><a class="toc-backref" id="转换器" href="#转换器">转换器</a></h1><p>A converter is like an ordinary proc except that it enhances the &quot;implicitly convertible&quot; type relation (see <a class="reference external" href="#convertible-relation">Convertible relation</a>):</p>
<pre class="listing"><span class="Comment"># bad style ahead: Nim is not C.</span>
<span class="Keyword">converter</span> <span class="Identifier">toBool</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">!=</span> <span class="DecNumber">0</span>

<span class="Keyword">if</span> <span class="DecNumber">4</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;compiles&quot;</span></pre><p>A converter can also be explicitly invoked for improved readability. Note that implicit converter chaining is not supported: If there is a converter from type A to type B and from type B to type C the implicit conversion from A to C is not provided.</p>

<h1><a class="toc-backref" id="type段" href="#type段">Type段</a></h1><p>示例：</p>
<pre class="listing"><span class="Keyword">type</span> <span class="Comment"># example demonstrating mutually recursive types</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>  <span class="Comment"># an object managed by the garbage collector (ref)</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>     <span class="Comment"># left and right subtrees</span>
    <span class="Identifier">sym</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Sym</span>     <span class="Comment"># leaves contain a reference to a Sym</span>
  
  <span class="Identifier">Sym</span> <span class="Operator">=</span> <span class="Keyword">object</span>       <span class="Comment"># a symbol</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>     <span class="Comment"># the symbol's name</span>
    <span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">int</span>        <span class="Comment"># the line the symbol was declared in</span>
    <span class="Identifier">code</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>       <span class="Comment"># the symbol's abstract syntax tree</span></pre><p>A type section begins with the <tt class="docutils literal"><span class="pre">type</span></tt> keyword. It contains multiple type definitions. A type definition binds a type to a name. Type definitions can be recursive or even mutually recursive. Mutually recursive types are only possible within a single <tt class="docutils literal"><span class="pre">type</span></tt> section. Nominal types like <tt class="docutils literal"><span class="pre">objects</span></tt> or <tt class="docutils literal"><span class="pre">enums</span></tt> can only be defined in a <tt class="docutils literal"><span class="pre">type</span></tt> section.</p>

<h1><a class="toc-backref" id="异常处理" href="#异常处理">异常处理</a></h1>
<h2><a class="toc-backref" id="异常处理-try语句" href="#异常处理-try语句">Try语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Comment"># read the first two lines of a text file that should contain numbers</span>
<span class="Comment"># and tries to add them</span>
<span class="Keyword">var</span>
  <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
<span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;sum: &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Punctuation">(</span><span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">OverflowError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;overflow!&quot;</span>
  <span class="Keyword">except</span> <span class="Identifier">ValueError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;could not convert string to integer&quot;</span>
  <span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;IO error!&quot;</span>
  <span class="Keyword">except</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;Unknown exception!&quot;</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span>
    <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span></pre><p>The statements after the <tt class="docutils literal"><span class="pre">try</span></tt> are executed in sequential order unless an exception <tt class="docutils literal"><span class="pre">e</span></tt> is raised. If the exception type of <tt class="docutils literal"><span class="pre">e</span></tt> matches any listed in an <tt class="docutils literal"><span class="pre">except</span></tt> clause the corresponding statements are executed. The statements following the <tt class="docutils literal"><span class="pre">except</span></tt> clauses are called <span id="exception-handlers_1">exception handlers</span>.</p>
<p>The empty <span id="except_1">except</span> clause is executed if there is an exception that is not listed otherwise. It is similar to an <tt class="docutils literal"><span class="pre">else</span></tt> clause in <tt class="docutils literal"><span class="pre">if</span></tt> statements.</p>
<p>If there is a <span id="finally_1">finally</span> clause, it is always executed after the exception handlers.</p>
<p>The exception is <em>consumed</em> in an exception handler. However, an exception handler may raise another exception. If the exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a <tt class="docutils literal"><span class="pre">finally</span></tt> clause - is not executed (if an exception occurs).</p>

<h2><a class="toc-backref" id="异常处理-try表达式" href="#异常处理-try表达式">Try表达式</a></h2><p>Try can also be used as an expression; the type of the <tt class="docutils literal"><span class="pre">try</span></tt> branch then needs to fit the types of <tt class="docutils literal"><span class="pre">except</span></tt> branches, but the type of the <tt class="docutils literal"><span class="pre">finally</span></tt> branch always has to be <tt class="docutils literal"><span class="pre">void</span></tt>:</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Keyword">try</span><span class="Punctuation">:</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="StringLit">&quot;133a&quot;</span><span class="Punctuation">)</span>
        <span class="Keyword">except</span><span class="Punctuation">:</span> <span class="Operator">-</span><span class="DecNumber">1</span>
        <span class="Keyword">finally</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;hi&quot;</span></pre><p>To prevent confusing code there is a parsing limitation; if the <tt class="docutils literal"><span class="pre">try</span></tt> follows a <tt class="docutils literal"><span class="pre">(</span></tt> it has to be written as a one liner:</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">try</span><span class="Punctuation">:</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="StringLit">&quot;133a&quot;</span><span class="Punctuation">)</span> <span class="Keyword">except</span><span class="Punctuation">:</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="异常处理-排除从句" href="#异常处理-排除从句">排除从句</a></h2><p>Within an <tt class="docutils literal"><span class="pre">except</span></tt> clause it is possible to access the current exception using the following syntax:</p>
<pre class="listing"><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span> <span class="Identifier">IOError</span> <span class="Keyword">as</span> <span class="Identifier">e</span><span class="Punctuation">:</span>
  <span class="Comment"># Now use &quot;e&quot;</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;I/O error: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">msg</span></pre><p>Alternatively, it is possible to use <tt class="docutils literal"><span class="pre">getCurrentException</span></tt> to retrieve the exception that has been raised:</p>
<pre class="listing"><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">e</span> <span class="Operator">=</span> <span class="Identifier">getCurrentException</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Comment"># Now use &quot;e&quot;</span></pre><p>Note that <tt class="docutils literal"><span class="pre">getCurrentException</span></tt> always returns a <tt class="docutils literal"><span class="pre">ref Exception</span></tt> type. If a variable of the proper type is needed (in the example above, <tt class="docutils literal"><span class="pre">IOError</span></tt>), one must convert it explicitly:</p>
<pre class="listing"><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">e</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">ref</span> <span class="Identifier">IOError</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="Identifier">getCurrentException</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Comment"># &quot;e&quot; is now of the proper type</span></pre><p>However, this is seldom needed. The most common case is to extract an error message from <tt class="docutils literal"><span class="pre">e</span></tt>, and for such situations it is enough to use <tt class="docutils literal"><span class="pre">getCurrentExceptionMsg</span></tt>:</p>
<pre class="listing"><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">getCurrentExceptionMsg</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="异常处理-defer语句" href="#异常处理-defer语句">Defer语句</a></h2><p>Instead of a <tt class="docutils literal"><span class="pre">try finally</span></tt> statement a <tt class="docutils literal"><span class="pre">defer</span></tt> statement can be used.</p>
<p>Any statements following the <tt class="docutils literal"><span class="pre">defer</span></tt> in the current block will be considered to be in an implicit try block:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">defer</span><span class="Punctuation">:</span> <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
  <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;abc&quot;</span>
  <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;def&quot;</span></pre><p>Is rewritten to:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;abc&quot;</span>
    <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;def&quot;</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span>
    <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span></pre><p>Top level <tt class="docutils literal"><span class="pre">defer</span></tt> statements are not supported since it's unclear what such a statement should refer to.</p>

<h2><a class="toc-backref" id="异常处理-raise语句" href="#异常处理-raise语句">Raise语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">raise</span> <span class="Identifier">newEOS</span><span class="Punctuation">(</span><span class="StringLit">&quot;operating system failed&quot;</span><span class="Punctuation">)</span></pre><p>Apart from built-in operations like array indexing, memory allocation, etc. the <tt class="docutils literal"><span class="pre">raise</span></tt> statement is the only way to raise an exception.</p>
<p>If no exception name is given, the current exception is <span id="reminusraised_1">re-raised</span>. The <span id="reraiseerror_1">ReraiseError</span> exception is raised if there is no exception to re-raise. It follows that the <tt class="docutils literal"><span class="pre">raise</span></tt> statement <em>always</em> raises an exception.</p>

<h2><a class="toc-backref" id="异常处理-异常层级" href="#异常处理-异常层级">异常层级</a></h2><p>The exception tree is defined in the <a class="reference external" href="system.html">system</a> module. Every exception inherits from <tt class="docutils literal"><span class="pre">system.Exception</span></tt>. Exceptions that indicate programming bugs inherit from <tt class="docutils literal"><span class="pre">system.Defect</span></tt> (which is a subtype of <tt class="docutils literal"><span class="pre">Exception</span></tt>) and are stricly speaking not catchable as they can also be mapped to an operation that terminates the whole process. Exceptions that indicate any other runtime error that can be caught inherit from <tt class="docutils literal"><span class="pre">system.CatchableError</span></tt> (which is a subtype of <tt class="docutils literal"><span class="pre">Exception</span></tt>).</p>

<h2><a class="toc-backref" id="异常处理-导入的异常" href="#异常处理-导入的异常">导入的异常</a></h2><p>It is possible to raise/catch imported C++ exceptions. Types imported using <tt class="docutils literal"><span class="pre">importcpp</span></tt> can be raised or caught. Exceptions are raised by value and caught by reference. 示例：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">std_exception</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;std::exception&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;exception&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>

<span class="Keyword">proc</span> <span class="Identifier">what</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">std_exception</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;((char *)#.what())&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Keyword">raise</span> <span class="Identifier">std_exception</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">except</span> <span class="Identifier">std_exception</span> <span class="Keyword">as</span> <span class="Identifier">ex</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">ex</span><span class="Operator">.</span><span class="Identifier">what</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h1><a class="toc-backref" id="效应系统" href="#效应系统">效应系统</a></h1>
<h2><a class="toc-backref" id="效应系统-异常跟踪" href="#效应系统-异常跟踪">异常跟踪</a></h2><p>Nim supports exception tracking. The <span id="raises_1">raises</span> pragma can be used to explicitly define which exceptions a proc/iterator/method/converter is allowed to raise. The compiler verifies this:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">what</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="Identifier">OSError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">what</span><span class="Punctuation">:</span> <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;OS&quot;</span><span class="Punctuation">)</span></pre><p>An empty <tt class="docutils literal"><span class="pre">raises</span></tt> list (<tt class="docutils literal"><span class="pre">raises: []</span></tt>) means that no exception may be raised:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Identifier">unsafeCall</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Keyword">except</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span></pre><p>A <tt class="docutils literal"><span class="pre">raises</span></tt> list can also be attached to a proc type. This affects type compatibility:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Callback</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span>
  <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Callback</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;OS&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">p</span> <span class="Comment"># type error</span></pre><p>For a routine <tt class="docutils literal"><span class="pre">p</span></tt> the compiler uses inference rules to determine the set of possibly raised exceptions; the algorithm operates on <tt class="docutils literal"><span class="pre">p</span></tt>'s call graph:</p>
<ol class="simple"><li>Every indirect call via some proc type <tt class="docutils literal"><span class="pre">T</span></tt> is assumed to raise <tt class="docutils literal"><span class="pre">system.Exception</span></tt> (the base type of the exception hierarchy) and thus any exception unless <tt class="docutils literal"><span class="pre">T</span></tt> has an explicit <tt class="docutils literal"><span class="pre">raises</span></tt> list. However if the call is of the form <tt class="docutils literal"><span class="pre">f(...)</span></tt> where <tt class="docutils literal"><span class="pre">f</span></tt> is a parameter of the currently analysed routine it is ignored. The call is optimistically assumed to have no effect. Rule 2 compensates for this case.</li>
<li>Every expression of some proc type within a call that is not a call itself (and not nil) is assumed to be called indirectly somehow and thus its raises list is added to <tt class="docutils literal"><span class="pre">p</span></tt>'s raises list.</li>
<li>Every call to a proc <tt class="docutils literal"><span class="pre">q</span></tt> which has an unknown body (due to a forward declaration or an <tt class="docutils literal"><span class="pre">importc</span></tt> pragma) is assumed to raise <tt class="docutils literal"><span class="pre">system.Exception</span></tt> unless <tt class="docutils literal"><span class="pre">q</span></tt> has an explicit <tt class="docutils literal"><span class="pre">raises</span></tt> list.</li>
<li>Every call to a method <tt class="docutils literal"><span class="pre">m</span></tt> is assumed to raise <tt class="docutils literal"><span class="pre">system.Exception</span></tt> unless <tt class="docutils literal"><span class="pre">m</span></tt> has an explicit <tt class="docutils literal"><span class="pre">raises</span></tt> list.</li>
<li>For every other call the analysis can determine an exact <tt class="docutils literal"><span class="pre">raises</span></tt> list.</li>
<li>For determining a <tt class="docutils literal"><span class="pre">raises</span></tt> list, the <tt class="docutils literal"><span class="pre">raise</span></tt> and <tt class="docutils literal"><span class="pre">try</span></tt> statements of <tt class="docutils literal"><span class="pre">p</span></tt> are taken into consideration.</li>
</ol>
<p>Rules 1-2 ensure the following works:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">noRaise</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># unknown call that might raise anything, but valid:</span>
  <span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">doRaise</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">use</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># doesn't compile! Can raise IOError!</span>
  <span class="Identifier">noRaise</span><span class="Punctuation">(</span><span class="Identifier">doRaise</span><span class="Punctuation">)</span></pre><p>So in many cases a callback does not cause the compiler to be overly conservative in its effect analysis.</p>

<h2><a class="toc-backref" id="效应系统-tag跟踪" href="#效应系统-tag跟踪">Tag跟踪</a></h2><p>The exception tracking is part of Nim's <span id="effect-system_1">effect system</span>. Raising an exception is an <em>effect</em>. Other effects can also be defined. A user defined effect is a means to <em>tag</em> a routine and to perform checks against this tag:</p>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">IO</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Comment">## input/output effect</span>
<span class="Keyword">proc</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">tags</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IO</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Keyword">proc</span> <span class="Identifier">no_IO_please</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">tags</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># the compiler prevents this:</span>
  <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>A tag has to be a type name. A <tt class="docutils literal"><span class="pre">tags</span></tt> list - like a <tt class="docutils literal"><span class="pre">raises</span></tt> list - can also be attached to a proc type. This affects type compatibility.</p>
<p>The inference for tag tracking is analogous to the inference for exception tracking.</p>

<h2><a class="toc-backref" id="效应系统-effects编译指示" href="#效应系统-effects编译指示">Effects编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">effects</span></tt> pragma has been designed to assist the programmer with the effects analysis. It is a statement that makes the compiler output all inferred effects up to the <tt class="docutils literal"><span class="pre">effects</span></tt>'s position:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">what</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">what</span><span class="Punctuation">:</span>
    <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">effects</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;OS&quot;</span><span class="Punctuation">)</span></pre><p>The compiler produces a hint message that <tt class="docutils literal"><span class="pre">IOError</span></tt> can be raised. <tt class="docutils literal"><span class="pre">OSError</span></tt> is not listed as it cannot be raised in the branch the <tt class="docutils literal"><span class="pre">effects</span></tt> pragma appears in.</p>

<h1><a class="toc-backref" id="泛型" href="#泛型">泛型</a></h1><p>Generics are Nim's means to parametrize procs, iterators or types with <span id="type-parameters_1">type parameters</span>. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type.</p>
<p>The following example shows a generic binary tree can be modelled:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">BinaryTree</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Comment"># BinaryTree is a generic type with</span>
                              <span class="Comment"># generic param ``T``</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span>     <span class="Comment"># left and right subtrees; may be nil</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span>                   <span class="Comment"># the data stored in a node</span>

<span class="Keyword">proc</span> <span class="Identifier">newNode</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Comment"># constructor for a node</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">le</span><span class="Punctuation">:</span> <span class="Keyword">nil</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Keyword">nil</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">data</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># insert a node into the tree</span>
  <span class="Keyword">if</span> <span class="Identifier">root</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Identifier">root</span> <span class="Operator">=</span> <span class="Identifier">n</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">root</span>
    <span class="Keyword">while</span> <span class="Identifier">it</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Comment"># compare the data items; uses the generic ``cmp`` proc</span>
      <span class="Comment"># that works for any type that has a ``==`` and ``&lt;`` operator</span>
      <span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span>
      <span class="Keyword">if</span> <span class="Identifier">c</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span>
      <span class="Keyword">else</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># convenience proc:</span>
  <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">iterator</span> <span class="Identifier">preorder</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Comment"># Preorder traversal of a binary tree.</span>
  <span class="Comment"># Since recursive iterators are not yet implemented,</span>
  <span class="Comment"># this uses an explicit stack (which is more efficient anyway):</span>
  <span class="Keyword">var</span> <span class="Identifier">stack</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="Identifier">root</span><span class="Punctuation">]</span>
  <span class="Keyword">while</span> <span class="Identifier">stack</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&gt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">stack</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Keyword">while</span> <span class="Identifier">n</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Keyword">yield</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span>
      <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">stack</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">ri</span><span class="Punctuation">)</span>  <span class="Comment"># push right subtree onto the stack</span>
      <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">le</span>          <span class="Comment"># and follow the left pointer</span>

<span class="Keyword">var</span>
  <span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Comment"># instantiate a BinaryTree with ``string``</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;hello&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># instantiates ``newNode`` and ``add``</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="StringLit">&quot;world&quot;</span><span class="Punctuation">)</span>          <span class="Comment"># instantiates the second ``add`` proc</span>
<span class="Keyword">for</span> <span class="Identifier">str</span> <span class="Keyword">in</span> <span class="Identifier">preorder</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">str</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">T</span></tt> is called a <span id="generic-type-parameter_1">generic type parameter</span> or a <span id="type-variable_1">type variable</span>.</p>

<h2><a class="toc-backref" id="泛型-is操作符" href="#泛型-is操作符">Is操作符</a></h2><p>The <tt class="docutils literal"><span class="pre">is</span></tt> operator is evaluated during semantic analysis to check for type equivalence. It is therefore very useful for type specialization within generic code:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">,</span> <span class="Identifier">Value</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">keys</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">]</span>
    <span class="Identifier">values</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Value</span><span class="Punctuation">]</span>
    <span class="Keyword">when</span> <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">Key</span> <span class="Keyword">is</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Comment"># empty value for strings used for optimization</span>
      <span class="Identifier">deletedKeys</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">bool</span><span class="Punctuation">]</span></pre>
<h2><a class="toc-backref" id="泛型-类型类别" href="#泛型-类型类别">类型类别</a></h2><p>A type class is a special pseudo-type that can be used to match against types in the context of overload resolution or the <tt class="docutils literal"><span class="pre">is</span></tt> operator. Nim supports the following built-in type classes:</p>
<table border="1" class="docutils"><tr><th>type class</th><th>matches</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">object</span></tt></td><td>any object type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">tuple</span></tt></td><td>any tuple type</td></tr>
<tr><td></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">enum</span></tt></td><td>any enumeration</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">proc</span></tt></td><td>any proc type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">ref</span></tt></td><td>any <tt class="docutils literal"><span class="pre">ref</span></tt> type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">ptr</span></tt></td><td>any <tt class="docutils literal"><span class="pre">ptr</span></tt> type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">var</span></tt></td><td>any <tt class="docutils literal"><span class="pre">var</span></tt> type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">distinct</span></tt></td><td>any distinct type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">array</span></tt></td><td>any array type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">set</span></tt></td><td>any set type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">seq</span></tt></td><td>any seq type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">auto</span></tt></td><td>any type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">any</span></tt></td><td>distinct auto (see below)</td></tr>
</table><p>Furthermore, every generic type automatically creates a type class of the same name that will match any instantiation of the generic type.</p>
<p>Type classes can be combined using the standard boolean operators to form more complex type classes:</p>
<pre class="listing"><span class="Comment"># create a type class that will match all tuple and object types</span>
<span class="Keyword">type</span> <span class="Identifier">RecordType</span> <span class="Operator">=</span> <span class="Keyword">tuple</span> <span class="Keyword">or</span> <span class="Keyword">object</span>

<span class="Keyword">proc</span> <span class="Identifier">printFields</span><span class="Punctuation">(</span><span class="Identifier">rec</span><span class="Punctuation">:</span> <span class="Identifier">RecordType</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">key</span><span class="Punctuation">,</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Identifier">fieldPairs</span><span class="Punctuation">(</span><span class="Identifier">rec</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">key</span><span class="Punctuation">,</span> <span class="StringLit">&quot; = &quot;</span><span class="Punctuation">,</span> <span class="Identifier">value</span></pre><p>Procedures utilizing type classes in such manner are considered to be <span id="implicitly-generic_1">implicitly generic</span>. They will be instantiated once for each unique combination of param types used within the program.</p>
<p>Whilst the syntax of type classes appears to resemble that of ADTs/algebraic data types in ML-like languages, it should be understood that type classes are static constraints to be enforced at type instantations. Type classes are not really types in themsleves, but are instead a system of providing generic &quot;checks&quot; that ultimately <em>resolve</em> to some singular type. Type classes do not allow for runtime type dynamism, unlike object variants or methods.</p>
<p>As an example, the following would not compile:</p>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">TypeClass</span> <span class="Operator">=</span> <span class="Identifier">int</span> <span class="Operator">|</span> <span class="Identifier">string</span>
<span class="Keyword">var</span> <span class="Identifier">foo</span><span class="Punctuation">:</span> <span class="Identifier">TypeClass</span> <span class="Operator">=</span> <span class="DecNumber">2</span> <span class="Comment"># foo's type is resolved to an int here</span>
<span class="Identifier">foo</span> <span class="Operator">=</span> <span class="StringLit">&quot;this will fail&quot;</span> <span class="Comment"># error here, because foo is an int</span></pre><p>Nim allows for type classes and regular types to be specified as <span id="type-constraints_1">type constraints</span> of the generic type parameter:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">onlyIntOrString</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Operator">|</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">onlyIntOrString</span><span class="Punctuation">(</span><span class="DecNumber">450</span><span class="Punctuation">,</span> <span class="DecNumber">616</span><span class="Punctuation">)</span> <span class="Comment"># valid</span>
<span class="Identifier">onlyIntOrString</span><span class="Punctuation">(</span><span class="FloatNumber">5.0</span><span class="Punctuation">,</span> <span class="FloatNumber">0.0</span><span class="Punctuation">)</span> <span class="Comment"># type mismatch</span>
<span class="Identifier">onlyIntOrString</span><span class="Punctuation">(</span><span class="StringLit">&quot;xy&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">50</span><span class="Punctuation">)</span> <span class="Comment"># invalid as 'T' cannot be both at the same time</span></pre><p>By default, during overload resolution each named type class will bind to exactly one concrete type. We call such type classes <span id="bind-once_1">bind once</span> types. Here is an example taken directly from the system module to illustrate this:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Comment">## requires `x` and `y` to be of the same tuple type</span>
  <span class="Comment">## generic ``==`` operator for tuples that is lifted from the components</span>
  <span class="Comment">## of `x` and `y`.</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Keyword">for</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Identifier">fields</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">if</span> <span class="Identifier">a</span> <span class="Operator">!=</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span></pre><p>Alternatively, the <tt class="docutils literal"><span class="pre">distinct</span></tt> type modifier can be applied to the type class to allow each param matching the type class to bind to a different type. Such type classes are called <span id="bind-many_1">bind many</span> types.</p>
<p>Procs written with the implicitly generic style will often need to refer to the type parameters of the matched generic type. They can be easily accessed using the dot syntax:</p>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">,</span> <span class="Identifier">Rows</span><span class="Punctuation">,</span> <span class="Identifier">Columns</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">m</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">,</span> <span class="Identifier">row</span><span class="Punctuation">,</span> <span class="Identifier">col</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Operator">.</span><span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">[</span><span class="Identifier">col</span> <span class="Operator">*</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">Matrix</span><span class="Operator">.</span><span class="Identifier">Columns</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">row</span><span class="Punctuation">]</span></pre><p>Alternatively, the <tt class="docutils literal"><span class="pre">type</span></tt> operator can be used over the proc params for similar effect when anonymous or distinct type classes are used.</p>
<p>When a generic type is instantiated with a type class instead of a concrete type, this results in another more specific type class:</p>
<pre class="listing"><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Keyword">ref</span> <span class="Keyword">object</span><span class="Punctuation">]</span>  <span class="Comment"># Any sequence storing references to any object type</span>

<span class="Keyword">type</span> <span class="Identifier">T1</span> <span class="Operator">=</span> <span class="Identifier">auto</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">T1</span><span class="Punctuation">)</span>
  <span class="Comment"># seq[T1] is the same as just `seq`, but T1 will be allowed to bind</span>
  <span class="Comment"># to a single type, while the signature is being matched</span>

<span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="Identifier">Ordinal</span><span class="Punctuation">]</span> <span class="Comment"># Any Matrix instantiation using integer values</span></pre><p>As seen in the previous example, in such instantiations, it's not necessary to supply all type parameters of the generic type, because any missing ones will be inferred to have the equivalent of the <tt class="docutils literal"><span class="pre">any</span></tt> type class and thus they will match anything without discrimination.</p>

<h2><a class="toc-backref" id="泛型-泛型推导限制" href="#泛型-泛型推导限制">泛型推导限制</a></h2><p>The types <tt class="docutils literal"><span class="pre">var T</span></tt> and <tt class="docutils literal"><span class="pre">typedesc[T]</span></tt> cannot be inferred in a generic instantiation. The following is not allowed:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">g</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">;</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">c</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="Identifier">y</span>
<span class="Keyword">proc</span> <span class="Identifier">v</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">y</span> <span class="Operator">+=</span> <span class="DecNumber">100</span>
<span class="Keyword">var</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Comment"># allowed: infers 'T' to be of type 'int'</span>
<span class="Identifier">g</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="DecNumber">42</span><span class="Punctuation">)</span>

<span class="Comment"># not valid: 'T' is not inferred to be of type 'var int'</span>
<span class="Identifier">g</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">)</span>

<span class="Comment"># also not allowed: explict instantiation via 'var int'</span>
<span class="Identifier">g</span><span class="Punctuation">[</span><span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="泛型-泛型符号查找" href="#泛型-泛型符号查找">泛型符号查找</a></h2>
<h3><a class="toc-backref" id="泛型符号查找-开放和关闭的符号" href="#泛型符号查找-开放和关闭的符号">开放和关闭的符号</a></h3><p>The symbol binding rules in generics are slightly subtle: There are &quot;open&quot; and &quot;closed&quot; symbols. A &quot;closed&quot; symbol cannot be re-bound in the instantiation context, an &quot;open&quot; symbol can. Per default overloaded symbols are open and every other symbol is closed.</p>
<p>Open symbols are looked up in two different contexts: Both the context at definition and the context at instantiation are considered:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Index</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Index</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="FloatNumber">0.</span><span class="Identifier">Index</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="FloatNumber">0.</span><span class="Identifier">Index</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span> <span class="Comment"># works!</span></pre><p>In the example the generic <tt class="docutils literal"><span class="pre">==</span></tt> for tuples (as defined in the system module) uses the <tt class="docutils literal"><span class="pre">==</span></tt> operators of the tuple's components. However, the <tt class="docutils literal"><span class="pre">==</span></tt> for the <tt class="docutils literal"><span class="pre">Index</span></tt> type is defined <em>after</em> the <tt class="docutils literal"><span class="pre">==</span></tt> for tuples; yet the example compiles as the instantiation takes the currently defined symbols into account too.</p>

<h2><a class="toc-backref" id="泛型-mixin语句" href="#泛型-mixin语句">Mixin语句</a></h2><p>A symbol can be forced to be open by a <span id="mixin_1">mixin</span> declaration:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">create</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Comment"># there is no overloaded 'init' here, so we need to state that it's an</span>
  <span class="Comment"># open symbol explicitly:</span>
  <span class="Keyword">mixin</span> <span class="Identifier">init</span>
  <span class="Identifier">new</span> <span class="Identifier">result</span>
  <span class="Identifier">init</span> <span class="Identifier">result</span></pre><p><tt class="docutils literal"><span class="pre">mixin</span></tt> 语句只在模板和泛型中有意义。</p>

<h2><a class="toc-backref" id="泛型-bind语句" href="#泛型-bind语句">Bind语句</a></h2><p>The <tt class="docutils literal"><span class="pre">bind</span></tt> statement is the counterpart to the <tt class="docutils literal"><span class="pre">mixin</span></tt> statement. It can be used to explicitly declare identifiers that should be bound early (i.e. the identifiers should be looked up in the scope of the template/generic definition):</p>
<pre class="listing"><span class="Comment"># Module A</span>
<span class="Keyword">var</span>
  <span class="Identifier">lastId</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">template</span> <span class="Identifier">genId</span><span class="Operator">*:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Keyword">bind</span> <span class="Identifier">lastId</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">lastId</span><span class="Punctuation">)</span>
  <span class="Identifier">lastId</span></pre><pre class="listing"><span class="Comment"># Module B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>

<span class="Identifier">echo</span> <span class="Identifier">genId</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>But a <tt class="docutils literal"><span class="pre">bind</span></tt> is rarely useful because symbol binding from the definition scope is the default.</p>
<p><tt class="docutils literal"><span class="pre">bind</span></tt> statements only make sense in templates and generics.</p>

<h1><a class="toc-backref" id="模板" href="#模板">模板</a></h1><p>A template is a simple form of a macro: It is a simple substitution mechanism that operates on Nim's abstract syntax trees. It is processed in the semantic pass of the compiler.</p>
<p>The syntax to <em>invoke</em> a template is the same as calling a procedure.</p>
<p>示例：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Punctuation">`</span><span class="Operator">!=</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Comment"># this definition exists in the System module</span>
  <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="DecNumber">5</span> <span class="Operator">!=</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># the compiler rewrites that to: assert(not (5 == 6))</span></pre><p>The <tt class="docutils literal"><span class="pre">!=</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;=</span></tt>, <tt class="docutils literal"><span class="pre">in</span></tt>, <tt class="docutils literal"><span class="pre">notin</span></tt>, <tt class="docutils literal"><span class="pre">isnot</span></tt> operators are in fact templates:</p>
<p><tt class="docutils literal"><span class="pre">a &gt; b</span></tt> is transformed into <tt class="docutils literal"><span class="pre">b &lt; a</span></tt>.<br /><tt class="docutils literal"><span class="pre">a in b</span></tt> is transformed into <tt class="docutils literal"><span class="pre">contains(b, a)</span></tt>.<br /><tt class="docutils literal"><span class="pre">notin</span></tt> and <tt class="docutils literal"><span class="pre">isnot</span></tt> have the obvious meanings.<br /></p><p>The &quot;types&quot; of templates can be the symbols <tt class="docutils literal"><span class="pre">untyped</span></tt>, <tt class="docutils literal"><span class="pre">typed</span></tt> or <tt class="docutils literal"><span class="pre">typedesc</span></tt>. These are &quot;meta types&quot;, they can only be used in certain contexts. Regular types can be used too; this implies that <tt class="docutils literal"><span class="pre">typed</span></tt> expressions are expected.</p>

<h2><a class="toc-backref" id="模板-类型化和无类型形参" href="#模板-类型化和无类型形参">类型化和无类型形参</a></h2><p>An <tt class="docutils literal"><span class="pre">untyped</span></tt> parameter means that symbol lookups and type resolution is not performed before the expression is passed to the template. This means that for example <em>undeclared</em> identifiers can be passed to the template:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># valid</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">3</span></pre><pre class="listing"><span class="Keyword">template</span> <span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typed</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># invalid, because x has not been declared and so has no type</span></pre><p>A template where every parameter is <tt class="docutils literal"><span class="pre">untyped</span></tt> is called an <span id="immediate_1">immediate</span> template. For historical reasons templates can be explicitly annotated with an <tt class="docutils literal"><span class="pre">immediate</span></tt> pragma and then these templates do not take part in overloading resolution and the parameters' types are <em>ignored</em> by the compiler. Explicit immediate templates are now deprecated.</p>
<p><strong>Note</strong>: For historical reasons <tt class="docutils literal"><span class="pre">stmt</span></tt> was an alias for <tt class="docutils literal"><span class="pre">typed</span></tt> and <tt class="docutils literal"><span class="pre">expr</span></tt> was an alias for <tt class="docutils literal"><span class="pre">untyped</span></tt>, but they are removed.</p>

<h2><a class="toc-backref" id="模板-向模板传代码块" href="#模板-向模板传代码块">向模板传代码块</a></h2><p>You can pass a block of statements as the last argument to a template following the special <tt class="docutils literal"><span class="pre">:</span></tt> syntax:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">,</span> <span class="Identifier">actions</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
  <span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">actions</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;cannot open: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">fn</span><span class="Punctuation">)</span>

<span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">txt</span><span class="Punctuation">,</span> <span class="StringLit">&quot;ttempl3.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span><span class="Punctuation">:</span>  <span class="Comment"># special colon</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 1&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 2&quot;</span><span class="Punctuation">)</span></pre><p>In the example, the two <tt class="docutils literal"><span class="pre">writeLine</span></tt> statements are bound to the <tt class="docutils literal"><span class="pre">actions</span></tt> parameter.</p>
<p>Usually to pass a block of code to a template the parameter that accepts the block needs to be of type <tt class="docutils literal"><span class="pre">untyped</span></tt>. Because symbol lookups are then delayed until template instantiation time:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">(</span><span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">typed</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">block</span><span class="Punctuation">:</span>
    <span class="Identifier">body</span>

<span class="Identifier">t</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span>

<span class="Identifier">t</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">2</span>  <span class="Comment"># fails with 'attempt to redeclare i'</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span></pre><p>The above code fails with the mysterious error message that <tt class="docutils literal"><span class="pre">i</span></tt> has already been declared. The reason for this is that the <tt class="docutils literal"><span class="pre">var i = ...</span></tt> bodies need to be type-checked before they are passed to the <tt class="docutils literal"><span class="pre">body</span></tt> parameter and type checking in Nim implies symbol lookups. For the symbol lookups to succeed <tt class="docutils literal"><span class="pre">i</span></tt> needs to be added to the current (i.e. outer) scope. After type checking these additions to the symbol table are not rolled back (for better or worse). The same code works with <tt class="docutils literal"><span class="pre">untyped</span></tt> as the passed body is not required to be type-checked:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">(</span><span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">block</span><span class="Punctuation">:</span>
    <span class="Identifier">body</span>

<span class="Identifier">t</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span>

<span class="Identifier">t</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">2</span>  <span class="Comment"># compiles</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span></pre>
<h2><a class="toc-backref" id="模板-无类型可变参数" href="#模板-无类型可变参数">无类型可变参数</a></h2><p>In addition to the <tt class="docutils literal"><span class="pre">untyped</span></tt> meta-type that prevents type checking there is also <tt class="docutils literal"><span class="pre">varargs[untyped]</span></tt> so that not even the number of parameters is fixed:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">hideIdentifiers</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">untyped</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">hideIdentifiers</span><span class="Punctuation">(</span><span class="Identifier">undeclared1</span><span class="Punctuation">,</span> <span class="Identifier">undeclared2</span><span class="Punctuation">)</span></pre><p>However, since a template cannot iterate over varargs, this feature is generally much more useful for macros.</p>

<h2><a class="toc-backref" id="模板-模板符号绑定" href="#模板-模板符号绑定">模板符号绑定</a></h2><p>A template is a <span id="hygienic_1">hygienic</span> macro and so opens a new scope. Most symbols are bound from the definition scope of the template:</p>
<pre class="listing"><span class="Comment"># Module A</span>
<span class="Keyword">var</span>
  <span class="Identifier">lastId</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">template</span> <span class="Identifier">genId</span><span class="Operator">*:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">lastId</span><span class="Punctuation">)</span>
  <span class="Identifier">lastId</span></pre><pre class="listing"><span class="Comment"># Module B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>

<span class="Identifier">echo</span> <span class="Identifier">genId</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># Works as 'lastId' has been bound in 'genId's defining scope</span></pre><p>As in generics symbol binding can be influenced via <tt class="docutils literal"><span class="pre">mixin</span></tt> or <tt class="docutils literal"><span class="pre">bind</span></tt> statements.</p>

<h2><a class="toc-backref" id="模板-标识符构造" href="#模板-标识符构造">标识符构造</a></h2><p>In templates identifiers can be constructed with the backticks notation:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">typedef</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">,</span> <span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">type</span>
    <span class="Punctuation">`</span><span class="Identifier">T</span> <span class="Identifier">name</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">typ</span>
    <span class="Punctuation">`</span><span class="Identifier">P</span> <span class="Identifier">name</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Punctuation">`</span><span class="Identifier">T</span> <span class="Identifier">name</span><span class="Punctuation">`</span>

<span class="Identifier">typedef</span><span class="Punctuation">(</span><span class="Identifier">myint</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PMyInt</span></pre><p>In the example <tt class="docutils literal"><span class="pre">name</span></tt> is instantiated with <tt class="docutils literal"><span class="pre">myint</span></tt>, so `T name` becomes <tt class="docutils literal"><span class="pre">Tmyint</span></tt>.</p>

<h2><a class="toc-backref" id="模板-模板形参查询规则" href="#模板-模板形参查询规则">模板形参查询规则</a></h2><p>A parameter <tt class="docutils literal"><span class="pre">p</span></tt> in a template is even substituted in the expression <tt class="docutils literal"><span class="pre">x.p</span></tt>. Thus template arguments can be used as field names and a global symbol can be shadowed by the same argument name even when fully qualified:</p>
<pre class="listing"><span class="Comment"># module 'm'</span>

<span class="Keyword">type</span>
  <span class="Identifier">Lev</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">levA</span><span class="Punctuation">,</span> <span class="Identifier">levB</span>

<span class="Keyword">var</span> <span class="Identifier">abclev</span> <span class="Operator">=</span> <span class="Identifier">levB</span>

<span class="Keyword">template</span> <span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">abclev</span><span class="Punctuation">:</span> <span class="Identifier">Lev</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">abclev</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">abclev</span>

<span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">levA</span><span class="Punctuation">)</span>
<span class="Comment"># produces: 'levA levA'</span></pre><p>But the global symbol can properly be captured by a <tt class="docutils literal"><span class="pre">bind</span></tt> statement:</p>
<pre class="listing"><span class="Comment"># module 'm'</span>

<span class="Keyword">type</span>
  <span class="Identifier">Lev</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">levA</span><span class="Punctuation">,</span> <span class="Identifier">levB</span>

<span class="Keyword">var</span> <span class="Identifier">abclev</span> <span class="Operator">=</span> <span class="Identifier">levB</span>

<span class="Keyword">template</span> <span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">abclev</span><span class="Punctuation">:</span> <span class="Identifier">Lev</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">bind</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">abclev</span>
  <span class="Identifier">echo</span> <span class="Identifier">abclev</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">abclev</span>

<span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">levA</span><span class="Punctuation">)</span>
<span class="Comment"># produces: 'levA levB'</span></pre>
<h2><a class="toc-backref" id="模板-模板卫生" href="#模板-模板卫生">模板卫生</a></h2><p>Per default templates are <span id="hygienic_2">hygienic</span>: Local identifiers declared in a template cannot be accessed in the instantiation context:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">newException</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">exceptn</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">,</span> <span class="Identifier">message</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Keyword">var</span>
    <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">exceptn</span>  <span class="Comment"># e is implicitly gensym'ed here</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">)</span>
  <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">msg</span> <span class="Operator">=</span> <span class="Identifier">message</span>
  <span class="Identifier">e</span>

<span class="Comment"># so this works:</span>
<span class="Keyword">let</span> <span class="Identifier">e</span> <span class="Operator">=</span> <span class="StringLit">&quot;message&quot;</span>
<span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IoError</span><span class="Punctuation">,</span> <span class="Identifier">e</span><span class="Punctuation">)</span></pre><p>Whether a symbol that is declared in a template is exposed to the instantiation scope is controlled by the <span id="inject_1">inject</span> and <span id="gensym_1">gensym</span> pragmas: gensym'ed symbols are not exposed but inject'ed are.</p>
<p>The default for symbols of entity <tt class="docutils literal"><span class="pre">type</span></tt>, <tt class="docutils literal"><span class="pre">var</span></tt>, <tt class="docutils literal"><span class="pre">let</span></tt> and <tt class="docutils literal"><span class="pre">const</span></tt> is <tt class="docutils literal"><span class="pre">gensym</span></tt> and for <tt class="docutils literal"><span class="pre">proc</span></tt>, <tt class="docutils literal"><span class="pre">iterator</span></tt>, <tt class="docutils literal"><span class="pre">converter</span></tt>, <tt class="docutils literal"><span class="pre">template</span></tt>, <tt class="docutils literal"><span class="pre">macro</span></tt> is <tt class="docutils literal"><span class="pre">inject</span></tt>. However, if the name of the entity is passed as a template parameter, it is an inject'ed symbol:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">,</span> <span class="Identifier">actions</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Keyword">block</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>  <span class="Comment"># since 'f' is a template param, it's injected implicitly</span>
    <span class="Operator">...</span>

<span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">txt</span><span class="Punctuation">,</span> <span class="StringLit">&quot;ttempl3.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 1&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 2&quot;</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">inject</span></tt> and <tt class="docutils literal"><span class="pre">gensym</span></tt> pragmas are second class annotations; they have no semantics outside of a template definition and cannot be abstracted over:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span> <span class="Identifier">myInject</span><span class="Punctuation">:</span> <span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">myInject</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># does NOT work</span></pre><p>To get rid of hygiene in templates, one can use the <span id="dirty_1">dirty</span> pragma for a template. <tt class="docutils literal"><span class="pre">inject</span></tt> and <tt class="docutils literal"><span class="pre">gensym</span></tt> have no effect in <tt class="docutils literal"><span class="pre">dirty</span></tt> templates.</p>

<h2><a class="toc-backref" id="模板-方法调用语法限制" href="#模板-方法调用语法限制">方法调用语法限制</a></h2><p>The expression <tt class="docutils literal"><span class="pre">x</span></tt> in <tt class="docutils literal"><span class="pre">x.f</span></tt> needs to be semantically checked (that means symbol lookup and type checking) before it can be decided that it needs to be rewritten to <tt class="docutils literal"><span class="pre">f(x)</span></tt>. Therefore the dot syntax has some limitations when it is used to invoke templates/macros:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">declareVar</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">const</span> <span class="Identifier">name</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Comment"># Doesn't compile:</span>
<span class="Identifier">unknownIdentifier</span><span class="Operator">.</span><span class="Identifier">declareVar</span></pre><p>Another common example is this:</p>
<pre class="listing"><span class="Keyword">from</span> <span class="Identifier">sequtils</span> <span class="Keyword">import</span> <span class="Identifier">toSeq</span>

<span class="Keyword">iterator</span> <span class="Identifier">something</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Keyword">yield</span> <span class="StringLit">&quot;Hello&quot;</span>
  <span class="Keyword">yield</span> <span class="StringLit">&quot;World&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">info</span> <span class="Operator">=</span> <span class="Identifier">something</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">toSeq</span></pre><p>The problem here is that the compiler already decided that <tt class="docutils literal"><span class="pre">something()</span></tt> as an iterator is not callable in this context before <tt class="docutils literal"><span class="pre">toSeq</span></tt> gets its chance to convert it into a sequence.</p>

<h1><a class="toc-backref" id="宏" href="#宏">宏</a></h1><p>A macro is a special function that is executed at compile time. Normally the input for a macro is an abstract syntax tree (AST) of the code that is passed to it. The macro can then do transformations on it and return the transformed AST. This can be used to add custom language features and implement <span id="domain-specific-languages_1">domain specific languages</span>.</p>
<p>Macro invocation is a case where semantic analyis does <strong>not</strong> entirely proceed top to bottom and left to right. Instead, semantic analysis happens at least twice:</p>
<ul class="simple"><li>Semantic analysis recognizes and resolves the macro invocation.</li>
<li>The compiler executes the macro body (which may invoke other procs).</li>
<li>It replaces the AST of the macro invocation with the AST returned by the macro.</li>
<li>It repeats semantic analysis of that region of the code.</li>
<li>If the AST returned by the macro contains other macro invocations, this process iterates.</li>
</ul>
<p>While macros enable advanced compile-time code transformations, they cannot change Nim's syntax. However, this is no real restriction because Nim's syntax is flexible enough anyway.</p>

<h2><a class="toc-backref" id="宏-debug示例" href="#宏-debug示例">Debug示例</a></h2><p>The following example implements a powerful <tt class="docutils literal"><span class="pre">debug</span></tt> command that accepts a variable number of arguments:</p>
<pre class="listing"><span class="Comment"># to work with Nim syntax trees, we need an API that is defined in the</span>
<span class="Comment"># ``macros`` module:</span>
<span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">args</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">untyped</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Comment"># `args` is a collection of `NimNode` values that each contain the</span>
  <span class="Comment"># AST for an argument of the macro. A macro always has to</span>
  <span class="Comment"># return a `NimNode`. A node of kind `nnkStmtList` is suitable for</span>
  <span class="Comment"># this use case.</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">nnkStmtList</span><span class="Operator">.</span><span class="Identifier">newTree</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Comment"># iterate over any argument that is passed to this macro:</span>
  <span class="Keyword">for</span> <span class="Identifier">n</span> <span class="Keyword">in</span> <span class="Identifier">args</span><span class="Punctuation">:</span>
    <span class="Comment"># add a call to the statement list that writes the expression;</span>
    <span class="Comment"># `toStrLit` converts an AST to its string representation:</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;write&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">repr</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Comment"># add a call to the statement list that writes &quot;: &quot;</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;write&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Comment"># add a call to the statement list that writes the expressions value:</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;writeLine&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>The macro call expands to:</p>
<pre class="listing"><span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[0]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[1]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;x&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>Arguments that are passed to a <tt class="docutils literal"><span class="pre">varargs</span></tt> parameter are wrapped in an array constructor expression. This is why <tt class="docutils literal"><span class="pre">debug</span></tt> iterates over all of <tt class="docutils literal"><span class="pre">n</span></tt>'s children.</p>

<h2><a class="toc-backref" id="宏-bindsym" href="#宏-bindsym">BindSym</a></h2><p>The above <tt class="docutils literal"><span class="pre">debug</span></tt> macro relies on the fact that <tt class="docutils literal"><span class="pre">write</span></tt>, <tt class="docutils literal"><span class="pre">writeLine</span></tt> and <tt class="docutils literal"><span class="pre">stdout</span></tt> are declared in the system module and thus visible in the instantiating context. There is a way to use bound identifiers (aka <span id="symbols_1">symbols</span>) instead of using unbound identifiers. The <tt class="docutils literal"><span class="pre">bindSym</span></tt> builtin can be used for that:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">typed</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newNimNode</span><span class="Punctuation">(</span><span class="Identifier">nnkStmtList</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Identifier">n</span><span class="Punctuation">:</span>
    <span class="Comment"># we can bind symbols in scope via 'bindSym':</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;write&quot;</span><span class="Punctuation">,</span> <span class="RawData">bindSym&quot;stdout&quot;</span><span class="Punctuation">,</span> <span class="Identifier">toStrLit</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;write&quot;</span><span class="Punctuation">,</span> <span class="RawData">bindSym&quot;stdout&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newStrLitNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;writeLine&quot;</span><span class="Punctuation">,</span> <span class="RawData">bindSym&quot;stdout&quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>The macro call expands to:</p>
<pre class="listing"><span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[0]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[1]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;x&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>However, the symbols <tt class="docutils literal"><span class="pre">write</span></tt>, <tt class="docutils literal"><span class="pre">writeLine</span></tt> and <tt class="docutils literal"><span class="pre">stdout</span></tt> are already bound and are not looked up again. As the example shows, <tt class="docutils literal"><span class="pre">bindSym</span></tt> does work with overloaded symbols implicitly.</p>

<h2><a class="toc-backref" id="宏-caseminusof宏" href="#宏-caseminusof宏">Case-Of宏</a></h2><p>In Nim it is possible to have a macro with the syntax of a <em>case-of</em> expression just with the difference that all of branches are passed to and processed by the macro implementation. It is then up the macro implementation to transform the <em>of-branches</em> into a valid Nim statement. The following example should show how this feature could be used for a lexical analyzer.</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">case_token</span><span class="Punctuation">(</span><span class="Identifier">args</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">untyped</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">args</span><span class="Operator">.</span><span class="Identifier">treeRepr</span>
  <span class="Comment"># creates a lexical analyzer from regular expressions</span>
  <span class="Comment"># ... (implementation is an exercise for the reader ;-)</span>
  <span class="Keyword">discard</span>

<span class="Identifier">case_token</span><span class="Punctuation">:</span> <span class="Comment"># this colon tells the parser it is a macro statement</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;[A-Za-z_]+[A-Za-z_0-9]*&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkIdentifier</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;0-9+&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkInteger</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;[\+\-\*\?]+&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkOperator</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkUnknown</span></pre><p><strong>Style note</strong>: For code readability, it is the best idea to use the least powerful programming construct that still suffices. So the &quot;check list&quot; is:</p>
<ol class="simple"><li>Use an ordinary proc/iterator, if possible.</li>
<li>Else: Use a generic proc/iterator, if possible.</li>
<li>Else: Use a template, if possible.</li>
<li>Else: Use a macro.</li>
</ol>

<h2><a class="toc-backref" id="宏-macros用作编译指示" href="#宏-macros用作编译指示">Macros用作编译指示</a></h2><p>Whole routines (procs, iterators etc.) can also be passed to a template or a macro via the pragma notation:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">m</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre><p>This is a simple syntactic transformation into:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">m</span><span class="Punctuation">:</span>
  <span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre>
<h2><a class="toc-backref" id="宏-for循环宏" href="#宏-for循环宏">For循环宏</a></h2><p>A macro that takes as its only input parameter an expression of the special type <tt class="docutils literal"><span class="pre">system.ForLoopStmt</span></tt> can rewrite the entirety of a <tt class="docutils literal"><span class="pre">for</span></tt> loop:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">macros</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;forLoopMacros&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">macro</span> <span class="Identifier">enumerate</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">ForLoopStmt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">expectKind</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">nnkForStmt</span>
  <span class="Comment"># we strip off the first for loop variable and use</span>
  <span class="Comment"># it as an integer counter:</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newStmtList</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newVarStmt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">body</span> <span class="Operator">=</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">1</span><span class="Punctuation">]</span>
  <span class="Keyword">if</span> <span class="Identifier">body</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">!=</span> <span class="Identifier">nnkStmtList</span><span class="Punctuation">:</span>
    <span class="Identifier">body</span> <span class="Operator">=</span> <span class="Identifier">newTree</span><span class="Punctuation">(</span><span class="Identifier">nnkStmtList</span><span class="Punctuation">,</span> <span class="Identifier">body</span><span class="Punctuation">)</span>
  <span class="Identifier">body</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;inc&quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">newFor</span> <span class="Operator">=</span> <span class="Identifier">newTree</span><span class="Punctuation">(</span><span class="Identifier">nnkForStmt</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">3</span><span class="Punctuation">:</span>
    <span class="Identifier">newFor</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
  <span class="Comment"># transform enumerate(X) to 'X'</span>
  <span class="Identifier">newFor</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span>
  <span class="Identifier">newFor</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">body</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newFor</span>
  <span class="Comment"># now wrap the whole macro in a block to create a new scope</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">quote</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
    <span class="Keyword">block</span><span class="Punctuation">:</span> <span class="Punctuation">`</span><span class="Identifier">result</span><span class="Punctuation">`</span>

<span class="Keyword">for</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Identifier">enumerate</span><span class="Punctuation">(</span><span class="Identifier">items</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">b</span>

<span class="Comment"># without wrapping the macro in a block, we'd need to choose different</span>
<span class="Comment"># names for `a` and `b` here to avoid redefinition errors</span>
<span class="Keyword">for</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Identifier">enumerate</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">b</span></pre><p>Currently for loop macros must be enabled explicitly via <tt class="docutils literal"><span class="pre">{.experimental: &quot;forLoopMacros&quot;.}</span></tt>.</p>

<h1><a class="toc-backref" id="特殊类型" href="#特殊类型">特殊类型</a></h1>
<h2><a class="toc-backref" id="特殊类型-static-t" href="#特殊类型-static-t">static[T]</a></h2><p>As their name suggests, static parameters must be constant expressions:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">precompiledRegex</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">:</span> <span class="Keyword">static</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">RegEx</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">res</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">global</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">re</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span>
  <span class="Keyword">return</span> <span class="Identifier">res</span>

<span class="Identifier">precompiledRegex</span><span class="Punctuation">(</span><span class="StringLit">&quot;/d+&quot;</span><span class="Punctuation">)</span> <span class="Comment"># Replaces the call with a precompiled</span>
                        <span class="Comment"># regex, stored in a global variable</span>

<span class="Identifier">precompiledRegex</span><span class="Punctuation">(</span><span class="Identifier">paramStr</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># Error, command-line options</span>
                              <span class="Comment"># are not constant expressions</span></pre><p>For the purposes of code generation, all static params are treated as generic params - the proc will be compiled separately for each unique supplied value (or combination of values).</p>
<p>Static params can also appear in the signatures of generic types:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="Identifier">M</span><span class="Punctuation">,</span><span class="Identifier">N</span><span class="Punctuation">:</span> <span class="Keyword">static</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">Number</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Punctuation">(</span><span class="Identifier">M</span><span class="Operator">*</span><span class="Identifier">N</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span>
    <span class="Comment"># Note how `Number` is just a type constraint here, while</span>
    <span class="Comment"># `static int` requires us to supply an int value</span>
  
  <span class="Identifier">AffineTransform2D</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span>
  <span class="Identifier">AffineTransform3D</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span>

<span class="Keyword">var</span> <span class="Identifier">m1</span><span class="Punctuation">:</span> <span class="Identifier">AffineTransform3D</span><span class="Punctuation">[</span><span class="Identifier">float</span><span class="Punctuation">]</span>  <span class="Comment"># OK</span>
<span class="Keyword">var</span> <span class="Identifier">m2</span><span class="Punctuation">:</span> <span class="Identifier">AffineTransform2D</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Comment"># Error, `string` is not a `Number`</span></pre><p>Please note that <tt class="docutils literal"><span class="pre">static T</span></tt> is just a syntactic convenience for the underlying generic type <tt class="docutils literal"><span class="pre">static[T]</span></tt>. The type param can be omitted to obtain the type class of all constant expressions. A more specific type class can be created by instantiating <tt class="docutils literal"><span class="pre">static</span></tt> with another type class.</p>
<p>You can force an expression to be evaluated at compile time as a constant expression by coercing it to a corresponding <tt class="docutils literal"><span class="pre">static</span></tt> type:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">math</span>

<span class="Identifier">echo</span> <span class="Keyword">static</span><span class="Punctuation">(</span><span class="Identifier">fac</span><span class="Punctuation">(</span><span class="DecNumber">5</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Keyword">static</span><span class="Punctuation">[</span><span class="Identifier">bool</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="FloatNumber">16.</span><span class="Identifier">isPowerOfTwo</span><span class="Punctuation">)</span></pre><p>The complier will report any failure to evaluate the expression or a possible type mismatch error.</p>

<h2><a class="toc-backref" id="特殊类型-typedesc-t" href="#特殊类型-typedesc-t">typedesc[T]</a></h2><p>In many contexts, Nim allows you to treat the names of types as regular values. These values exists only during the compilation phase, but since all values must have a type, <tt class="docutils literal"><span class="pre">typedesc</span></tt> is considered their special type.</p>
<p><tt class="docutils literal"><span class="pre">typedesc</span></tt> acts like a generic type. For instance, the type of the symbol <tt class="docutils literal"><span class="pre">int</span></tt> is <tt class="docutils literal"><span class="pre">typedesc[int]</span></tt>. Just like with regular generic types, when the generic param is ommited, <tt class="docutils literal"><span class="pre">typedesc</span></tt> denotes the type class of all types. As a syntactic convenience, you can also use <tt class="docutils literal"><span class="pre">typedesc</span></tt> as a modifier.</p>
<p>Procs featuring <tt class="docutils literal"><span class="pre">typedesc</span></tt> params are considered implicitly generic. They will be instantiated for each unique combination of supplied types and within the body of the proc, the name of each param will refer to the bound concrete type:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;allocating &quot;</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Operator">.</span><span class="Identifier">name</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Operator">.</span><span class="Identifier">new</span>
<span class="Keyword">var</span> <span class="Identifier">tree</span> <span class="Operator">=</span> <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>When multiple type params are present, they will bind freely to different types. To force a bind-once behavior one can use an explicit generic param:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">acceptOnlyTypePairs</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">,</span> <span class="Identifier">U</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">C</span><span class="Punctuation">,</span> <span class="Identifier">D</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">U</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>Once bound, type params can appear in the rest of the proc signature:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">declareVariableWithType</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Operator">=</span> <span class="Identifier">value</span>

<span class="Identifier">declareVariableWithType</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="DecNumber">42</span></pre><p>Overload resolution can be further influenced by constraining the set of types that will match the type param. This works in practice to attaching attributes to types via templates. The constraint can be a concrete type or a type class.</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">maxval</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Keyword">template</span> <span class="Identifier">maxval</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">float</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span> <span class="Identifier">Inf</span>

<span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="Identifier">int</span><span class="Operator">.</span><span class="Identifier">maxval</span>
<span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">float</span><span class="Operator">.</span><span class="Identifier">maxval</span>
<span class="Keyword">when</span> <span class="Identifier">false</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="Identifier">string</span><span class="Operator">.</span><span class="Identifier">maxval</span> <span class="Comment"># error, maxval is not implemented for string</span>

<span class="Keyword">template</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Keyword">object</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;Don't think so.&quot;</span>
<span class="Keyword">template</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">SomeInteger</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;Yes!&quot;</span>
<span class="Keyword">template</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">SomeFloat</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;Maybe, could be NaN.&quot;</span>

<span class="Identifier">echo</span> <span class="StringLit">&quot;is int a number? &quot;</span><span class="Punctuation">,</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;is float a number? &quot;</span><span class="Punctuation">,</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">float</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;is RootObj a number? &quot;</span><span class="Punctuation">,</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">RootObj</span><span class="Punctuation">)</span></pre><p>Passing <tt class="docutils literal"><span class="pre">typedesc</span></tt> almost identical, just with the differences that the macro is not instantiated generically. The type expression is simply passed as a <tt class="docutils literal"><span class="pre">NimNode</span></tt> to the macro, like everything else.</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">forwardType</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span> <span class="Operator">=</span>
  <span class="Comment"># ``arg`` is of type ``NimNode``</span>
  <span class="Keyword">let</span> <span class="Identifier">tmp</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span> <span class="Operator">=</span> <span class="Identifier">arg</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">tmp</span>

<span class="Keyword">var</span> <span class="Identifier">tmp</span><span class="Punctuation">:</span> <span class="Identifier">forwardType</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="特殊类型-typeof操作符" href="#特殊类型-typeof操作符">typeof操作符</a></h2><p><strong>Note</strong>: <tt class="docutils literal"><span class="pre">typeof(x)</span></tt> can for historical reasons also be written as <tt class="docutils literal"><span class="pre">type(x)</span></tt> but <tt class="docutils literal"><span class="pre">type(x)</span></tt> is discouraged.</p>
<p>You can obtain the type of a given expression by constructing a <tt class="docutils literal"><span class="pre">typeof</span></tt> value from it (in many other languages this is known as the <span id="typeof_1">typeof</span> operator):</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Keyword">var</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typeof</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># y has type int</span></pre><p>If <tt class="docutils literal"><span class="pre">typeof</span></tt> is used to determine the result type of a proc/iterator/converter call <tt class="docutils literal"><span class="pre">c(X)</span></tt> (where <tt class="docutils literal"><span class="pre">X</span></tt> stands for a possibly empty list of arguments), the interpretation where <tt class="docutils literal"><span class="pre">c</span></tt> is an iterator is preferred over the other interpretations, but this behavior can be changed by passing <tt class="docutils literal"><span class="pre">typeOfProc</span></tt> as the second argument to <tt class="docutils literal"><span class="pre">typeof</span></tt>:</p>
<pre class="listing"><span class="Keyword">iterator</span> <span class="Identifier">split</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Identifier">split</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Comment"># since an iterator is the preferred interpretation, `y` has the type ``string``:</span>
<span class="Identifier">assert</span> <span class="Identifier">typeof</span><span class="Punctuation">(</span><span class="StringLit">&quot;a b c&quot;</span><span class="Operator">.</span><span class="Identifier">split</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">string</span>

<span class="Identifier">assert</span> <span class="Identifier">typeof</span><span class="Punctuation">(</span><span class="StringLit">&quot;a b c&quot;</span><span class="Operator">.</span><span class="Identifier">split</span><span class="Punctuation">,</span> <span class="Identifier">typeOfProc</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span></pre>
<h1><a class="toc-backref" id="模块" href="#模块">模块</a></h1><p>Nim supports splitting a program into pieces by a module concept. Each module needs to be in its own file and has its own <span id="namespace_1">namespace</span>. Modules enable <span id="information-hiding_1">information hiding</span> and <span id="separate-compilation_1">separate compilation</span>. A module may gain access to symbols of another module by the <span id="import_1">import</span> statement. <span id="recursive-module-dependencies_1">Recursive module dependencies</span> are allowed, but slightly subtle. Only top-level symbols that are marked with an asterisk (<tt class="docutils literal"><span class="pre">*</span></tt>) are exported. A valid module name can only be a valid Nim identifier (and thus its filename is <tt class="docutils literal"><span class="pre">identifier.nim</span></tt>).</p>
<p>The algorithm for compiling modules is:</p>
<ul class="simple"><li>compile the whole module as usual, following import statements recursively</li>
<li>if there is a cycle only import the already parsed symbols (that are exported); if an unknown identifier occurs then abort</li>
</ul>
<p>This is best illustrated by an 示例：</p>
<pre class="listing"><span class="Comment"># Module A</span>
<span class="Keyword">type</span>
  <span class="Identifier">T1</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Identifier">int</span>  <span class="Comment"># Module A exports the type ``T1``</span>
<span class="Keyword">import</span> <span class="Identifier">B</span>     <span class="Comment"># the compiler starts parsing B</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Comment"># works because B has been parsed completely here</span>

<span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><pre class="listing"><span class="Comment"># Module B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>  <span class="Comment"># A is not parsed here! Only the already known symbols</span>
          <span class="Comment"># of A are imported.</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">T1</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">T1</span> <span class="Operator">=</span>
  <span class="Comment"># this works because the compiler has already</span>
  <span class="Comment"># added T1 to A's interface symbol table</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="DecNumber">1</span></pre>
<h3><a class="toc-backref" id="模块-import语句" href="#模块-import语句">Import语句</a></h3><p>After the <tt class="docutils literal"><span class="pre">import</span></tt> statement a list of module names can follow or a single module name followed by an <tt class="docutils literal"><span class="pre">except</span></tt> list to prevent some symbols to be imported:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">strutils</span> <span class="Keyword">except</span> <span class="Punctuation">`</span><span class="Operator">%</span><span class="Punctuation">`</span><span class="Punctuation">,</span> <span class="Identifier">toUpperAscii</span>

<span class="Comment"># doesn't work then:</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;$1&quot;</span> <span class="Operator">%</span> <span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">toUpperAscii</span></pre><p>It is not checked that the <tt class="docutils literal"><span class="pre">except</span></tt> list is really exported from the module. This feature allows to compile against an older version of the module that does not export these identifiers.</p>

<h3><a class="toc-backref" id="模块-include语句" href="#模块-include语句">Include语句</a></h3><p>The <tt class="docutils literal"><span class="pre">include</span></tt> statement does something fundamentally different than importing a module: it merely includes the contents of a file. The <tt class="docutils literal"><span class="pre">include</span></tt> statement is useful to split up a large module into several files:</p>
<pre class="listing"><span class="Keyword">include</span> <span class="Identifier">fileA</span><span class="Punctuation">,</span> <span class="Identifier">fileB</span><span class="Punctuation">,</span> <span class="Identifier">fileC</span></pre>
<h3><a class="toc-backref" id="模块-导入的模块名" href="#模块-导入的模块名">导入的模块名</a></h3><p>A module alias can be introduced via the <tt class="docutils literal"><span class="pre">as</span></tt> keyword:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">strutils</span> <span class="Keyword">as</span> <span class="Identifier">su</span><span class="Punctuation">,</span> <span class="Identifier">sequtils</span> <span class="Keyword">as</span> <span class="Identifier">qu</span>

<span class="Identifier">echo</span> <span class="Identifier">su</span><span class="Operator">.</span><span class="Identifier">format</span><span class="Punctuation">(</span><span class="StringLit">&quot;$1&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;lalelu&quot;</span><span class="Punctuation">)</span></pre><p>The original module name is then not accessible. The notations <tt class="docutils literal"><span class="pre">path/to/module</span></tt> or <tt class="docutils literal"><span class="pre">&quot;path/to/module&quot;</span></tt> can be used to refer to a module in subdirectories:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">os</span><span class="Punctuation">,</span> <span class="StringLit">&quot;lib/pure/times&quot;</span></pre><p>Note that the module name is still <tt class="docutils literal"><span class="pre">strutils</span></tt> and not <tt class="docutils literal"><span class="pre">lib/pure/strutils</span></tt> and so one <strong>cannot</strong> do:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">strutils</span>
<span class="Identifier">echo</span> <span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">strutils</span><span class="Operator">.</span><span class="Identifier">toUpperAscii</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">)</span></pre><p>Likewise the following does not make sense as the name is <tt class="docutils literal"><span class="pre">strutils</span></tt> already:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">strutils</span> <span class="Keyword">as</span> <span class="Identifier">strutils</span></pre>
<h3><a class="toc-backref" id="模块-从目录中集体导入" href="#模块-从目录中集体导入">从目录中集体导入</a></h3><p>The syntax <tt class="docutils literal"><span class="pre">import dir / [moduleA, moduleB]</span></tt> can be used to import multiple modules from the same directory.</p>
<p>Path names are syntactically either Nim identifiers or string literals. If the path name is not a valid Nim identifier it needs to be a string literal:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="StringLit">&quot;gfx/3d/somemodule&quot;</span> <span class="Comment"># in quotes because '3d' is not a valid Nim identifier</span></pre>
<h3><a class="toc-backref" id="模块-pseudo-importslashinclude-paths" href="#模块-pseudo-importslashinclude-paths">Pseudo import/include paths</a></h3><p>A directory can also be a so called &quot;pseudo directory&quot;. They can be used to avoid ambiguity when there are multiple modules with the same path.</p>
<p>There are two pseudo directories:</p>
<p>1. <tt class="docutils literal"><span class="pre">std</span></tt>: The <tt class="docutils literal"><span class="pre">std</span></tt> pseudo directory is the abstract location of Nim's standard library. For example, the syntax <tt class="docutils literal"><span class="pre">import std / strutils</span></tt> is used to unambiguously refer to the standard library's <tt class="docutils literal"><span class="pre">strutils</span></tt> module.</p>
<p>2. <tt class="docutils literal"><span class="pre">pkg</span></tt>: The <tt class="docutils literal"><span class="pre">pkg</span></tt> pseudo directory is used to unambiguously refer to a Nimble package. However, for technical details that lie outside of the scope of this document its semantics are: <em>Use the search path to look for module name but ignore the standard library locations</em>. In other words, it is the opposite of <tt class="docutils literal"><span class="pre">std</span></tt>.</p>

<h3><a class="toc-backref" id="模块-from-import语句" href="#模块-from-import语句">From import语句</a></h3><p>After the <tt class="docutils literal"><span class="pre">from</span></tt> statement a module name follows followed by an <tt class="docutils literal"><span class="pre">import</span></tt> to list the symbols one likes to use without explicit full qualification:</p>
<pre class="listing"><span class="Keyword">from</span> <span class="Identifier">strutils</span> <span class="Keyword">import</span> <span class="Punctuation">`</span><span class="Operator">%</span><span class="Punctuation">`</span>

<span class="Identifier">echo</span> <span class="StringLit">&quot;$1&quot;</span> <span class="Operator">%</span> <span class="StringLit">&quot;abc&quot;</span>
<span class="Comment"># always possible: full qualification:</span>
<span class="Identifier">echo</span> <span class="Identifier">strutils</span><span class="Operator">.</span><span class="Identifier">replace</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;z&quot;</span><span class="Punctuation">)</span></pre><p>It's also possible to use <tt class="docutils literal"><span class="pre">from module import nil</span></tt> if one wants to import the module but wants to enforce fully qualified access to every symbol in <tt class="docutils literal"><span class="pre">module</span></tt>.</p>

<h3><a class="toc-backref" id="模块-export语句" href="#模块-export语句">Export语句</a></h3><p>An <tt class="docutils literal"><span class="pre">export</span></tt> statement can be used for symbol forwarding so that client modules don't need to import a module's dependencies:</p>
<pre class="listing"><span class="Comment"># module B</span>
<span class="Keyword">type</span> <span class="Identifier">MyObject</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span></pre><pre class="listing"><span class="Comment"># module A</span>
<span class="Keyword">import</span> <span class="Identifier">B</span>
<span class="Keyword">export</span> <span class="Identifier">B</span><span class="Operator">.</span><span class="Identifier">MyObject</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;my object&quot;</span></pre><pre class="listing"><span class="Comment"># module C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>

<span class="Comment"># B.MyObject has been imported implicitly here:</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span>
<span class="Identifier">echo</span> <span class="Operator">$</span><span class="Identifier">x</span></pre><p>When the exported symbol is another module, all of its definitions will be forwarded. You can use an <tt class="docutils literal"><span class="pre">except</span></tt> list to exclude some of the symbols.</p>
<p>Notice that when exporting, you need to specify only the module name:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">foo</span><span class="Operator">/</span><span class="Identifier">bar</span><span class="Operator">/</span><span class="Identifier">baz</span>
<span class="Keyword">export</span> <span class="Identifier">baz</span></pre>
<h2><a class="toc-backref" id="模块-作用域规则" href="#模块-作用域规则">作用域规则</a></h2><p>Identifiers are valid from the point of their declaration until the end of the block in which the declaration occurred. The range where the identifier is known is the scope of the identifier. The exact scope of an identifier depends on the way it was declared.</p>

<h3><a class="toc-backref" id="作用域规则-块作用域" href="#作用域规则-块作用域">块作用域</a></h3><p>The <em>scope</em> of a variable declared in the declaration part of a block is valid from the point of declaration until the end of the block. If a block contains a second block, in which the identifier is redeclared, then inside this block, the second declaration will be valid. Upon leaving the inner block, the first declaration is valid again. An identifier cannot be redefined in the same block, except if valid for procedure or iterator overloading purposes.</p>

<h3><a class="toc-backref" id="作用域规则-元组或对象作用域" href="#作用域规则-元组或对象作用域">元组或对象作用域</a></h3><p>The field identifiers inside a tuple or object definition are valid in the following places:</p>
<ul class="simple"><li>To the end of the tuple/object definition.</li>
<li>Field designators of a variable of the given tuple/object type.</li>
<li>In all descendant types of the object type.</li>
</ul>

<h3><a class="toc-backref" id="作用域规则-模块作用域" href="#作用域规则-模块作用域">模块作用域</a></h3><p>All identifiers of a module are valid from the point of declaration until the end of the module. Identifiers from indirectly dependent modules are <em>not</em> available. The <span id="system_1">system</span> module is automatically imported in every module.</p>
<p>If a module imports an identifier by two different modules, each occurrence of the identifier has to be qualified, unless it is an overloaded procedure or iterator in which case the overloading resolution takes place:</p>
<pre class="listing"><span class="Comment"># Module A</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">string</span></pre><pre class="listing"><span class="Comment"># Module B</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre><pre class="listing"><span class="Comment"># Module C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># error: x is ambiguous</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># no error: qualifier used</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># not ambiguous: uses the module C's x</span></pre>
<h3><a class="toc-backref" id="作用域规则-代码重排" href="#作用域规则-代码重排">代码重排</a></h3><p><strong>Note</strong>: Code reordering is experimental and must be enabled via the``{.experimental.}`` pragma.</p>
<p>The code reordering feature can implicitly rearrange procedure, template, and macro definitions along with variable declarations and initializations at the top level scope so that, to a large extent, a programmer should not have to worry about ordering definitions correctly or be forced to use forward declarations to preface definitions inside a module.</p>
<p>示例：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;codeReordering&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Identifier">foo</span><span class="Punctuation">(</span><span class="DecNumber">10</span><span class="Punctuation">)</span></pre><p>Variables can also be reordered as well. Variables that are <em>initialized</em> (i.e. variables that have their declaration and assignment combined in a single statement) can have their entire initialization statement reordered. Be wary of what code is executed at the top level:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;codeReordering&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">foo</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">foo</span> <span class="Operator">=</span> <span class="DecNumber">5</span>

<span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># outputs: &quot;5&quot;</span></pre><p>It is important to note that reordering <em>only</em> works for symbols at top level scope. Therefore, the following will <em>fail to compile:</em></p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;codeReordering&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">b</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">proc</span> <span class="Identifier">b</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hello!&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h1><a class="toc-backref" id="编译器消息" href="#编译器消息">编译器消息</a></h1><p>The Nim compiler emits different kinds of messages: <span id="hint_1">hint</span>, <span id="warning_1">warning</span>, and <span id="error_1">error</span> messages. An <em>error</em> message is emitted if the compiler encounters any static error.</p>

<h1><a class="toc-backref" id="编译指示" href="#编译指示">编译指示</a></h1><p>Pragmas are Nim's method to give the compiler additional information / commands without introducing a massive number of new keywords. Pragmas are processed on the fly during semantic checking. Pragmas are enclosed in the special <tt class="docutils literal"><span class="pre">{.</span></tt> and <tt class="docutils literal"><span class="pre">.}</span></tt> curly brackets. Pragmas are also often used as a first implementation to play with a language feature before a nicer syntax to access the feature becomes available.</p>

<h2><a class="toc-backref" id="编译指示-deprecated-编译指示" href="#编译指示-deprecated-编译指示">deprecated 编译指示</a></h2><p>The deprecated pragma is used to mark a symbol as deprecated:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">char</span></pre><p>This pragma can also take in an optional warning string to relay to developers.</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">thing</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Punctuation">:</span> <span class="StringLit">&quot;use thong instead&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="编译指示-nosideeffect-编译指示" href="#编译指示-nosideeffect-编译指示">noSideEffect 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">noSideEffect</span></tt> pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type <tt class="docutils literal"><span class="pre">var T</span></tt> or <tt class="docutils literal"><span class="pre">ref T</span></tt> or <tt class="docutils literal"><span class="pre">ptr T</span></tt> this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</p>
<p>As a special semantic rule, the built-in <a class="reference external" href="system.html#debugEcho">debugEcho</a> pretends to be free of side effects, so that it can be used for debugging routines marked as <tt class="docutils literal"><span class="pre">noSideEffect</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">func</span></tt> is syntactic sugar for a proc with no side effects:</p>
<pre class="listing"><span class="Keyword">func</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>To override the compiler's side effect analysis a <tt class="docutils literal"><span class="pre">{.noSideEffect.}</span></tt> pragma block can be used:</p>
<pre class="listing"><span class="Keyword">func</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noSideEffect</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;test&quot;</span></pre>
<h2><a class="toc-backref" id="编译指示-compiletime-编译指示" href="#编译指示-compiletime-编译指示">compileTime 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">compileTime</span></tt> pragma is used to mark a proc or variable to be used only during compile-time execution. No code will be generated for it. Compile-time procs are useful as helpers for macros. Since version 0.12.0 of the language, a proc that uses <tt class="docutils literal"><span class="pre">system.NimNode</span></tt> within its parameter types is implicitly declared <tt class="docutils literal"><span class="pre">compileTime</span></tt>:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">astHelper</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">n</span></pre><p>Is the same as:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">astHelper</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">n</span></pre>
<h2><a class="toc-backref" id="编译指示-noreturn-编译指示" href="#编译指示-noreturn-编译指示">noReturn 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">noreturn</span></tt> pragma is used to mark a proc that never returns.</p>

<h2><a class="toc-backref" id="编译指示-acyclic-编译指示" href="#编译指示-acyclic-编译指示">acyclic 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">acyclic</span></tt> pragma applies to type declarations. It is deprecated and ignored.</p>

<h2><a class="toc-backref" id="编译指示-final-编译指示" href="#编译指示-final-编译指示">final 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">final</span></tt> pragma can be used for an object type to specify that it cannot be inherited from. Note that inheritance is only available for objects that inherit from an existing object (via the <tt class="docutils literal"><span class="pre">object of SuperType</span></tt> syntax) or that have been marked as <tt class="docutils literal"><span class="pre">inheritable</span></tt>.</p>

<h2><a class="toc-backref" id="编译指示-shallow-编译指示" href="#编译指示-shallow-编译指示">shallow 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">shallow</span></tt> pragma affects the semantics of a type: The compiler is allowed to make a shallow copy. This can cause serious semantic issues and break memory safety! However, it can speed up assignments considerably, because the semantics of Nim require deep copying of sequences and strings. This can be expensive, especially if sequences are used to build a tree structure:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">NodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span> <span class="Identifier">nkLeaf</span><span class="Punctuation">,</span> <span class="Identifier">nkInner</span>
  <span class="Identifier">Node</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">shallow</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">NodeKind</span>
    <span class="Keyword">of</span> <span class="Identifier">nkLeaf</span><span class="Punctuation">:</span>
      <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">nkInner</span><span class="Punctuation">:</span>
      <span class="Identifier">children</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Node</span><span class="Punctuation">]</span></pre>
<h2><a class="toc-backref" id="编译指示-pure-编译指示" href="#编译指示-pure-编译指示">pure 编译指示</a></h2><p>An object type can be marked with the <tt class="docutils literal"><span class="pre">pure</span></tt> pragma so that its type field which is used for runtime type identification is omitted. This used to be necessary for binary compatibility with other compiled languages.</p>
<p>An enum type can be marked as <tt class="docutils literal"><span class="pre">pure</span></tt>. Then access of its fields always requires full qualification.</p>

<h2><a class="toc-backref" id="编译指示-asmnostackframe-编译指示" href="#编译指示-asmnostackframe-编译指示">asmNoStackFrame 编译指示</a></h2><p>A proc can be marked with the <tt class="docutils literal"><span class="pre">asmNoStackFrame</span></tt> pragma to tell the compiler it should not generate a stack frame for the proc. There are also no exit statements like <tt class="docutils literal"><span class="pre">return result;</span></tt> generated and the generated C function is declared as <tt class="docutils literal"><span class="pre">__declspec(naked)</span></tt> or <tt class="docutils literal"><span class="pre">__attribute__((naked))</span></tt> (depending on the used C compiler).</p>
<p><strong>Note</strong>: This pragma should only be used by procs which consist solely of assembler statements.</p>

<h2><a class="toc-backref" id="编译指示-error-编译指示" href="#编译指示-error-编译指示">error 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">error</span></tt> pragma is used to make the compiler output an error message with the given content. Compilation does not necessarily abort after an error though.</p>
<p>The <tt class="docutils literal"><span class="pre">error</span></tt> pragma can also be used to annotate a symbol (like an iterator or proc). The <em>usage</em> of the symbol then triggers a static error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</p>
<pre class="listing"><span class="Comment">## check that underlying int values are compared and not the pointers:</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">error</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="编译指示-fatal-编译指示" href="#编译指示-fatal-编译指示">fatal 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">fatal</span></tt> pragma is used to make the compiler output an error message with the given content. In contrast to the <tt class="docutils literal"><span class="pre">error</span></tt> pragma, compilation is guaranteed to be aborted by this pragma. 示例：</p>
<pre class="listing"><span class="Keyword">when</span> <span class="Keyword">not</span> <span class="Identifier">defined</span><span class="Punctuation">(</span><span class="Identifier">objc</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">fatal</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Compile this program with the objc command!&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="编译指示-warning-编译指示" href="#编译指示-warning-编译指示">warning 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">warning</span></tt> pragma is used to make the compiler output a warning message with the given content. Compilation continues after the warning.</p>

<h2><a class="toc-backref" id="编译指示-hint-编译指示" href="#编译指示-hint-编译指示">hint 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">hint</span></tt> pragma is used to make the compiler output a hint message with the given content. Compilation continues after the hint.</p>

<h2><a class="toc-backref" id="编译指示-line-编译指示" href="#编译指示-line-编译指示">line 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">line</span></tt> pragma can be used to affect line information of the annotated statement as seen in stack backtraces:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">myassert</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">,</span> <span class="Identifier">msg</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">cond</span><span class="Punctuation">:</span>
    <span class="Comment"># change run-time line information of the 'raise' statement:</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">instantiationInfo</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
      <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">EAssertionFailed</span><span class="Punctuation">,</span> <span class="Identifier">msg</span><span class="Punctuation">)</span></pre><p>If the <tt class="docutils literal"><span class="pre">line</span></tt> pragma is used with a parameter, the parameter needs be a <tt class="docutils literal"><span class="pre">tuple[filename: string, line: int]</span></tt>. If it is used without a parameter, <tt class="docutils literal"><span class="pre">system.InstantiationInfo()</span></tt> is used.</p>

<h2><a class="toc-backref" id="编译指示-linearscanend-编译指示" href="#编译指示-linearscanend-编译指示">linearScanEnd 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">linearScanEnd</span></tt> pragma can be used to tell the compiler how to compile a Nim <span id="case_1">case</span> statement. Syntactically it has to be used as a statement:</p>
<pre class="listing"><span class="Keyword">case</span> <span class="Identifier">myInt</span>
<span class="Keyword">of</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;most common case&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">linearScanEnd</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;second most common case&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;unlikely: use branch table&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;unlikely too: use branch table for &quot;</span><span class="Punctuation">,</span> <span class="Identifier">myInt</span></pre><p>In the example, the case branches <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">1</span></tt> are much more common than the other cases. Therefore the generated assembler code should test for these values first, so that the CPU's branch predictor has a good chance to succeed (avoiding an expensive CPU pipeline stall). The other cases might be put into a jump table for O(1) overhead, but at the cost of a (very likely) pipeline stall.</p>
<p>The <tt class="docutils literal"><span class="pre">linearScanEnd</span></tt> pragma should be put into the last branch that should be tested against via linear scanning. If put into the last branch of the whole <tt class="docutils literal"><span class="pre">case</span></tt> statement, the whole <tt class="docutils literal"><span class="pre">case</span></tt> statement uses linear scanning.</p>

<h2><a class="toc-backref" id="编译指示-computedgoto-编译指示" href="#编译指示-computedgoto-编译指示">computedGoto 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">computedGoto</span></tt> pragma can be used to tell the compiler how to compile a Nim <span id="case_2">case</span> in a <tt class="docutils literal"><span class="pre">while true</span></tt> statement. Syntactically it has to be used as a statement inside the loop:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">enumA</span><span class="Punctuation">,</span> <span class="Identifier">enumB</span><span class="Punctuation">,</span> <span class="Identifier">enumC</span><span class="Punctuation">,</span> <span class="Identifier">enumD</span><span class="Punctuation">,</span> <span class="Identifier">enumE</span>

<span class="Keyword">proc</span> <span class="Identifier">vm</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">instructions</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">100</span><span class="Punctuation">,</span> <span class="Identifier">MyEnum</span><span class="Punctuation">]</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumC</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumD</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumA</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumD</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumC</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">7</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumA</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">8</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumB</span>
  
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">12</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumE</span>
  <span class="Keyword">var</span> <span class="Identifier">pc</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">computedGoto</span><span class="Operator">.</span><span class="Punctuation">}</span>
    <span class="Keyword">let</span> <span class="Identifier">instr</span> <span class="Operator">=</span> <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="Identifier">pc</span><span class="Punctuation">]</span>
    <span class="Keyword">case</span> <span class="Identifier">instr</span>
    <span class="Keyword">of</span> <span class="Identifier">enumA</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah A&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumC</span><span class="Punctuation">,</span> <span class="Identifier">enumD</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah CD&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumB</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah B&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumE</span><span class="Punctuation">:</span>
      <span class="Keyword">break</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">pc</span><span class="Punctuation">)</span>

<span class="Identifier">vm</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>As the example shows <tt class="docutils literal"><span class="pre">computedGoto</span></tt> is mostly useful for interpreters. If the underlying backend (C compiler) does not support the computed goto extension the pragma is simply ignored.</p>

<h2><a class="toc-backref" id="编译指示-unroll-编译指示" href="#编译指示-unroll-编译指示">unroll 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">unroll</span></tt> pragma can be used to tell the compiler that it should unroll a <span id="for_2">for</span> or <span id="while_1">while</span> loop for execution efficiency:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">searchChar</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">unroll</span><span class="Punctuation">:</span> <span class="FloatNumber">4.</span><span class="Punctuation">}</span>
    <span class="Keyword">if</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">i</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Operator">-</span><span class="DecNumber">1</span></pre><p>In the above example, the search loop is unrolled by a factor 4. The unroll factor can be left out too; the compiler then chooses an appropriate unroll factor.</p>
<p><strong>Note</strong>: Currently the compiler recognizes but ignores this pragma.</p>

<h2><a class="toc-backref" id="编译指示-immediate-编译指示" href="#编译指示-immediate-编译指示">immediate 编译指示</a></h2><p>The immediate pragma is obsolete. See <a class="reference external" href="#typed-vs-untyped-parameters">Typed vs untyped parameters</a>.</p>

<h2><a class="toc-backref" id="编译指示-compilation-option-pragmas" href="#编译指示-compilation-option-pragmas">compilation option pragmas</a></h2><p>The listed pragmas here can be used to override the code generation options for a proc/method/converter.</p>
<p>The implementation currently provides the following possible options (various others may be added later).</p>
<table border="1" class="docutils"><tr><th>pragma</th><th>allowed values</th><th>description</th></tr>
<tr><td>checks</td><td>on|off </td><td>Turns the code generation for all runtime checks on or off.</td></tr>
<tr><td>boundChecks</td><td>on|off </td><td>Turns the code generation for array bound checks on or off.</td></tr>
<tr><td>overflowChecks</td><td>on|off </td><td>Turns the code generation for over- or underflow checks on or off.</td></tr>
<tr><td>nilChecks</td><td>on|off </td><td>Turns the code generation for nil pointer checks on or off.</td></tr>
<tr><td>assertions</td><td>on|off </td><td>Turns the code generation for assertions on or off.</td></tr>
<tr><td>warnings</td><td>on|off </td><td>Turns the warning messages of the compiler on or off.</td></tr>
<tr><td>hints</td><td>on|off </td><td>Turns the hint messages of the compiler on or off.</td></tr>
<tr><td>optimization</td><td>none|speed|size </td><td>Optimize the code for speed or size, or disable optimization.</td></tr>
<tr><td>patterns</td><td>on|off </td><td>Turns the term rewriting templates/macros on or off.</td></tr>
<tr><td>callconv</td><td>cdecl|...</td><td>Specifies the default calling convention for all procedures (and procedure types) that follow.</td></tr>
</table><p>示例：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">checks</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Punctuation">,</span> <span class="Identifier">optimization</span><span class="Punctuation">:</span> <span class="Identifier">speed</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Comment"># compile without runtime checks and optimize for speed</span></pre>
<h2><a class="toc-backref" id="编译指示-push-and-pop-编译指示" href="#编译指示-push-and-pop-编译指示">push and pop 编译指示</a></h2><p>The <span id="pushslashpop_1">push/pop</span> pragmas are very similar to the option directive, but are used to override the settings temporarily. 示例：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">checks</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Comment"># compile this section without runtime checks as it is</span>
<span class="Comment"># speed critical</span>
<span class="Comment"># ... some code ...</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Comment"># restore old settings</span></pre>
<h2><a class="toc-backref" id="编译指示-register-编译指示" href="#编译指示-register-编译指示">register 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">register</span></tt> pragma is for variables only. It declares the variable as <tt class="docutils literal"><span class="pre">register</span></tt>, giving the compiler a hint that the variable should be placed in a hardware register for faster access. C compilers usually ignore this though and for good reasons: Often they do a better job without it anyway.</p>
<p>In highly specific cases (a dispatch loop of a bytecode interpreter for example) it may provide benefits, though.</p>

<h2><a class="toc-backref" id="编译指示-global-编译指示" href="#编译指示-global-编译指示">global 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">global</span></tt> pragma can be applied to a variable within a proc to instruct the compiler to store it in a global location and initialize it once at program startup.</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">isHexNumber</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">pattern</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">global</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="RawData">re&quot;[0-9a-fA-F]+&quot;</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">match</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span></pre><p>When used within a generic proc, a separate unique global variable will be created for each instantiation of the proc. The order of initialization of the created global variables within a module is not defined, but all of them will be initialized after any top-level variables in their originating module and before any variable in a module that imports it.</p>

<h2><a class="toc-backref" id="编译指示-pragma-编译指示" href="#编译指示-pragma-编译指示">pragma 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">pragma</span></tt> pragma can be used to declare user defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</p>
<p>示例：</p>
<pre class="listing"><span class="Keyword">when</span> <span class="Identifier">appType</span> <span class="Operator">==</span> <span class="StringLit">&quot;lib&quot;</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Punctuation">:</span> <span class="Identifier">rtl</span><span class="Punctuation">,</span> <span class="Identifier">exportc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">,</span> <span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Punctuation">:</span> <span class="Identifier">rtl</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;client.dll&quot;</span><span class="Punctuation">,</span> <span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">rtl</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">+</span><span class="Identifier">b</span></pre><p>In the example a new pragma named <tt class="docutils literal"><span class="pre">rtl</span></tt> is introduced that either imports a symbol from a dynamic library or exports the symbol for dynamic library generation.</p>

<h2><a class="toc-backref" id="编译指示-disabling-certain-messages" href="#编译指示-disabling-certain-messages">Disabling certain messages</a></h2><p>Nim generates some warnings and hints (&quot;line too long&quot;) that may annoy the user. A mechanism for disabling certain messages is provided: Each hint and warning message contains a symbol in brackets. This is the message's identifier that can be used to enable or disable it:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">hint</span><span class="Punctuation">[</span><span class="Identifier">LineTooLong</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Comment"># turn off the hint about too long lines</span></pre><p>This is often better than disabling all warnings at once.</p>

<h2><a class="toc-backref" id="编译指示-used-编译指示" href="#编译指示-used-编译指示">used 编译指示</a></h2><p>Nim produces a warning for symbols that are not exported and not used either. The <tt class="docutils literal"><span class="pre">used</span></tt> pragma can be attached to a symbol to suppress this warning. This is particularly useful when the symbol was generated by a macro:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">implementArithOps</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Identifier">echoAdd</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">used</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
    <span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">+</span> <span class="Identifier">b</span>
  <span class="Keyword">proc</span> <span class="Identifier">echoSub</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">used</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
    <span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">-</span> <span class="Identifier">b</span>

<span class="Comment"># no warning produced for the unused 'echoSub'</span>
<span class="Identifier">implementArithOps</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Identifier">echoAdd</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">5</span></pre>
<h2><a class="toc-backref" id="编译指示-experimental-编译指示" href="#编译指示-experimental-编译指示">experimental 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">experimental</span></tt> pragma enables experimental language features. Depending on the concrete feature this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed any time).</p>
<p>示例：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;parallel&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">useParallel</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">parallel</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">4</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;echo in parallel&quot;</span></pre><p>As a top level statement, the experimental pragma enables a feature for the rest of the module it's enabled in. This is problematic for macro and generic instantiations that cross a module scope. Currently these usages have to be put into a <tt class="docutils literal"><span class="pre">.push/pop</span></tt> environment:</p>
<pre class="listing"><span class="Comment"># client.nim</span>
<span class="Keyword">proc</span> <span class="Identifier">useParallel</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">unused</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># use a generic T here to show the problem.</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;parallel&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Identifier">parallel</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">4</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;echo in parallel&quot;</span>
  
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><pre class="listing"><span class="Keyword">import</span> <span class="Identifier">client</span>
<span class="Identifier">useParallel</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre>
<h1><a class="toc-backref" id="特定实现的编译指示" href="#特定实现的编译指示">特定实现的编译指示</a></h1><p>This section describes additional pragmas that the current Nim implementation supports but which should not be seen as part of the language specification.</p>

<h2><a class="toc-backref" id="特定实现的编译指示-bitsize-编译指示" href="#特定实现的编译指示-bitsize-编译指示">Bitsize 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">bitsize</span></tt> 编译指示 is for object field members. It declares the field as a bitfield in C/C++.</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">mybitfield</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">flag</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">bitsize</span><span class="Punctuation">:</span><span class="FloatNumber">1.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">cuint</span></pre><p>generates:</p>
<pre class="listing"><span class="Keyword">struct</span> <span class="Identifier">mybitfield</span> <span class="Punctuation">{</span>
  <span class="Keyword">unsigned</span> <span class="Keyword">int</span> <span class="Identifier">flag</span><span class="Punctuation">:</span><span class="DecNumber">1</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span><span class="Punctuation">;</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-volatile-编译指示" href="#特定实现的编译指示-volatile-编译指示">Volatile 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">volatile</span></tt> pragma is for variables only. It declares the variable as <tt class="docutils literal"><span class="pre">volatile</span></tt>, whatever that means in C/C++ (its semantics are not well defined in C/C++).</p>
<p><strong>Note</strong>: This pragma will not exist for the LLVM backend.</p>

<h2><a class="toc-backref" id="特定实现的编译指示-nodecl-编译指示" href="#特定实现的编译指示-nodecl-编译指示">NoDecl 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">noDecl</span></tt> pragma can be applied to almost any symbol (variable, proc, type, etc.) and is sometimes useful for interoperability with C: It tells Nim that it should not generate a declaration for the symbol in the C code. For 示例：</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">EACCES</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">noDecl</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">cint</span> <span class="Comment"># pretend EACCES was a variable, as</span>
                                   <span class="Comment"># Nim does not know its value</span></pre><p>However, the <tt class="docutils literal"><span class="pre">header</span></tt> pragma is often the better alternative.</p>
<p><strong>Note</strong>: This will not work for the LLVM backend.</p>

<h2><a class="toc-backref" id="特定实现的编译指示-header-编译指示" href="#特定实现的编译指示-header-编译指示">Header 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">header</span></tt> pragma is very similar to the <tt class="docutils literal"><span class="pre">noDecl</span></tt> pragma: It can be applied to almost any symbol and specifies that it should not be declared and instead the generated code should contain an <tt class="docutils literal"><span class="pre">#include</span></tt>:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">PFile</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;FILE*&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;stdio.h&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">pointer</span>
    <span class="Comment"># import C's FILE* type; Nim will treat it as a new pointer type</span></pre><p>The <tt class="docutils literal"><span class="pre">header</span></tt> pragma always expects a string constant. The string contant contains the header file: As usual for C, a system header file is enclosed in angle brackets: <tt class="docutils literal"><span class="pre">&lt;&gt;</span></tt>. If no angle brackets are given, Nim encloses the header file in <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> in the generated C code.</p>
<p><strong>Note</strong>: This will not work for the LLVM backend.</p>

<h2><a class="toc-backref" id="特定实现的编译指示-incompletestruct-编译指示" href="#特定实现的编译指示-incompletestruct-编译指示">IncompleteStruct 编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">incompleteStruct</span></tt> pragma tells the compiler to not use the underlying C <tt class="docutils literal"><span class="pre">struct</span></tt> in a <tt class="docutils literal"><span class="pre">sizeof</span></tt> expression:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">DIR</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;DIR&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;dirent.h&gt;&quot;</span><span class="Punctuation">,</span>
         <span class="Identifier">pure</span><span class="Punctuation">,</span> <span class="Identifier">incompleteStruct</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-compile编译指示" href="#特定实现的编译指示-compile编译指示">Compile编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">compile</span></tt> 编译指示 can be used to compile and link a C/C++ source file with the project:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compile</span><span class="Punctuation">:</span> <span class="StringLit">&quot;myfile.cpp&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p><strong>Note</strong>: Nim computes a SHA1 checksum and only recompiles the file if it has changed. You can use the <tt class="docutils literal"><span class="pre">-f</span></tt> command line option to force recompilation of the file.</p>

<h2><a class="toc-backref" id="特定实现的编译指示-link编译指示" href="#特定实现的编译指示-link编译指示">Link编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">link</span></tt> 编译指示 can be used to link an additional file with the project:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">link</span><span class="Punctuation">:</span> <span class="StringLit">&quot;myfile.o&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-passc编译指示" href="#特定实现的编译指示-passc编译指示">PassC编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">passC</span></tt> 编译指示 can be used to pass additional parameters to the C compiler like you would using the commandline switch <tt class="docutils literal"><span class="pre">--passC</span></tt>:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">passC</span><span class="Punctuation">:</span> <span class="StringLit">&quot;-Wall -Werror&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>Note that you can use <tt class="docutils literal"><span class="pre">gorge</span></tt> from the <a class="reference external" href="system.html">system module</a> to embed parameters from an external command that will be executed during semantic analysis:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">passC</span><span class="Punctuation">:</span> <span class="Identifier">gorge</span><span class="Punctuation">(</span><span class="StringLit">&quot;pkg-config --cflags sdl&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-passl编译指示" href="#特定实现的编译指示-passl编译指示">PassL编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">passL</span></tt> 编译指示 can be used to pass additional parameters to the linker like you would using the commandline switch <tt class="docutils literal"><span class="pre">--passL</span></tt>:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">passL</span><span class="Punctuation">:</span> <span class="StringLit">&quot;-lSDLmain -lSDL&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>Note that you can use <tt class="docutils literal"><span class="pre">gorge</span></tt> from the <a class="reference external" href="system.html">system module</a> to embed parameters from an external command that will be executed during semantic analysis:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">passL</span><span class="Punctuation">:</span> <span class="Identifier">gorge</span><span class="Punctuation">(</span><span class="StringLit">&quot;pkg-config --libs sdl&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-emit编译指示" href="#特定实现的编译指示-emit编译指示">Emit编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">emit</span></tt> 编译指示 can be used to directly affect the output of the compiler's code generator. So it makes your code unportable to other code generators/backends. Its usage is highly discouraged! However, it can be extremely useful for interfacing with <span id="cplusplus_1">C++</span> or <span id="objective-c_1">Objective C</span> code.</p>
<p>示例：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="LongStringLit">&quot;&quot;&quot;
static int cvariable = 420;
&quot;&quot;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">stackTrace</span><span class="Punctuation">:</span><span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">embedsC</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">nimVar</span> <span class="Operator">=</span> <span class="DecNumber">89</span>
  <span class="Comment"># access Nim symbols within an emit section outside of string literals:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="LongStringLit">&quot;&quot;&quot;fprintf(stdout, &quot;%d\n&quot;, cvariable + (int)&quot;&quot;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nimVar</span><span class="Punctuation">,</span> <span class="StringLit">&quot;);&quot;</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Identifier">embedsC</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p><tt class="docutils literal"><span class="pre">nimbase.h</span></tt> defines <tt class="docutils literal"><span class="pre">NIM_EXTERNC</span></tt> C macro that can be used for <tt class="docutils literal"><span class="pre">extern &quot;C&quot;</span></tt> code to work with both <tt class="docutils literal"><span class="pre">nim c</span></tt> and <tt class="docutils literal"><span class="pre">nim cpp</span></tt>, eg:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foobar</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span><span class="StringLit">&quot;$1&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="LongStringLit">&quot;&quot;&quot;
#include &lt;stdio.h&gt;
NIM_EXTERNC
void fun(){}
&quot;&quot;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>For backwards compatibility, if the argument to the <tt class="docutils literal"><span class="pre">emit</span></tt> statement is a single string literal, Nim symbols can be referred to via backticks. This usage is however deprecated.</p>
<p>For a toplevel emit statement the section where in the generated C/C++ file the code should be emitted can be influenced via the prefixes <tt class="docutils literal"><span class="pre">/*TYPESECTION*/</span></tt> or <tt class="docutils literal"><span class="pre">/*VARSECTION*/</span></tt> or <tt class="docutils literal"><span class="pre">/*INCLUDESECTION*/</span></tt>:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="LongStringLit">&quot;&quot;&quot;/*TYPESECTION*/
struct Vector3 {
public:
  Vector3(): x(5) {}
  Vector3(float x_): x(x_) {}
  float x;
};
&quot;&quot;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">type</span> <span class="Identifier">Vector3</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Vector3&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">cfloat</span>

<span class="Keyword">proc</span> <span class="Identifier">constructVector3</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">cfloat</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Vector3</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Vector3(@)&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-importcpp编译指示" href="#特定实现的编译指示-importcpp编译指示">ImportCpp编译指示</a></h2><p><strong>注意</strong>: <a class="reference external" href="https://github.com/nim-lang/c2nim/blob/master/doc/c2nim.rst">c2nim</a> 可以解析C++子集并且知道 <tt class="docutils literal"><span class="pre">importcpp</span></tt> 编译指示模式语言。 没有必要知道这里描述的所有细节。</p>
<p>Similar to the <a class="reference external" href="#foreign-function-interface-importc-pragma">importc pragma for C</a>, the <tt class="docutils literal"><span class="pre">importcpp</span></tt> pragma can be used to import <span id="cplusplus_2">C++</span> methods or C++ symbols in general. The generated code then uses the C++ method calling syntax: <tt class="docutils literal"><span class="pre">obj-&gt;method(arg)</span></tt>.  In combination with the <tt class="docutils literal"><span class="pre">header</span></tt> and <tt class="docutils literal"><span class="pre">emit</span></tt> pragmas this allows <em>sloppy</em> interfacing with libraries written in C++:</p>
<pre class="listing"><span class="Comment"># Horrible example of how to interface with a C++ engine ... ;-)</span>

<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">link</span><span class="Punctuation">:</span> <span class="StringLit">&quot;/usr/lib/libIrrlicht.so&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="LongStringLit">&quot;&quot;&quot;
using namespace irr;
using namespace core;
using namespace scene;
using namespace video;
using namespace io;
using namespace gui;
&quot;&quot;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">const</span>
  <span class="Identifier">irr</span> <span class="Operator">=</span> <span class="StringLit">&quot;&lt;irrlicht/irrlicht.h&gt;&quot;</span>

<span class="Keyword">type</span>
  <span class="Identifier">IrrlichtDeviceObj</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">header</span><span class="Punctuation">:</span> <span class="Identifier">irr</span><span class="Punctuation">,</span>
                      <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;IrrlichtDevice&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">IrrlichtDevice</span> <span class="Operator">=</span> <span class="Keyword">ptr</span> <span class="Identifier">IrrlichtDeviceObj</span>

<span class="Keyword">proc</span> <span class="Identifier">createDevice</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">IrrlichtDevice</span> <span class="Punctuation">{</span><span class="Operator">.</span>
  <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="Identifier">irr</span><span class="Punctuation">,</span> <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;createDevice(@)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">run</span><span class="Punctuation">(</span><span class="Identifier">device</span><span class="Punctuation">:</span> <span class="Identifier">IrrlichtDevice</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span>
  <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="Identifier">irr</span><span class="Punctuation">,</span> <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;#.run(@)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>The compiler needs to be told to generate C++ (command <tt class="docutils literal"><span class="pre">cpp</span></tt>) for this to work. The conditional symbol <tt class="docutils literal"><span class="pre">cpp</span></tt> is defined when the compiler emits C++ code.</p>

<h3><a class="toc-backref" id="importcpp编译指示-命名空间" href="#importcpp编译指示-命名空间">命名空间</a></h3><p>The <em>sloppy interfacing</em> example uses <tt class="docutils literal"><span class="pre">.emit</span></tt> to produce <tt class="docutils literal"><span class="pre">using namespace</span></tt> declarations. It is usually much better to instead refer to the imported name via the <tt class="docutils literal"><span class="pre">namespace::identifier</span></tt> notation:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">IrrlichtDeviceObj</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">header</span><span class="Punctuation">:</span> <span class="Identifier">irr</span><span class="Punctuation">,</span>
                      <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;irr::IrrlichtDevice&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span></pre>
<h3><a class="toc-backref" id="importcpp编译指示-枚举importcpp" href="#importcpp编译指示-枚举importcpp">枚举Importcpp</a></h3><p>When <tt class="docutils literal"><span class="pre">importcpp</span></tt> is applied to an enum type the numerical enum values are annotated with the C++ enum type, like in this 示例： <tt class="docutils literal"><span class="pre">((TheCppEnum)(3))</span></tt>. (This turned out to be the simplest way to implement it.)</p>

<h3><a class="toc-backref" id="importcpp编译指示-过程importcpp" href="#importcpp编译指示-过程importcpp">过程Importcpp</a></h3><p>Note that the <tt class="docutils literal"><span class="pre">importcpp</span></tt> variant for procs uses a somewhat cryptic pattern language for maximum flexibility:</p>
<ul class="simple"><li>A hash <tt class="docutils literal"><span class="pre">#</span></tt> symbol is replaced by the first or next argument.</li>
<li>A dot following the hash <tt class="docutils literal"><span class="pre">#.</span></tt> indicates that the call should use C++'s dot or arrow notation.</li>
<li>An at symbol <tt class="docutils literal"><span class="pre">@</span></tt> is replaced by the remaining arguments, separated by commas.</li>
</ul>
<p>示例：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">cppMethod</span><span class="Punctuation">(</span><span class="Identifier">this</span><span class="Punctuation">:</span> <span class="Identifier">CppObj</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;#.CppMethod(@)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">CppObj</span>
<span class="Identifier">cppMethod</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre><p>Produces:</p>
<pre class="listing"><span class="Identifier">x</span><span class="Operator">-&gt;</span><span class="Identifier">CppMethod</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre><p>As a special rule to keep backwards compatibility with older versions of the <tt class="docutils literal"><span class="pre">importcpp</span></tt> pragma, if there is no special pattern character (any of <tt class="docutils literal"><span class="pre"># ' @</span></tt>) at all, C++'s dot or arrow notation is assumed, so the above example can also be written as:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">cppMethod</span><span class="Punctuation">(</span><span class="Identifier">this</span><span class="Punctuation">:</span> <span class="Identifier">CppObj</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;CppMethod&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>Note that the pattern language naturally also covers C++'s operator overloading capabilities:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">vectorAddition</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Vec3</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Vec3</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;# + #&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">dictLookup</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Dict</span><span class="Punctuation">,</span> <span class="Identifier">k</span><span class="Punctuation">:</span> <span class="Identifier">Key</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Value</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;#[#]&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><ul class="simple"><li>An apostrophe <tt class="docutils literal"><span class="pre">'</span></tt> followed by an integer <tt class="docutils literal"><span class="pre">i</span></tt> in the range 0..9 is replaced by the i'th parameter <em>type</em>. The 0th position is the result type. This can be used to pass types to C++ function templates. Between the <tt class="docutils literal"><span class="pre">'</span></tt> and the digit an asterisk can be used to get to the base type of the type. (So it &quot;takes away a star&quot; from the type; <tt class="docutils literal"><span class="pre">T*</span></tt> becomes <tt class="docutils literal"><span class="pre">T</span></tt>.) Two stars can be used to get to the element type of the element type etc.</li>
</ul>
<p>示例：</p>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">Input</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;System::Input&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
<span class="Keyword">proc</span> <span class="Identifier">getSubsystem</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">T</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;SystemManager::getSubsystem&lt;'*0&gt;()&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">let</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Input</span> <span class="Operator">=</span> <span class="Identifier">getSubsystem</span><span class="Punctuation">[</span><span class="Identifier">Input</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>Produces:</p>
<pre class="listing"><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">SystemManager</span><span class="Punctuation">:</span><span class="Punctuation">:</span><span class="Identifier">getSubsystem</span><span class="Operator">&lt;</span><span class="Identifier">System</span><span class="Punctuation">:</span><span class="Punctuation">:</span><span class="Identifier">Input</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><ul class="simple"><li><tt class="docutils literal"><span class="pre">#@</span></tt> is a special case to support a <tt class="docutils literal"><span class="pre">cnew</span></tt> operation. It is required so that the call expression is inlined directly, without going through a temporary location. This is only required to circumvent a limitation of the current code generator.</li>
</ul>
<p>For example C++'s <tt class="docutils literal"><span class="pre">new</span></tt> operator can be &quot;imported&quot; like this:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">cnew</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">T</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;(new '*0#@)&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Comment"># constructor of 'Foo':</span>
<span class="Keyword">proc</span> <span class="Identifier">constructFoo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Foo</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Foo(@)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">cnew</span> <span class="Identifier">constructFoo</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span></pre><p>Produces:</p>
<pre class="listing"><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">new</span> <span class="Identifier">Foo</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span></pre><p>However, depending on the use case <tt class="docutils literal"><span class="pre">new Foo</span></tt> can also be wrapped like this instead:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">newFoo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Foo</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;new Foo(@)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">newFoo</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span></pre>
<h3><a class="toc-backref" id="importcpp编译指示-包装构造函数" href="#importcpp编译指示-包装构造函数">包装构造函数</a></h3><p>Sometimes a C++ class has a private copy constructor and so code like <tt class="docutils literal"><span class="pre">Class c = Class(1,2);</span></tt> must not be generated but instead <tt class="docutils literal"><span class="pre">Class c(1,2);</span></tt>. For this purpose the Nim proc that wraps a C++ constructor needs to be annotated with the <span id="constructor_1">constructor</span> pragma. This pragma also helps to generate faster C++ code since construction then doesn't invoke the copy constructor:</p>
<pre class="listing"><span class="Comment"># 更好的'Foo'构建函数：</span>
<span class="Keyword">proc</span> <span class="Identifier">constructFoo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Foo</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Foo(@)&quot;</span><span class="Punctuation">,</span> <span class="Identifier">constructor</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h3><a class="toc-backref" id="importcpp编译指示-包装析构函数" href="#importcpp编译指示-包装析构函数">包装析构函数</a></h3><p>包装destruct由于Nim直接生成C++，所以任何析构函数都由C++编译器在作用域出口处隐式调用。 这意味着通常人们可以完全没有包装析构函数！ 但是当需要显式调用它时，需要将其包装起来。 模式语言提供了所需的一切：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">destroyFoo</span><span class="Punctuation">(</span><span class="Identifier">this</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Foo</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;#.~Foo()&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h3><a class="toc-backref" id="importcpp编译指示-对象的importcpp" href="#importcpp编译指示-对象的importcpp">对象的Importcpp</a></h3><p>泛型 <tt class="docutils literal"><span class="pre">importcpp</span></tt> 的对象映射成C++模板。这意味着您可以轻松导入C++的模板，而无需对象类型的模式语言：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">StdMap</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;std::map&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;map&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Punctuation">[</span><span class="Identifier">K</span><span class="Punctuation">,</span> <span class="Identifier">V</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Identifier">K</span><span class="Punctuation">,</span> <span class="Identifier">V</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">this</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">StdMap</span><span class="Punctuation">[</span><span class="Identifier">K</span><span class="Punctuation">,</span> <span class="Identifier">V</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">key</span><span class="Punctuation">:</span> <span class="Identifier">K</span><span class="Punctuation">;</span> <span class="Identifier">val</span><span class="Punctuation">:</span> <span class="Identifier">V</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span>
  <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;#[#] = #&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;map&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">StdMap</span><span class="Punctuation">[</span><span class="Identifier">cint</span><span class="Punctuation">,</span> <span class="Identifier">cdouble</span><span class="Punctuation">]</span>
<span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="FloatNumber">91.4</span></pre><p>Produces:</p>
<pre class="listing"><span class="Identifier">std</span><span class="Punctuation">:</span><span class="Punctuation">:</span><span class="Identifier">map</span><span class="Operator">&lt;</span><span class="Keyword">int</span><span class="Punctuation">,</span> <span class="Keyword">double</span><span class="Operator">&gt;</span> <span class="Identifier">x</span><span class="Punctuation">;</span>
<span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="FloatNumber">91.4</span><span class="Punctuation">;</span></pre><ul class="simple"><li>If more precise control is needed, the apostrophe <tt class="docutils literal"><span class="pre">'</span></tt> can be used in the supplied pattern to denote the concrete type parameters of the generic type. See the usage of the apostrophe operator in proc patterns for more details.</li>
</ul>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">VectorIterator</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;std::vector&lt;'0&gt;::iterator&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>

<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">VectorIterator</span><span class="Punctuation">[</span><span class="Identifier">cint</span><span class="Punctuation">]</span></pre><p>Produces:</p>
<pre class="listing"><span class="Identifier">std</span><span class="Punctuation">:</span><span class="Punctuation">:</span><span class="Identifier">vector</span><span class="Operator">&lt;</span><span class="Keyword">int</span><span class="Operator">&gt;::</span><span class="Identifier">iterator</span> <span class="Identifier">x</span><span class="Punctuation">;</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-importobjc编译指示" href="#特定实现的编译指示-importobjc编译指示">ImportObjC编译指示</a></h2><p>Similar to the <a class="reference external" href="#foreign-function-interface-importc-pragma">importc pragma for C</a> , the <tt class="docutils literal"><span class="pre">importobjc</span></tt> pragma can be used to import <span id="objective-c_2">Objective C</span> methods.  The generated code then uses the Objective C method calling syntax: <tt class="docutils literal"><span class="pre">[obj method param1: arg]</span></tt>. In addition with the <tt class="docutils literal"><span class="pre">header</span></tt> and <tt class="docutils literal"><span class="pre">emit</span></tt> pragmas this allows <em>sloppy</em> interfacing with libraries written in Objective C:</p>
<pre class="listing"><span class="Comment"># horrible example of how to interface with GNUStep ...</span>

<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">passL</span><span class="Punctuation">:</span> <span class="StringLit">&quot;-lobjc&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="LongStringLit">&quot;&quot;&quot;
#include &lt;objc/Object.h&gt;
@interface Greeter:Object
{
}

- (void)greet:(long)x y:(long)dummy;
@end

#include &lt;stdio.h&gt;
@implementation Greeter

- (void)greet:(long)x y:(long)dummy
{
  printf(&quot;Hello, World!\n&quot;);
}
@end

#include &lt;stdlib.h&gt;
&quot;&quot;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">type</span>
  <span class="Identifier">Id</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;id&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;objc/Object.h&gt;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">final</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Identifier">newGreeter</span><span class="Punctuation">:</span> <span class="Identifier">Id</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importobjc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Greeter new&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">greet</span><span class="Punctuation">(</span><span class="Identifier">self</span><span class="Punctuation">:</span> <span class="Identifier">Id</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importobjc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;greet&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">free</span><span class="Punctuation">(</span><span class="Identifier">self</span><span class="Punctuation">:</span> <span class="Identifier">Id</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importobjc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;free&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">var</span> <span class="Identifier">g</span> <span class="Operator">=</span> <span class="Identifier">newGreeter</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">g</span><span class="Operator">.</span><span class="Identifier">greet</span><span class="Punctuation">(</span><span class="DecNumber">12</span><span class="Punctuation">,</span> <span class="DecNumber">34</span><span class="Punctuation">)</span>
<span class="Identifier">g</span><span class="Operator">.</span><span class="Identifier">free</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>The compiler needs to be told to generate Objective C (command <tt class="docutils literal"><span class="pre">objc</span></tt>) for this to work. The conditional symbol <tt class="docutils literal"><span class="pre">objc</span></tt> is defined when the compiler emits Objective C code.</p>

<h2><a class="toc-backref" id="特定实现的编译指示-codegendecl编译指示" href="#特定实现的编译指示-codegendecl编译指示">CodegenDecl编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">codegenDecl</span></tt> 编译指示 can be used to directly influence Nim's code generator. It receives a format string that determines how the variable or proc is declared in the generated code.</p>
<p>For variables $1 in the format string represents the type of the variable and $2 is the name of the variable.</p>
<p>The following Nim code:</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">codegenDecl</span><span class="Punctuation">:</span> <span class="StringLit">&quot;$# progmem $#&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>will generate this C code:</p>
<pre class="listing"><span class="Keyword">int</span> <span class="Identifier">progmem</span> <span class="Identifier">a</span></pre><p>For procedures $1 is the return type of the procedure, $2 is the name of the procedure and $3 is the parameter list.</p>
<p>The following nim code:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">myinterrupt</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">codegenDecl</span><span class="Punctuation">:</span> <span class="StringLit">&quot;__interrupt $# $#$#&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;realistic interrupt handler&quot;</span></pre><p>will generate this code:</p>
<pre class="listing"><span class="Identifier">__interrupt</span> <span class="Keyword">void</span> <span class="Identifier">myinterrupt</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-injectstmt编译指示" href="#特定实现的编译指示-injectstmt编译指示">InjectStmt编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">injectStmt</span></tt> 编译指示can be used to inject a statement before every other statement in the current module. It is only supposed to be used for debugging:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">injectStmt</span><span class="Punctuation">:</span> <span class="Identifier">gcInvariants</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Comment"># ... complex code here that produces crashes ...</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-编译期定义的编译指示" href="#特定实现的编译指示-编译期定义的编译指示">编译期定义的编译指示</a></h2><p>此处列出的编译指示可用于在编译时选择接受-d /--define选项中的值。</p>
<p>该实现目前提供以下可能的选项（稍后可以添加各种其他选项）。</p>
<table border="1" class="docutils"><tr><th>pragma</th><th>description</th></tr>
<tr><td><span id="intdefine_1">intdefine</span></td><td>读取构建时定义为整数</td></tr>
<tr><td><span id="strdefine_1">strdefine</span></td><td>读取构建时定义为字符串</td></tr>
<tr><td><span id="booldefine_1">booldefine</span></td><td>读取构建时定义为bool</td></tr>
</table><pre class="listing"><span class="Keyword">const</span> <span class="Identifier">FooBar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">intdefine</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">5</span>
<span class="Identifier">echo</span> <span class="Identifier">FooBar</span></pre><pre>nim c -d:FooBar=42 foobar.nim</pre>
<p>In the above example, providing the -d flag causes the symbol <tt class="docutils literal"><span class="pre">FooBar</span></tt> to be overwritten at compile time, printing out 42. If the <tt class="docutils literal"><span class="pre">-d:FooBar=42</span></tt> were to be omitted, the default value of 5 would be used. To see if a value was provided, <tt class="docutils literal"><span class="pre">defined(FooBar)</span></tt> can be used.</p>
<p>The syntax <tt class="docutils literal"><span class="pre">-d:flag</span></tt> is actually just a shortcut for <tt class="docutils literal"><span class="pre">-d:flag=true</span></tt>.</p>

<h2><a class="toc-backref" id="特定实现的编译指示-自定义标注" href="#特定实现的编译指示-自定义标注">自定义标注</a></h2><p>It is possible to define custom typed pragmas. Custom pragmas do not effect code generation directly, but their presence can be detected by macros. Custom pragmas are defined using templates annotated with pragma <tt class="docutils literal"><span class="pre">pragma</span></tt>:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">dbTable</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">table_space</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">template</span> <span class="Identifier">dbKey</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">primary_key</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">false</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">template</span> <span class="Identifier">dbForeignKey</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">template</span> <span class="Identifier">dbIgnore</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>Consider stylized example of possible Object Relation Mapping (ORM) implementation:</p>
<pre class="listing"><span class="Keyword">const</span> <span class="Identifier">tblspace</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">strdefine</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="StringLit">&quot;dev&quot;</span> <span class="Comment"># switch for dev, test and prod environments</span>

<span class="Keyword">type</span>
  <span class="Identifier">User</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbTable</span><span class="Punctuation">(</span><span class="StringLit">&quot;users&quot;</span><span class="Punctuation">,</span> <span class="Identifier">tblspace</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">id</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbKey</span><span class="Punctuation">(</span><span class="Identifier">primary_key</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">name</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="RawData">dbKey&quot;full_name&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">is_cached</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbIgnore</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">bool</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  
  <span class="Identifier">UserProfile</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbTable</span><span class="Punctuation">(</span><span class="StringLit">&quot;profiles&quot;</span><span class="Punctuation">,</span> <span class="Identifier">tblspace</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">id</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbKey</span><span class="Punctuation">(</span><span class="Identifier">primary_key</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">user_id</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbForeignKey</span><span class="Punctuation">:</span> <span class="Identifier">User</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">read_access</span><span class="Punctuation">:</span> <span class="Identifier">bool</span>
    <span class="Identifier">write_access</span><span class="Punctuation">:</span> <span class="Identifier">bool</span>
    <span class="Identifier">admin_acess</span><span class="Punctuation">:</span> <span class="Identifier">bool</span></pre><p>In this example custom pragmas are used to describe how Nim objects are mapped to the schema of the relational database. Custom pragmas can have zero or more arguments. In order to pass multiple arguments use one of template call syntaxes. All arguments are typed and follow standard overload resolution rules for templates. Therefore, it is possible to have default values for arguments, pass by name, varargs, etc.</p>
<p>Custom pragmas can be used in all locations where ordinary pragmas can be specified. It is possible to annotate procs, templates, type and variable definitions, statements, etc.</p>
<p>Macros module includes helpers which can be used to simplify custom pragma access <tt class="docutils literal"><span class="pre">hasCustomPragma</span></tt>, <tt class="docutils literal"><span class="pre">getCustomPragmaVal</span></tt>. Please consult macros module documentation for details. These macros are no magic, they don't do anything you cannot do yourself by walking AST object representation.</p>
<p>More examples with custom pragmas:</p>
<ul class="simple"><li>Better serialization/deserialization control:</li>
</ul>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">MyObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">a</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dontSerialize</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">b</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">defaultDeserialize</span><span class="Punctuation">:</span> <span class="FloatNumber">5.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">c</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">serializationKey</span><span class="Punctuation">:</span> <span class="StringLit">&quot;_c&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre><ul class="simple"><li>Adopting type for gui inspector in a game engine:</li>
</ul>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">MyComponent</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">position</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">editable</span><span class="Punctuation">,</span> <span class="Identifier">animatable</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">Vector3</span>
  <span class="Identifier">alpha</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">editRange</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="FloatNumber">0.0</span><span class="Operator">..</span><span class="FloatNumber">1.0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">animatable</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">float32</span></pre>
<h1><a class="toc-backref" id="外部函数接口" href="#外部函数接口">外部函数接口</a></h1><p>Nim的 <span id="ffi_1">FFI</span> (外部函数接口) 非常广泛，这里只记载扩展到其它未来后端的部分 (如 LLVM/JavaScript后端)。</p>

<h2><a class="toc-backref" id="外部函数接口-importc编译指示" href="#外部函数接口-importc编译指示">Importc编译指示</a></h2><p><tt class="docutils literal"><span class="pre">importc</span></tt> 编译指示提供了一种从C导入proc或变量的方法。 可选参数是包含C标识符的字符串。 如果缺少参数，则C名称与Nim标识符 <em>拼写完全相同</em> ：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;stdio.h&gt;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;printf&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>请注意，此pragma有点用词不当：其他后端确实在同一名称下提供相同的功能。</p>
<p>此外，如果一个人正在与C++接口，那么 <a class="reference external" href="manual.html＃implementation-specific-pragmas-importcpp-pragma">ImportCpp pragma</a> 并与Objective-C连接 <a class="reference external" href="manual.html＃implementation-specific-pragmas- importobjc-pragma">importObjC pragma</a> 可以使用。</p>
<p>传递给``importc``的字符串文字可以是格式字符串：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;prefix$1&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>在示例中，``p`` 的外部名称设置为 <tt class="docutils literal"><span class="pre">prefixp</span></tt> 。 只有 <tt class="docutils literal"><span class="pre">$1</span></tt> 可用，文字美元符号必须写成 <tt class="docutils literal"><span class="pre">$$</span></tt> 。</p>

<h2><a class="toc-backref" id="外部函数接口-exportc编译指示" href="#外部函数接口-exportc编译指示">Exportc编译指示</a></h2><p>The <tt class="docutils literal"><span class="pre">exportc</span></tt> pragma provides a means to export a type, a variable, or a procedure to C. Enums and constants can't be exported. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier <em>exactly as spelled</em>:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">exportc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;callMe&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name.</p>
<p>The string literal passed to <tt class="docutils literal"><span class="pre">exportc</span></tt> can be a format string:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">exportc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;prefix$1&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">s</span></pre><p>In the example the external name of <tt class="docutils literal"><span class="pre">p</span></tt> is set to <tt class="docutils literal"><span class="pre">prefixp</span></tt>. Only <tt class="docutils literal"><span class="pre">$1</span></tt> is available and a literal dollar sign must be written as <tt class="docutils literal"><span class="pre">$$</span></tt>.</p>

<h2><a class="toc-backref" id="外部函数接口-extern编译指示" href="#外部函数接口-extern编译指示">Extern编译指示</a></h2><p>Like <tt class="docutils literal"><span class="pre">exportc</span></tt> or <tt class="docutils literal"><span class="pre">importc</span></tt>, the <tt class="docutils literal"><span class="pre">extern</span></tt> pragma affects name mangling. The string literal passed to <tt class="docutils literal"><span class="pre">extern</span></tt> can be a format string:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">extern</span><span class="Punctuation">:</span> <span class="StringLit">&quot;prefix$1&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">s</span></pre><p>In the example the external name of <tt class="docutils literal"><span class="pre">p</span></tt> is set to <tt class="docutils literal"><span class="pre">prefixp</span></tt>. Only <tt class="docutils literal"><span class="pre">$1</span></tt> is available and a literal dollar sign must be written as <tt class="docutils literal"><span class="pre">$$</span></tt>.</p>

<h2><a class="toc-backref" id="外部函数接口-bycopy编译指示" href="#外部函数接口-bycopy编译指示">Bycopy编译指示</a></h2><p><tt class="docutils literal"><span class="pre">bycopy</span></tt> 编译指示可以应用于对象或元组类型，并指示编译器按类型将类型传递给procs：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Vector</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">bycopy</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">float</span></pre>
<h2><a class="toc-backref" id="外部函数接口-byref编译指示" href="#外部函数接口-byref编译指示">Byref编译指示</a></h2><p><tt class="docutils literal"><span class="pre">byref</span></tt> 编译指示可以应用于对象或元组类型，并指示编译器通过引用（隐藏指针）将类型传递给procs。</p>

<h2><a class="toc-backref" id="外部函数接口-varargs编译指示" href="#外部函数接口-varargs编译指示">Varargs编译指示</a></h2><p><tt class="docutils literal"><span class="pre">varargs</span></tt> 编译指示只适用于过程 (和过程类型)。 它告诉Nim proc可以在最后指定的参数获取可变数量的参数。 Nim字符串值将自动转换为C字符串：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">nodecl</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Identifier">printf</span><span class="Punctuation">(</span><span class="StringLit">&quot;hallo %s&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;world&quot;</span><span class="Punctuation">)</span> <span class="Comment"># &quot;world&quot;将作为C字符串传递</span></pre>
<h2><a class="toc-backref" id="外部函数接口-union编译指示" href="#外部函数接口-union编译指示">Union编译指示</a></h2><p><tt class="docutils literal"><span class="pre">union</span></tt> 编译指示适用于任何 <tt class="docutils literal"><span class="pre">对象</span></tt> 类型。 这意味着所有对象的字段在内存中是重叠的。 这会在生成的C / C ++代码中生成一个 <tt class="docutils literal"><span class="pre">union</span></tt> 而不是 <tt class="docutils literal"><span class="pre">struct</span></tt> 。 然后，对象声明不能使用继承或任何GC的内存，但目前尚不做检查。</p>
<p><strong>未来方向</strong>: 应该允许在联合中使用GC内存并且GC应当保守地扫描联合。</p>

<h2><a class="toc-backref" id="外部函数接口-packed编译指示" href="#外部函数接口-packed编译指示">Packed编译指示</a></h2><p><tt class="docutils literal"><span class="pre">packed</span></tt> 编译指示适用于任何 <tt class="docutils literal"><span class="pre">对象</span></tt> 类型。 它确保对象的字段打包在连续的内存中。 将数据包或消息存储到网络或硬件驱动程序以及与C的互操作性非常有用。 没有定义packed编译指示的继承用法，且不应该与GC的内存（ref）一起使用。</p>
<p><strong>未来方向</strong>: 在packed pragma中使用GC内存将导致静态错误。应该定义和记录继承的用法。</p>

<h2><a class="toc-backref" id="外部函数接口-用于导入的dynlib编译指示" href="#外部函数接口-用于导入的dynlib编译指示">用于导入的Dynlib编译指示</a></h2><p>使用 <tt class="docutils literal"><span class="pre">dynlib</span></tt> 编译指示，可以从动态库（Windows的 <tt class="docutils literal"><span class="pre">.dll</span></tt> 文件，UNIX的 <tt class="docutils literal"><span class="pre">lib*.so</span></tt> 文件）导入过程或变量。</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">gtk_image_new</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PGtkWidget</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;libgtk-x11-2.0.so&quot;</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>通常，导入动态库不需要任何特殊的链接器选项或链接到导入库。 这也意味着不需要安装 <em>开发</em> 包。</p>
<p><tt class="docutils literal"><span class="pre">dynlib</span></tt> 导入机制支持版本控制方案：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">Tcl_Eval</span><span class="Punctuation">(</span><span class="Identifier">interp</span><span class="Punctuation">:</span> <span class="Identifier">pTcl_Interp</span><span class="Punctuation">,</span> <span class="Identifier">script</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span>
  <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;libtcl(|8.5|8.4|8.3).so.(1|0)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>在运行时，搜索动态库（按此顺序）</p>
<blockquote><p>libtcl.so.1 libtcl.so.0 libtcl8.5.so.1 libtcl8.5.so.0 libtcl8.4.so.1 libtcl8.4.so.0 libtcl8.3.so.1 libtcl8.3.so.0</p></blockquote>
<p><tt class="docutils literal"><span class="pre">dynlib</span></tt> 编译指示不仅支持常量字符串作为参数，还支持字符串表达式：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">os</span>

<span class="Keyword">proc</span> <span class="Identifier">getDllName</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;mylib.dll&quot;</span>
  <span class="Keyword">if</span> <span class="Identifier">existsFile</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;mylib2.dll&quot;</span>
  <span class="Keyword">if</span> <span class="Identifier">existsFile</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span>
  <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;could not load dynamic library&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">myImport</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="Identifier">getDllName</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p><strong>注意</strong>: 形如 <tt class="docutils literal"><span class="pre">libtcl(|8.5|8.4).so</span></tt> 只支持常量字符串，因为它们需要预编译。</p>
<p><strong>注意</strong>: 传变量给 <tt class="docutils literal"><span class="pre">dynlib</span></tt> pragma 在进行时会失败，因为初始化问题的顺序。</p>
<p><strong>注意</strong>: <tt class="docutils literal"><span class="pre">dynlib</span></tt> 导入可以用 <tt class="docutils literal"><span class="pre">--dynlibOverride:name</span></tt> 命令行选项重写。 编译器用户指南包括更多信息。</p>

<h2><a class="toc-backref" id="外部函数接口-用于导出的dynlib编译指示" href="#外部函数接口-用于导出的dynlib编译指示">用于导出的Dynlib编译指示</a></h2><p>过程可以用 <tt class="docutils literal"><span class="pre">dynlib</span></tt> 编译指示导出到一个动态库。 编译指示没有实参而且必须和 <tt class="docutils literal"><span class="pre">exportc</span></tt> 拼接在一起:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">exportme</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">exportc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>这只有当程序通过 <tt class="docutils literal"><span class="pre">--app:lib</span></tt> 命令行选项编译为动态库时有用。 此编译指示仅对Windows目标上的代码生成有影响，因此当忘写并且仅在Mac和/或Linux上测试动态库时，不会出现错误。 在Windows上，这个编译指示在函数声明中添加了 <tt class="docutils literal"><span class="pre">__declspec(dllexport)</span></tt> 。</p>

<h1><a class="toc-backref" id="线程" href="#线程">线程</a></h1><p>要启用线程支持，需要使用 <tt class="docutils literal"><span class="pre">--threads:on</span></tt> 命令行开关。 然后 <tt class="docutils literal"><span class="pre">system</span></tt> 模块包含几个线程原语。 请参阅低级线程API <a class="reference external" href="threads.html">threads</a> 和 <a class="reference external" href="channels.html">channels</a>  模块。 还有高级并行结构可用。见 <a class="reference external" href="manual_experimental.html#parallel-amp-spawn">spawn</a> 更多细节。</p>
<p>Nim's memory model for threads is quite different than that of other common programming languages (C, Pascal, Java): Each thread has its own (garbage collected) heap and sharing of memory is restricted to global variables. This helps to prevent race conditions. GC efficiency is improved quite a lot, because the GC never has to stop other threads and see what they reference.</p>

<h2><a class="toc-backref" id="线程-thread编译指示" href="#线程-thread编译指示">Thread编译指示</a></h2><p>A proc that is executed as a new thread of execution should be marked by the <tt class="docutils literal"><span class="pre">thread</span></tt> pragma for reasons of readability. The compiler checks for violations of the <span id="no-heap-sharing-restriction_1">no heap sharing restriction</span>: This restriction implies that it is invalid to construct a data structure that consists of memory allocated from different (thread local) heaps.</p>
<p>A thread proc is passed to <tt class="docutils literal"><span class="pre">createThread</span></tt> or <tt class="docutils literal"><span class="pre">spawn</span></tt> and invoked indirectly; so the <tt class="docutils literal"><span class="pre">thread</span></tt> pragma implies <tt class="docutils literal"><span class="pre">procvar</span></tt>.</p>

<h2><a class="toc-backref" id="线程-gc安全" href="#线程-gc安全">GC安全</a></h2><p>我们称过程 <tt class="docutils literal"><span class="pre">p</span></tt> <span id="gc安全_1">GC安全</span> ，当它不通过调用GC不安全的过程直接或间接访问任何含有GC内存的全局变量(<tt class="docutils literal"><span class="pre">string</span></tt>, <tt class="docutils literal"><span class="pre">seq</span></tt>, <tt class="docutils literal"><span class="pre">ref</span></tt> 或闭包)。</p>
<p>The <span id="gcsafe_1">gcsafe</span> annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that <tt class="docutils literal"><span class="pre">noSideEffect</span></tt> implies <tt class="docutils literal"><span class="pre">gcsafe</span></tt>. The only way to create a thread is via <tt class="docutils literal"><span class="pre">spawn</span></tt> or <tt class="docutils literal"><span class="pre">createThread</span></tt>. The invoked proc must not use <tt class="docutils literal"><span class="pre">var</span></tt> parameters nor must any of its parameters contain a <tt class="docutils literal"><span class="pre">ref</span></tt> or <tt class="docutils literal"><span class="pre">closure</span></tt> type. This enforces the <em>no heap sharing restriction</em>.</p>
<p>Routines that are imported from C are always assumed to be <tt class="docutils literal"><span class="pre">gcsafe</span></tt>. To disable the GC-safety checking the <tt class="docutils literal"><span class="pre">--threadAnalysis:off</span></tt> command line switch can be used. This is a temporary workaround to ease the porting effort from old code to the new threading model.</p>
<p>To override the compiler's gcsafety analysis a <tt class="docutils literal"><span class="pre">{.gcsafe.}</span></tt> pragma block can be used:</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">someGlobal</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string here&quot;</span>
  <span class="Identifier">perThread</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">threadvar</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Keyword">proc</span> <span class="Identifier">setPerThread</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">gcsafe</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">deepCopy</span><span class="Punctuation">(</span><span class="Identifier">perThread</span><span class="Punctuation">,</span> <span class="Identifier">someGlobal</span><span class="Punctuation">)</span></pre><p>Future directions:</p>
<ul class="simple"><li>A shared GC'ed heap might be provided.</li>
</ul>

<h2><a class="toc-backref" id="线程-threadvar编译指示" href="#线程-threadvar编译指示">Threadvar编译指示</a></h2><p>变量可以用 <tt class="docutils literal"><span class="pre">threadvar</span></tt> 编译指示标记，使它成为 <span id="threadminuslocal_1">thread-local</span> 变量; 另外，这意味着 <tt class="docutils literal"><span class="pre">global</span></tt> 编译指示的所有效果。</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">checkpoints</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">threadvar</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span></pre><p>由于实现限制，无法在 <tt class="docutils literal"><span class="pre">var</span></tt> 部分中初始化线程局部变量。 （在创建线程时需要复制每个线程局部变量。）</p>

<h2><a class="toc-backref" id="线程-线程和异常" href="#线程-线程和异常">线程和异常</a></h2><p>线程和异常之间的交互很简单：一个线程中的 <em>处理过的</em> 异常不会影响任何其他线程。但是，一个线程中的 <em>未处理的</em> 异常终止整个 <em>进程</em> ！</p>
</p>
  
  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small>Made with Nim. Generated: 2019-08-22 13:27:01 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
